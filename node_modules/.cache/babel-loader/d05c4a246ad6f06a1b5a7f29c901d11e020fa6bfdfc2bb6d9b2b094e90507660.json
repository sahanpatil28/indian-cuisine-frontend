{"ast":null,"code":"import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones, includeShadowRoots) {\n  return getNextElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones, undefined, undefined, undefined, includeShadowRoots);\n}\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones, includeShadowRoots) {\n  return getPreviousElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones, undefined, undefined, includeShadowRoots);\n}\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode, includeShadowRoots) {\n  if (checkNode === void 0) {\n    checkNode = true;\n  }\n  return getNextElement(rootElement, currentElement, checkNode, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/, undefined, includeShadowRoots);\n}\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode, includeShadowRoots) {\n  if (checkNode === void 0) {\n    checkNode = true;\n  }\n  return getPreviousElement(rootElement, currentElement, checkNode, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/, includeShadowRoots);\n}\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(rootElement, bypassHiddenElements, includeShadowRoots) {\n  var element = getNextElement(rootElement, rootElement, true, false, false, true, undefined, undefined, bypassHiddenElements, includeShadowRoots);\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n  return false;\n}\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots) {\n  var _a;\n  if (!currentElement || !allowFocusRoot && currentElement === rootElement) {\n    return null;\n  }\n  var isCurrentElementVisible = isElementVisible(currentElement);\n  // Check its children.\n  if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var lastElementChild = currentElement.lastElementChild || includeShadowRoots && ((_a = currentElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.lastElementChild);\n    var childMatch = getPreviousElement(rootElement, lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n    if (childMatch) {\n      if (tabbable && isElementTabbable(childMatch, true, includeShadowRoots) || !tabbable) {\n        return childMatch;\n      }\n      var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n      var childMatchParent = childMatch.parentElement;\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n    return currentElement;\n  }\n  // Check its previous sibling.\n  var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n  }\n  return null;\n}\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\nexport function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots) {\n  var _a;\n  if (!currentElement || currentElement === rootElement && suppressChildTraversal && !allowFocusRoot) {\n    return null;\n  }\n  var checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;\n  var isCurrentElementVisible = checkElementVisibility(currentElement);\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n    return currentElement;\n  }\n  // Check its children.\n  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var firstElementchild = currentElement.firstElementChild || includeShadowRoots && ((_a = currentElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.firstElementChild);\n    var childMatch = getNextElement(rootElement, firstElementchild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots);\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n  if (currentElement === rootElement) {\n    return null;\n  }\n  // Check its sibling.\n  var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots);\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n  if (!suppressParentTraversal) {\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots);\n  }\n  return null;\n}\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element) {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n  var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n  // Fallback to other methods of determining actual visibility.\n  return element.offsetHeight !== 0 || element.offsetParent !== null ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  element.isVisible === true; // used as a workaround for testing.\n}\n/**\n * Determines if an element is visible and not hidden\n * @param element - Element to check\n * @returns Returns true if the given element is visible and not hidden\n *\n * @public\n */\nexport function isElementVisibleAndNotHidden(element, win) {\n  var theWin = win !== null && win !== void 0 ? win : getWindow();\n  return !!element && isElementVisible(element) && !element.hidden && theWin.getComputedStyle(element).visibility !== 'hidden';\n}\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element, checkTabIndex, checkShadowRoot) {\n  if (checkShadowRoot === void 0) {\n    checkShadowRoot = true;\n  }\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || element.disabled) {\n    return false;\n  }\n  var tabIndex = 0;\n  var tabIndexAttributeValue = null;\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n  var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n  var delegatesFocus = checkShadowRoot && element.shadowRoot ? !!element.shadowRoot.delegatesFocus : false;\n  var result = !!element && isFocusableAttribute !== 'false' && (element.tagName === 'A' || element.tagName === 'BUTTON' || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT' || isFocusableAttribute === 'true' || isTabIndexSet || delegatesFocus);\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element) {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element) {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element) {\n  var doc = getDocument(element);\n  var currentActiveElement = doc && doc.activeElement;\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(element, noWrapDataAttribute, doc) {\n  var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();\n  return elementContainsAttribute(element, noWrapDataAttribute, theDoc) === 'true' ? false : true;\n}\nvar animationId = undefined;\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element) {\n  if (element) {\n    var win = getWindow(element);\n    if (win) {\n      // cancel any previous focus queues\n      if (animationId !== undefined) {\n        win.cancelAnimationFrame(animationId);\n      }\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      animationId = win.requestAnimationFrame(function () {\n        element && element.focus();\n        // We are done focusing for this frame, so reset the queued focus element\n        animationId = undefined;\n      });\n    }\n  }\n}\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent, path) {\n  var element = parent;\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var index = path_1[_i];\n    var nextChild = element.children[Math.min(index, element.children.length - 1)];\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n  element = isElementTabbable(element) && isElementVisible(element) ? element : getNextElement(parent, element, true) || getPreviousElement(parent, element);\n  return element;\n}\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement, toElement) {\n  var path = [];\n  while (toElement && fromElement && toElement !== fromElement) {\n    var parent_1 = getParent(toElement, true);\n    if (parent_1 === null) {\n      return [];\n    }\n    path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));\n    toElement = parent_1;\n  }\n  return path;\n}","map":{"version":3,"names":["elementContainsAttribute","elementContains","getParent","getWindow","getDocument","IS_FOCUSABLE_ATTRIBUTE","IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","getFirstFocusable","rootElement","currentElement","includeElementsInFocusZones","includeShadowRoots","getNextElement","undefined","getLastFocusable","getPreviousElement","getFirstTabbable","checkNode","getLastTabbable","focusFirstChild","bypassHiddenElements","element","focusAsync","suppressParentTraversal","traverseChildren","allowFocusRoot","tabbable","isCurrentElementVisible","isElementVisible","isElementFocusZone","isElementFocusSubZone","lastElementChild","_a","shadowRoot","childMatch","isElementTabbable","childMatchSiblingMatch","previousElementSibling","childMatchParent","parentElement","childMatchParentMatch","siblingMatch","suppressChildTraversal","checkElementVisibility","isElementVisibleAndNotHidden","firstElementchild","firstElementChild","nextElementSibling","getAttribute","visibilityAttribute","offsetHeight","offsetParent","isVisible","win","theWin","hidden","getComputedStyle","visibility","checkTabIndex","checkShadowRoot","disabled","tabIndex","tabIndexAttributeValue","parseInt","isFocusableAttribute","isTabIndexSet","delegatesFocus","result","tagName","doesElementContainFocus","doc","currentActiveElement","activeElement","shouldWrapFocus","noWrapDataAttribute","theDoc","animationId","cancelAnimationFrame","requestAnimationFrame","focus","getFocusableByIndexPath","parent","path","_i","path_1","length","index","nextChild","children","Math","min","getElementIndexPath","fromElement","toElement","parent_1","unshift","Array","prototype","indexOf","call"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\utilities\\src\\focus.ts"],"sourcesContent":["import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n    undefined,\n    undefined,\n    undefined,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n    undefined,\n    undefined,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n    undefined,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n    includeShadowRoots,\n  );\n}\n\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(\n  rootElement: HTMLElement,\n  bypassHiddenElements?: boolean,\n  includeShadowRoots?: boolean,\n): boolean {\n  let element: HTMLElement | null = getNextElement(\n    rootElement,\n    rootElement,\n    true,\n    false,\n    false,\n    true,\n    undefined,\n    undefined,\n    bypassHiddenElements,\n    includeShadowRoots,\n  );\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const lastElementChild = (currentElement.lastElementChild ||\n      (includeShadowRoots && currentElement.shadowRoot?.lastElementChild)) as HTMLElement;\n\n    const childMatch = getPreviousElement(\n      rootElement,\n      lastElementChild,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      includeShadowRoots,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true, includeShadowRoots)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        allowFocusRoot,\n        tabbable,\n        includeShadowRoots,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          allowFocusRoot,\n          tabbable,\n          includeShadowRoots,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n    includeShadowRoots,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      includeShadowRoots,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n  bypassHiddenElements?: boolean,\n  includeShadowRoots?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\n    return null;\n  }\n\n  const checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;\n\n  let isCurrentElementVisible = checkElementVisibility(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const firstElementchild = (currentElement.firstElementChild ||\n      (includeShadowRoots && currentElement.shadowRoot?.firstElementChild)) as HTMLElement;\n\n    const childMatch = getNextElement(\n      rootElement,\n      firstElementchild,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      bypassHiddenElements,\n      includeShadowRoots,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n    bypassHiddenElements,\n    includeShadowRoots,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n      bypassHiddenElements,\n      includeShadowRoots,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element is visible and not hidden\n * @param element - Element to check\n * @returns Returns true if the given element is visible and not hidden\n *\n * @public\n */\nexport function isElementVisibleAndNotHidden(element: HTMLElement | undefined | null, win?: Window): boolean {\n  const theWin = win ?? getWindow()!;\n  return (\n    !!element &&\n    isElementVisible(element) &&\n    !element.hidden &&\n    theWin.getComputedStyle(element).visibility !== 'hidden'\n  );\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(\n  element: HTMLElement,\n  checkTabIndex?: boolean,\n  checkShadowRoot: boolean = true,\n): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n  let delegatesFocus = checkShadowRoot && element.shadowRoot ? !!element.shadowRoot.delegatesFocus : false;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.tagName === 'SELECT' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet ||\n      delegatesFocus);\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element: HTMLElement): boolean {\n  let doc = getDocument(element);\n  let currentActiveElement: HTMLElement | undefined = doc && (doc.activeElement as HTMLElement);\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(\n  element: HTMLElement,\n  noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  doc?: Document,\n): boolean {\n  const theDoc = doc ?? getDocument()!;\n  return elementContainsAttribute(element, noWrapDataAttribute, theDoc) === 'true' ? false : true;\n}\n\nlet animationId: number | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // cancel any previous focus queues\n      if (animationId !== undefined) {\n        win.cancelAnimationFrame(animationId);\n      }\n\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      animationId = win.requestAnimationFrame(() => {\n        element && element.focus();\n\n        // We are done focusing for this frame, so reset the queued focus element\n        animationId = undefined;\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n\n  while (toElement && fromElement && toElement !== fromElement) {\n    const parent = getParent(toElement, true);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, toElement));\n    toElement = parent;\n  }\n\n  return path;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}