{"ast":null,"code":"import { getDocument } from './dom/getDocument';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getWindow } from './dom/getWindow';\nvar _scrollbarWidth;\nvar _bodyScrollDisabledCount = 0;\nvar DisabledScrollClassName = mergeStyles({\n  overflow: 'hidden !important'\n});\n/**\n * Placing this attribute on scrollable divs optimizes detection to know\n * if the div is scrollable or not (given we can avoid expensive operations\n * like getComputedStyle.)\n *\n * @public\n */\nexport var DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';\n/**\n * Allows the user to scroll within a element,\n * while preventing the user from scrolling the body\n */\nexport var allowScrollOnElement = function (element, events) {\n  var window = getWindow(element);\n  if (!element || !window) {\n    return;\n  }\n  var _previousClientY = 0;\n  var _element = null;\n  var computedStyles = window.getComputedStyle(element);\n  // remember the clientY for future calls of _preventOverscrolling\n  var _saveClientY = function (event) {\n    if (event.targetTouches.length === 1) {\n      _previousClientY = event.targetTouches[0].clientY;\n    }\n  };\n  // prevent the body from scrolling when the user attempts\n  // to scroll past the top or bottom of the element\n  var _preventOverscrolling = function (event) {\n    // only respond to a single-finger touch\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n    // prevent the body touchmove handler from firing\n    // so that scrolling is allowed within the element\n    event.stopPropagation();\n    if (!_element) {\n      return;\n    }\n    var clientY = event.targetTouches[0].clientY - _previousClientY;\n    var scrollableParent = findScrollableParent(event.target);\n    if (scrollableParent && _element !== scrollableParent) {\n      _element = scrollableParent;\n      computedStyles = window.getComputedStyle(_element);\n    }\n    var scrollTop = _element.scrollTop;\n    var isColumnReverse = (computedStyles === null || computedStyles === void 0 ? void 0 : computedStyles.flexDirection) === 'column-reverse';\n    // if the element is scrolled to the top,\n    // prevent the user from scrolling up\n    if (scrollTop === 0 && (isColumnReverse ? clientY < 0 : clientY > 0)) {\n      event.preventDefault();\n    }\n    // if the element is scrolled to the bottom,\n    // prevent the user from scrolling down\n    if (_element.scrollHeight - Math.abs(Math.ceil(scrollTop)) <= _element.clientHeight && (isColumnReverse ? clientY > 0 : clientY < 0)) {\n      event.preventDefault();\n    }\n  };\n  events.on(element, 'touchstart', _saveClientY, {\n    passive: false\n  });\n  events.on(element, 'touchmove', _preventOverscrolling, {\n    passive: false\n  });\n  _element = element;\n};\n/**\n * Same as allowScrollOnElement but does not prevent overscrolling.\n */\nexport var allowOverscrollOnElement = function (element, events) {\n  if (!element) {\n    return;\n  }\n  var _allowElementScroll = function (event) {\n    event.stopPropagation();\n  };\n  events.on(element, 'touchmove', _allowElementScroll, {\n    passive: false\n  });\n};\nvar _disableIosBodyScroll = function (event) {\n  event.preventDefault();\n};\n/**\n * Disables the body scrolling.\n *\n * @public\n */\nexport function disableBodyScroll() {\n  var doc = getDocument();\n  if (doc && doc.body && !_bodyScrollDisabledCount) {\n    doc.body.classList.add(DisabledScrollClassName);\n    doc.body.addEventListener('touchmove', _disableIosBodyScroll, {\n      passive: false,\n      capture: false\n    });\n  }\n  _bodyScrollDisabledCount++;\n}\n/**\n * Enables the body scrolling.\n *\n * @public\n */\nexport function enableBodyScroll() {\n  if (_bodyScrollDisabledCount > 0) {\n    var doc = getDocument();\n    if (doc && doc.body && _bodyScrollDisabledCount === 1) {\n      doc.body.classList.remove(DisabledScrollClassName);\n      doc.body.removeEventListener('touchmove', _disableIosBodyScroll);\n    }\n    _bodyScrollDisabledCount--;\n  }\n}\n/**\n * Calculates the width of a scrollbar for the browser/os.\n *\n * @public\n */\nexport function getScrollbarWidth(doc) {\n  if (_scrollbarWidth === undefined) {\n    var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();\n    var scrollDiv = theDoc.createElement('div');\n    scrollDiv.style.setProperty('width', '100px');\n    scrollDiv.style.setProperty('height', '100px');\n    scrollDiv.style.setProperty('overflow', 'scroll');\n    scrollDiv.style.setProperty('position', 'absolute');\n    scrollDiv.style.setProperty('top', '-9999px');\n    theDoc.body.appendChild(scrollDiv);\n    // Get the scrollbar width\n    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    // Delete the DIV\n    theDoc.body.removeChild(scrollDiv);\n  }\n  return _scrollbarWidth;\n}\n/**\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\n * document.body.\n *\n * @public\n */\nexport function findScrollableParent(startingElement) {\n  var el = startingElement;\n  var doc = getDocument(startingElement);\n  // First do a quick scan for the scrollable attribute.\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\n      return el;\n    }\n    el = el.parentElement;\n  }\n  // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\n  el = startingElement;\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\n      var computedStyles = getComputedStyle(el);\n      var overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';\n      if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\n        return el;\n      }\n    }\n    el = el.parentElement;\n  }\n  // Fall back to window scroll.\n  if (!el || el === doc.body) {\n    el = getWindow(startingElement);\n  }\n  return el;\n}","map":{"version":3,"names":["getDocument","mergeStyles","getWindow","_scrollbarWidth","_bodyScrollDisabledCount","DisabledScrollClassName","overflow","DATA_IS_SCROLLABLE_ATTRIBUTE","allowScrollOnElement","element","events","window","_previousClientY","_element","computedStyles","getComputedStyle","_saveClientY","event","targetTouches","length","clientY","_preventOverscrolling","stopPropagation","scrollableParent","findScrollableParent","target","scrollTop","isColumnReverse","flexDirection","preventDefault","scrollHeight","Math","abs","ceil","clientHeight","on","passive","allowOverscrollOnElement","_allowElementScroll","_disableIosBodyScroll","disableBodyScroll","doc","body","classList","add","addEventListener","capture","enableBodyScroll","remove","removeEventListener","getScrollbarWidth","undefined","theDoc","scrollDiv","createElement","style","setProperty","appendChild","offsetWidth","clientWidth","removeChild","startingElement","el","getAttribute","parentElement","overflowY","getPropertyValue"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\utilities\\src\\scroll.ts"],"sourcesContent":["import { getDocument } from './dom/getDocument';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { EventGroup } from './EventGroup';\nimport { getWindow } from './dom/getWindow';\n\nlet _scrollbarWidth: number;\nlet _bodyScrollDisabledCount = 0;\n\nconst DisabledScrollClassName = mergeStyles({\n  overflow: 'hidden !important' as 'hidden',\n});\n\n/**\n * Placing this attribute on scrollable divs optimizes detection to know\n * if the div is scrollable or not (given we can avoid expensive operations\n * like getComputedStyle.)\n *\n * @public\n */\nexport const DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';\n\n/**\n * Allows the user to scroll within a element,\n * while preventing the user from scrolling the body\n */\nexport const allowScrollOnElement = (element: HTMLElement | null, events: EventGroup): void => {\n  const window = getWindow(element);\n\n  if (!element || !window) {\n    return;\n  }\n\n  let _previousClientY = 0;\n  let _element: Element | null = null;\n  let computedStyles: CSSStyleDeclaration | undefined = window.getComputedStyle(element);\n\n  // remember the clientY for future calls of _preventOverscrolling\n  const _saveClientY = (event: TouchEvent): void => {\n    if (event.targetTouches.length === 1) {\n      _previousClientY = event.targetTouches[0].clientY;\n    }\n  };\n\n  // prevent the body from scrolling when the user attempts\n  // to scroll past the top or bottom of the element\n  const _preventOverscrolling = (event: TouchEvent): void => {\n    // only respond to a single-finger touch\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    // prevent the body touchmove handler from firing\n    // so that scrolling is allowed within the element\n    event.stopPropagation();\n\n    if (!_element) {\n      return;\n    }\n\n    const clientY = event.targetTouches[0].clientY - _previousClientY;\n\n    const scrollableParent = findScrollableParent(event.target as HTMLElement) as HTMLElement;\n    if (scrollableParent && _element !== scrollableParent) {\n      _element = scrollableParent;\n      computedStyles = window.getComputedStyle(_element);\n    }\n\n    const scrollTop = _element.scrollTop;\n    const isColumnReverse = computedStyles?.flexDirection === 'column-reverse';\n\n    // if the element is scrolled to the top,\n    // prevent the user from scrolling up\n    if (scrollTop === 0 && (isColumnReverse ? clientY < 0 : clientY > 0)) {\n      event.preventDefault();\n    }\n\n    // if the element is scrolled to the bottom,\n    // prevent the user from scrolling down\n    if (\n      _element.scrollHeight - Math.abs(Math.ceil(scrollTop)) <= _element.clientHeight &&\n      (isColumnReverse ? clientY > 0 : clientY < 0)\n    ) {\n      event.preventDefault();\n    }\n  };\n\n  events.on(element, 'touchstart', _saveClientY, { passive: false });\n  events.on(element, 'touchmove', _preventOverscrolling, { passive: false });\n\n  _element = element;\n};\n\n/**\n * Same as allowScrollOnElement but does not prevent overscrolling.\n */\nexport const allowOverscrollOnElement = (element: HTMLElement | null, events: EventGroup): void => {\n  if (!element) {\n    return;\n  }\n  const _allowElementScroll = (event: TouchEvent) => {\n    event.stopPropagation();\n  };\n  events.on(element, 'touchmove', _allowElementScroll, { passive: false });\n};\n\nconst _disableIosBodyScroll = (event: TouchEvent) => {\n  event.preventDefault();\n};\n\n/**\n * Disables the body scrolling.\n *\n * @public\n */\nexport function disableBodyScroll(): void {\n  let doc = getDocument();\n\n  if (doc && doc.body && !_bodyScrollDisabledCount) {\n    doc.body.classList.add(DisabledScrollClassName);\n    doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false });\n  }\n\n  _bodyScrollDisabledCount++;\n}\n\n/**\n * Enables the body scrolling.\n *\n * @public\n */\nexport function enableBodyScroll(): void {\n  if (_bodyScrollDisabledCount > 0) {\n    let doc = getDocument();\n\n    if (doc && doc.body && _bodyScrollDisabledCount === 1) {\n      doc.body.classList.remove(DisabledScrollClassName);\n      doc.body.removeEventListener('touchmove', _disableIosBodyScroll);\n    }\n\n    _bodyScrollDisabledCount--;\n  }\n}\n\n/**\n * Calculates the width of a scrollbar for the browser/os.\n *\n * @public\n */\nexport function getScrollbarWidth(doc?: Document): number {\n  if (_scrollbarWidth === undefined) {\n    const theDoc = doc ?? getDocument()!;\n    let scrollDiv: HTMLElement = theDoc.createElement('div');\n    scrollDiv.style.setProperty('width', '100px');\n    scrollDiv.style.setProperty('height', '100px');\n    scrollDiv.style.setProperty('overflow', 'scroll');\n    scrollDiv.style.setProperty('position', 'absolute');\n    scrollDiv.style.setProperty('top', '-9999px');\n    theDoc.body.appendChild(scrollDiv);\n    // Get the scrollbar width\n    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n    // Delete the DIV\n    theDoc.body.removeChild(scrollDiv);\n  }\n\n  return _scrollbarWidth;\n}\n\n/**\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\n * document.body.\n *\n * @public\n */\nexport function findScrollableParent(startingElement: HTMLElement | null): HTMLElement | Window | undefined | null {\n  let el: HTMLElement | Window | undefined | null = startingElement;\n  const doc = getDocument(startingElement)!;\n\n  // First do a quick scan for the scrollable attribute.\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\n      return el;\n    }\n    el = el.parentElement;\n  }\n\n  // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\n  el = startingElement;\n\n  while (el && el !== doc.body) {\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\n      const computedStyles = getComputedStyle(el);\n      let overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';\n\n      if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\n        return el;\n      }\n    }\n\n    el = el.parentElement;\n  }\n\n  // Fall back to window scroll.\n  if (!el || el === doc.body) {\n    el = getWindow(startingElement);\n  }\n\n  return el;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}