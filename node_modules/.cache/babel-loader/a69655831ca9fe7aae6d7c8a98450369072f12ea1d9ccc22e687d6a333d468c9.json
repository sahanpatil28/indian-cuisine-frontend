{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, css, elementContains, format, getId, classNamesFunction, styled, initializeComponentRef } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nimport { Label } from '../../Label';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getDocumentEx } from '../../utilities/dom';\nvar legacyStyles = stylesImport;\nvar EXTENDED_LOAD_TIME = 3000;\nvar getClassNames = classNamesFunction();\n/**\n * Should be removed once new picker without inheritance is created\n */\nfunction getStyledSuggestions(suggestionsType) {\n  return styled(suggestionsType, suggestionsStyles, undefined, {\n    scope: 'Suggestions'\n  });\n}\n/**\n * {@docCategory Pickers}\n */\nvar BasePicker = /** @class */function (_super) {\n  __extends(BasePicker, _super);\n  function BasePicker(basePickerProps) {\n    var _this = _super.call(this, basePickerProps) || this;\n    // Refs\n    _this.root = React.createRef();\n    _this.input = React.createRef();\n    _this.suggestionElement = React.createRef();\n    /**\n     * @deprecated this is no longer necessary as typescript now supports generic elements\n     */\n    _this.SuggestionOfProperType = Suggestions;\n    // eslint-disable-next-line deprecation/deprecation\n    _this._styledSuggestions = getStyledSuggestions(_this.SuggestionOfProperType);\n    _this._isMounted = false;\n    _this._overrideScrollDismiss = false;\n    _this.dismissSuggestions = function (ev) {\n      var selectItemFunction = function () {\n        var addItemOnDismiss = true;\n        if (_this.props.onDismiss) {\n          addItemOnDismiss = _this.props.onDismiss(ev, _this.suggestionStore.currentSuggestion ? _this.suggestionStore.currentSuggestion.item : undefined);\n        }\n        if (!ev || ev && !ev.defaultPrevented) {\n          // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n          if (addItemOnDismiss !== false && _this.canAddItems() && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestedDisplayValue) {\n            _this.addItemByIndex(0);\n          }\n        }\n      };\n      if (_this.currentPromise) {\n        _this.currentPromise.then(function () {\n          return selectItemFunction();\n        });\n      } else {\n        selectItemFunction();\n      }\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n    _this.refocusSuggestions = function (keyCode) {\n      _this.resetFocus();\n      if (_this.suggestionStore.suggestions && _this.suggestionStore.suggestions.length > 0) {\n        if (keyCode === KeyCodes.up) {\n          _this.suggestionStore.setSelectedSuggestion(_this.suggestionStore.suggestions.length - 1);\n        } else if (keyCode === KeyCodes.down) {\n          _this.suggestionStore.setSelectedSuggestion(0);\n        }\n      }\n    };\n    _this._getDescribedBy = function (items, hasError) {\n      var describedBy = '';\n      if (items.length > 0) {\n        describedBy += _this._ariaMap.selectedItems + ' ';\n      }\n      if (hasError) {\n        describedBy += _this._ariaMap.error;\n      }\n      return describedBy;\n    };\n    _this.onInputChange = function (value) {\n      _this.updateValue(value);\n      _this.setState({\n        moreSuggestionsAvailable: true,\n        isMostRecentlyUsedVisible: false\n      });\n    };\n    _this.onSuggestionClick = function (ev, item, index) {\n      _this.addItemByIndex(index);\n    };\n    _this.onSuggestionRemove = function (ev, item, index) {\n      if (_this.props.onRemoveSuggestion) {\n        _this.props.onRemoveSuggestion(item);\n      }\n      _this.suggestionStore.removeSuggestion(index);\n    };\n    _this.onInputFocus = function (ev) {\n      _this.selection.setAllSelected(false);\n      // Only trigger all of the focus if this component isn't already focused.\n      // For example when an item is selected or removed from the selected list it should be treated\n      // as though the input is still focused.\n      if (!_this.state.isFocused) {\n        _this._userTriggeredSuggestions();\n        if (_this.props.inputProps && _this.props.inputProps.onFocus) {\n          _this.props.inputProps.onFocus(ev);\n        }\n      }\n    };\n    _this.onInputBlur = function (ev) {\n      if (_this.props.inputProps && _this.props.inputProps.onBlur) {\n        _this.props.inputProps.onBlur(ev);\n      }\n    };\n    _this.onBlur = function (ev) {\n      if (_this.state.isFocused) {\n        // Only blur the entire component if an unrelated element gets focus.\n        // Otherwise treat it as though it still has focus.\n        // Do nothing if the blur is coming from something\n        // inside the comboBox root or the comboBox menu since\n        // it we are not really bluring from the whole comboBox\n        var relatedTarget = ev.relatedTarget;\n        if (ev.relatedTarget === null) {\n          // In IE11, due to lack of support, event.relatedTarget is always\n          // null making every onBlur call to be \"outside\" of the ComboBox\n          // even when it's not. Using document.activeElement is another way\n          // for us to be able to get what the relatedTarget without relying\n          // on the event\n          relatedTarget = getDocumentEx(_this.context).activeElement;\n        }\n        if (relatedTarget && !elementContains(_this.root.current, relatedTarget)) {\n          _this.setState({\n            isFocused: false\n          });\n          if (_this.props.onBlur) {\n            _this.props.onBlur(ev);\n          }\n        }\n      }\n    };\n    /**\n     * Resets focus to last element in wrapper div if clicking back into Picker that has hit item limit\n     */\n    _this.onWrapperClick = function (ev) {\n      if (_this.state.items.length && !_this.canAddItems()) {\n        _this.resetFocus(_this.state.items.length - 1);\n      }\n    };\n    /**\n     * Reveals suggestions any time the user clicks on the input element\n     * without shifting focus.\n     */\n    _this.onClick = function (ev) {\n      if (_this.props.inputProps !== undefined && _this.props.inputProps.onClick !== undefined) {\n        _this.props.inputProps.onClick(ev);\n      }\n      // Only primary (left) clicks show suggestions.\n      if (ev.button === 0) {\n        _this._userTriggeredSuggestions();\n      }\n    };\n    _this.onFocus = function () {\n      if (!_this.state.isFocused) {\n        _this.setState({\n          isFocused: true\n        });\n      }\n    };\n    _this.onKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var keyCode = ev.which;\n      switch (keyCode) {\n        case KeyCodes.escape:\n          if (_this.state.suggestionsVisible) {\n            _this.setState({\n              suggestionsVisible: false\n            });\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n          break;\n        case KeyCodes.tab:\n        case KeyCodes.enter:\n          if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedActionSelected()) {\n            _this.suggestionElement.current.executeSelectedAction();\n          } else if (!ev.shiftKey && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestionsVisible) {\n            _this.completeSuggestion();\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            _this._completeGenericSuggestion();\n          }\n          break;\n        case KeyCodes.backspace:\n          if (!_this.props.disabled) {\n            _this.onBackspace(ev);\n          }\n          ev.stopPropagation();\n          break;\n        case KeyCodes.del:\n          if (!_this.props.disabled) {\n            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible && _this.suggestionStore.currentIndex !== -1) {\n              if (_this.props.onRemoveSuggestion) {\n                _this.props.onRemoveSuggestion(_this.suggestionStore.currentSuggestion.item);\n              }\n              _this.suggestionStore.removeSuggestion(_this.suggestionStore.currentIndex);\n              _this.forceUpdate();\n            } else {\n              _this.onBackspace(ev);\n            }\n          }\n          ev.stopPropagation();\n          break;\n        case KeyCodes.up:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex === 0) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this.suggestionElement.current.focusAboveSuggestions();\n                _this.suggestionStore.deselectAllSuggestions();\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.previousSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n          break;\n        case KeyCodes.down:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex + 1 === _this.suggestionStore.suggestions.length) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this.suggestionElement.current.focusBelowSuggestions();\n                _this.suggestionStore.deselectAllSuggestions();\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.nextSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n          break;\n      }\n    };\n    _this.onItemChange = function (changedItem, index) {\n      var items = _this.state.items;\n      if (index >= 0) {\n        var newItems = items;\n        newItems[index] = changedItem;\n        _this._updateSelectedItems(newItems);\n      }\n    };\n    _this.onGetMoreResults = function () {\n      _this.setState({\n        isSearching: true\n      }, function () {\n        if (_this.props.onGetMoreResults && _this.input.current) {\n          var suggestions = _this.props.onGetMoreResults(_this.input.current.value, _this.state.items);\n          var suggestionsArray = suggestions;\n          var suggestionsPromiseLike = suggestions;\n          if (Array.isArray(suggestionsArray)) {\n            _this.updateSuggestions(suggestionsArray);\n            _this.setState({\n              isSearching: false\n            });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then(function (newSuggestions) {\n              _this.updateSuggestions(newSuggestions);\n              _this.setState({\n                isSearching: false\n              });\n            });\n          }\n        } else {\n          _this.setState({\n            isSearching: false\n          });\n        }\n        if (_this.input.current) {\n          _this.input.current.focus();\n        }\n        _this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true\n        });\n      });\n    };\n    _this.completeSelection = function (item) {\n      _this.addItem(item);\n      _this.updateValue('');\n      if (_this.input.current) {\n        _this.input.current.clear();\n      }\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n    _this.addItemByIndex = function (index) {\n      _this.completeSelection(_this.suggestionStore.getSuggestionAtIndex(index).item);\n    };\n    _this.addItem = function (item) {\n      var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;\n      if (processedItem === null) {\n        return;\n      }\n      var processedItemObject = processedItem;\n      var processedItemPromiseLike = processedItem;\n      if (processedItemPromiseLike && processedItemPromiseLike.then) {\n        processedItemPromiseLike.then(function (resolvedProcessedItem) {\n          var newItems = _this.state.items.concat([resolvedProcessedItem]);\n          _this._updateSelectedItems(newItems);\n        });\n      } else {\n        var newItems = _this.state.items.concat([processedItemObject]);\n        _this._updateSelectedItems(newItems);\n      }\n      _this.setState({\n        suggestedDisplayValue: '',\n        selectionRemoved: undefined\n      });\n    };\n    _this.removeItem = function (item) {\n      var items = _this.state.items;\n      var index = items.indexOf(item);\n      if (index >= 0) {\n        var newItems = items.slice(0, index).concat(items.slice(index + 1));\n        _this.setState({\n          selectionRemoved: item\n        });\n        _this._updateSelectedItems(newItems);\n        // reset selection removed text after a timeout so it isn't reached by screen reader virtual cursor.\n        // the exact timing isn't important, the live region will fully read even if the text is removed.\n        _this._async.setTimeout(function () {\n          _this.setState({\n            selectionRemoved: undefined\n          });\n        }, 1000);\n      }\n    };\n    _this.removeItems = function (itemsToRemove) {\n      var items = _this.state.items;\n      var newItems = items.filter(function (item) {\n        return itemsToRemove.indexOf(item) === -1;\n      });\n      _this._updateSelectedItems(newItems);\n    };\n    /**\n     * @deprecated this is no longer necessary as focuszone has been removed\n     */\n    _this._shouldFocusZoneEnterInnerZone = function (ev) {\n      // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n      if (_this.state.suggestionsVisible) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.up:\n          case KeyCodes.down:\n            return true;\n        }\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.which === KeyCodes.enter) {\n        return true;\n      }\n      return false;\n    };\n    _this._onResolveSuggestions = function (updatedValue) {\n      var suggestions = _this.props.onResolveSuggestions(updatedValue, _this.state.items);\n      if (suggestions !== null) {\n        _this.updateSuggestionsList(suggestions, updatedValue);\n      }\n    };\n    _this._completeGenericSuggestion = function () {\n      if (_this.props.onValidateInput && _this.input.current && _this.props.onValidateInput(_this.input.current.value) !== ValidationState.invalid && _this.props.createGenericItem) {\n        var itemToConvert = _this.props.createGenericItem(_this.input.current.value, _this.props.onValidateInput(_this.input.current.value));\n        _this.suggestionStore.createGenericSuggestion(itemToConvert);\n        _this.completeSuggestion();\n      }\n    };\n    /**\n     * This should be called when the user does something other than use text entry to trigger suggestions.\n     *\n     */\n    _this._userTriggeredSuggestions = function () {\n      if (!_this.state.suggestionsVisible) {\n        var input = _this.input.current ? _this.input.current.value : '';\n        if (!input) {\n          _this.onEmptyInputFocus();\n        } else {\n          if (_this.suggestionStore.suggestions.length === 0) {\n            _this._onResolveSuggestionsDebounced(input);\n          } else {\n            _this.setState({\n              isMostRecentlyUsedVisible: false,\n              suggestionsVisible: true\n            });\n          }\n        }\n      }\n    };\n    initializeComponentRef(_this);\n    var items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n    _this._id = getId();\n    _this._ariaMap = {\n      selectedItems: \"selected-items-\".concat(_this._id),\n      selectedSuggestionAlert: \"selected-suggestion-alert-\".concat(_this._id),\n      suggestionList: \"suggestion-list-\".concat(_this._id),\n      combobox: \"combobox-\".concat(_this._id),\n      error: \"error-\".concat(_this._id)\n    };\n    _this.suggestionStore = new SuggestionsController();\n    _this.selection = new Selection({\n      onSelectionChanged: function () {\n        return _this.onSelectionChange();\n      }\n    });\n    _this.selection.setItems(items);\n    _this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: [],\n      selectionRemoved: undefined\n    };\n    return _this;\n  }\n  BasePicker.getDerivedStateFromProps = function (newProps) {\n    if (newProps.selectedItems) {\n      return {\n        items: newProps.selectedItems\n      };\n    }\n    return null;\n  };\n  Object.defineProperty(BasePicker.prototype, \"items\", {\n    get: function () {\n      return this.state.items;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BasePicker.prototype.componentDidMount = function () {\n    this._isMounted = true;\n    this._async = new Async(this);\n    this._updateErrorMessage(this.state.items);\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestionsDebounced = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  };\n  BasePicker.prototype.componentDidUpdate = function (oldProps, oldState) {\n    var _this = this;\n    if (this.state.items && this.state.items !== oldState.items) {\n      var currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, false, true);\n          this.resetFocus(currentSelectedIndex);\n        }\n        // Reset focus to last item if the input is removed\n        else if (this.state.items.length > oldState.items.length && !this.canAddItems()) {\n          this.resetFocus(this.state.items.length - 1);\n        }\n      }\n    }\n    this._updateErrorMessage(this.state.items);\n    // handle dismiss buffer after suggestions are opened\n    if (this.state.suggestionsVisible && !oldState.suggestionsVisible) {\n      this._overrideScrollDismiss = true;\n      this._async.clearTimeout(this._overrideScrollDimissTimeout);\n      this._overrideScrollDimissTimeout = this._async.setTimeout(function () {\n        _this._overrideScrollDismiss = false;\n      }, 100);\n    }\n  };\n  BasePicker.prototype.componentWillUnmount = function () {\n    this._isMounted = false;\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n    this._async.dispose();\n  };\n  BasePicker.prototype.focus = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n  BasePicker.prototype.focusInput = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n  BasePicker.prototype.completeSuggestion = function (forceComplete) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  };\n  BasePicker.prototype.render = function () {\n    var _a, _b, _c;\n    var _d = this.state,\n      suggestedDisplayValue = _d.suggestedDisplayValue,\n      isFocused = _d.isFocused,\n      items = _d.items;\n    var _e = this.props,\n      className = _e.className,\n      inputProps = _e.inputProps,\n      disabled = _e.disabled,\n      selectionAriaLabel = _e.selectionAriaLabel,\n      _f = _e.selectionRole,\n      selectionRole = _f === void 0 ? 'list' : _f,\n      theme = _e.theme,\n      styles = _e.styles;\n    var suggestionsVisible = !!this.state.suggestionsVisible;\n    var suggestionsAvailable = suggestionsVisible ? this._ariaMap.suggestionList : undefined;\n    var hasError = !!((_a = this.state.errorMessage) !== null && _a !== void 0 ? _a : this.props.errorMessage);\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      disabled: disabled,\n      hasErrorMessage: hasError,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      error: 'ms-BasePicker-error',\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    var comboLabel = this.props['aria-label'] || (inputProps === null || inputProps === void 0 ? void 0 : inputProps['aria-label']);\n    var inputId = (_b = inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) !== null && _b !== void 0 ? _b : this._ariaMap.combobox;\n    // selectionAriaLabel is contained in a separate <span> rather than an aria-label on the items list\n    // because if the items list has an aria-label, the aria-describedby on the input will only read\n    // that label instead of all the selected items. Using aria-labelledby instead fixes this, since\n    // aria-describedby and aria-labelledby will not follow a second aria-labelledby\n    return React.createElement(\"div\", {\n      ref: this.root,\n      className: classNames.root,\n      onKeyDown: this.onKeyDown,\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onClick: this.onWrapperClick\n    }, this.renderLabel(inputId, (_c = classNames.subComponentStyles) === null || _c === void 0 ? void 0 : _c.label), this.renderCustomAlert(classNames.screenReaderText), React.createElement(\"span\", {\n      id: \"\".concat(this._ariaMap.selectedItems, \"-label\"),\n      hidden: true\n    }, selectionAriaLabel || comboLabel), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.multiple\n    }, React.createElement(\"div\", {\n      className: classNames.text,\n      \"aria-owns\": suggestionsAvailable\n    }, items.length > 0 && React.createElement(\"span\", {\n      id: this._ariaMap.selectedItems,\n      className: classNames.itemsWrapper,\n      role: selectionRole,\n      \"aria-labelledby\": \"\".concat(this._ariaMap.selectedItems, \"-label\")\n    }, this.renderItems()), this.canAddItems() && React.createElement(Autofill, __assign({\n      spellCheck: false\n    }, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      id: inputId,\n      onClick: this.onClick,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": suggestionsVisible ? this.getActiveDescendant() : undefined,\n      \"aria-controls\": suggestionsAvailable,\n      \"aria-describedby\": this._getDescribedBy(items, hasError),\n      \"aria-expanded\": suggestionsVisible,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-label\": comboLabel,\n      role: \"combobox\",\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    })))), this.renderError(classNames.error), this.renderSuggestions());\n  };\n  BasePicker.prototype.canAddItems = function () {\n    var items = this.state.items;\n    var itemLimit = this.props.itemLimit;\n    return itemLimit === undefined || items.length < itemLimit;\n  };\n  BasePicker.prototype.renderLabel = function (inputId, styles) {\n    var _a = this.props,\n      label = _a.label,\n      disabled = _a.disabled,\n      required = _a.required;\n    if (!label) {\n      return null;\n    }\n    return React.createElement(Label, {\n      className: \"ms-BasePicker-label\",\n      styles: styles,\n      disabled: disabled,\n      required: required,\n      htmlFor: inputId\n    }, label);\n  };\n  BasePicker.prototype.renderError = function (className) {\n    var _a = this.props.errorMessage,\n      errorMessage = _a === void 0 ? this.state.errorMessage : _a;\n    if (!errorMessage) {\n      return null;\n    }\n    return React.createElement(\"div\", {\n      role: \"alert\",\n      id: this._ariaMap.error,\n      className: className\n    }, errorMessage);\n  };\n  BasePicker.prototype.renderSuggestions = function () {\n    var _this = this;\n    var StyledTypedSuggestions = this._styledSuggestions;\n    return this.state.suggestionsVisible && this.input ? React.createElement(Callout, __assign({\n      isBeakVisible: false,\n      gapSpace: 5,\n      target: this.input.current ? this.input.current.inputElement : undefined,\n      onDismiss: this.dismissSuggestions,\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      directionalHintForRTL: DirectionalHint.bottomRightEdge,\n      // eslint-disable-next-line react/jsx-no-bind\n      preventDismissOnEvent: function (ev) {\n        return _this._preventDismissOnScrollOrResize(ev);\n      }\n    }, this.props.pickerCalloutProps), React.createElement(StyledTypedSuggestions\n    // Assumed to set in derived component's defaultProps\n    , __assign({\n      // Assumed to set in derived component's defaultProps\n      onRenderSuggestion: this.props.onRenderSuggestionsItem,\n      onSuggestionClick: this.onSuggestionClick,\n      onSuggestionRemove: this.onSuggestionRemove,\n      suggestions: this.suggestionStore.getSuggestions(),\n      componentRef: this.suggestionElement,\n      onGetMoreResults: this.onGetMoreResults,\n      moreSuggestionsAvailable: this.state.moreSuggestionsAvailable,\n      isLoading: this.state.suggestionsLoading,\n      isExtendedLoading: this.state.suggestionsExtendedLoading,\n      isSearching: this.state.isSearching,\n      isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible,\n      isResultsFooterVisible: this.state.isResultsFooterVisible,\n      refocusSuggestions: this.refocusSuggestions,\n      removeSuggestionAriaLabel: this.props.removeButtonAriaLabel,\n      suggestionsListId: this._ariaMap.suggestionList,\n      createGenericItem: this._completeGenericSuggestion\n    }, this.props.pickerSuggestionsProps))) : null;\n  };\n  BasePicker.prototype.renderItems = function () {\n    var _this = this;\n    var _a = this.props,\n      disabled = _a.disabled,\n      removeButtonAriaLabel = _a.removeButtonAriaLabel,\n      removeButtonIconProps = _a.removeButtonIconProps;\n    var onRenderItem = this.props.onRenderItem;\n    var _b = this.state,\n      items = _b.items,\n      selectedIndices = _b.selectedIndices;\n    return items.map(function (item, index) {\n      return onRenderItem({\n        item: item,\n        index: index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices.indexOf(index) !== -1,\n        onRemoveItem: function () {\n          return _this.removeItem(item);\n        },\n        disabled: disabled,\n        onItemChange: _this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel,\n        removeButtonIconProps: removeButtonIconProps\n      });\n    });\n  };\n  BasePicker.prototype.resetFocus = function (index) {\n    var items = this.state.items;\n    if (items.length) {\n      // default to focusing the last item\n      index = index !== null && index !== void 0 ? index : items.length - 1;\n      var newEl = this.root.current && this.root.current.querySelectorAll('[data-selection-index] > button')[Math.min(index, items.length - 1)];\n      if (newEl) {\n        newEl.focus();\n      }\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  };\n  BasePicker.prototype.onSuggestionSelect = function () {\n    if (this.suggestionStore.currentSuggestion) {\n      var currentValue = this.input.current ? this.input.current.value : '';\n      var itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n      this.setState({\n        suggestedDisplayValue: itemValue\n      });\n    }\n  };\n  BasePicker.prototype.onSelectionChange = function () {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices()\n    });\n  };\n  BasePicker.prototype.updateSuggestions = function (suggestions) {\n    var _a;\n    var maxSuggestionsCount = (_a = this.props.pickerSuggestionsProps) === null || _a === void 0 ? void 0 : _a.resultsMaximumNumber;\n    this.suggestionStore.updateSuggestions(suggestions, 0, maxSuggestionsCount);\n    this.forceUpdate();\n  };\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n  BasePicker.prototype.onEmptyInputFocus = function () {\n    var emptyResolveSuggestions = this.props.onEmptyResolveSuggestions ? this.props.onEmptyResolveSuggestions :\n    // eslint-disable-next-line deprecation/deprecation\n    this.props.onEmptyInputFocus;\n    // Only attempt to resolve suggestions if it exists\n    if (emptyResolveSuggestions) {\n      var suggestions = emptyResolveSuggestions(this.state.items);\n      this.updateSuggestionsList(suggestions);\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false\n      });\n    }\n  };\n  BasePicker.prototype.updateValue = function (updatedValue) {\n    this._onResolveSuggestionsDebounced(updatedValue);\n  };\n  BasePicker.prototype.updateSuggestionsList = function (suggestions, updatedValue) {\n    var _this = this;\n    var _a;\n    // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n    if (Array.isArray(suggestions)) {\n      this._updateAndResolveValue(updatedValue, suggestions);\n    } else if (suggestions && suggestions.then) {\n      this.setState({\n        suggestionsLoading: true\n      });\n      this._startLoadTimer();\n      // Clear suggestions\n      this.suggestionStore.updateSuggestions([]);\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions()\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current && this.input.current.inputElement === ((_a = getDocumentEx(this.context)) === null || _a === void 0 ? void 0 : _a.activeElement)\n        });\n      }\n      // Ensure that the promise will only use the callback if it was the most recent one.\n      this.currentPromise = suggestions;\n      suggestions.then(function (newSuggestions) {\n        if (suggestions === _this.currentPromise) {\n          _this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  };\n  BasePicker.prototype.resolveNewValue = function (updatedValue, suggestions) {\n    var _this = this;\n    this.updateSuggestions(suggestions);\n    var itemValue = undefined;\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    }\n    // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n    this.setState({\n      suggestedDisplayValue: itemValue,\n      suggestionsVisible: this._getShowSuggestions()\n    }, function () {\n      return _this.setState({\n        suggestionsLoading: false,\n        suggestionsExtendedLoading: false\n      });\n    });\n  };\n  BasePicker.prototype.onChange = function (items) {\n    if (this.props.onChange) {\n      this.props.onChange(items);\n    }\n  };\n  // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n  BasePicker.prototype.onBackspace = function (ev) {\n    if (this.state.items.length && !this.input.current || this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  };\n  BasePicker.prototype.getActiveDescendant = function () {\n    var _a;\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n    var currentIndex = this.suggestionStore.currentIndex;\n    if (currentIndex < 0) {\n      // if the suggestions element has actions and the currentIndex does not point to a suggestion,\n      // return the action id\n      if ((_a = this.suggestionElement.current) === null || _a === void 0 ? void 0 : _a.hasSuggestedAction()) {\n        return 'sug-selectedAction';\n      }\n      // If there are no suggestions and no action suggested, then return the ID for the no results found.\n      if (this.suggestionStore.suggestions.length === 0) {\n        return 'sug-noResultsFound';\n      }\n      return undefined;\n    } else {\n      return \"sug-\".concat(currentIndex);\n    }\n  };\n  /** @deprecated use renderCustomAlert instead */\n  BasePicker.prototype.getSuggestionsAlert = function (suggestionAlertClassName) {\n    if (suggestionAlertClassName === void 0) {\n      suggestionAlertClassName = legacyStyles.screenReaderOnly;\n    }\n    var currentIndex = this.suggestionStore.currentIndex;\n    if (this.props.enableSelectedSuggestionAlert) {\n      var selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      var selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      // keeping the id/className here for legacy support\n      return React.createElement(\"div\", {\n        id: this._ariaMap.selectedSuggestionAlert,\n        className: suggestionAlertClassName\n      }, \"\".concat(selectedSuggestionAlertText, \" \"));\n    }\n  };\n  BasePicker.prototype.renderCustomAlert = function (alertClassName) {\n    if (alertClassName === void 0) {\n      alertClassName = legacyStyles.screenReaderOnly;\n    }\n    var _a = this.props.suggestionRemovedText,\n      suggestionRemovedText = _a === void 0 ? 'removed {0}' : _a;\n    var removedItemText = '';\n    if (this.state.selectionRemoved) {\n      var itemName = this._getTextFromItem(this.state.selectionRemoved, '');\n      removedItemText = format(suggestionRemovedText, itemName);\n    }\n    return React.createElement(\"div\", {\n      className: alertClassName,\n      id: this._ariaMap.selectedSuggestionAlert,\n      \"aria-live\": \"assertive\"\n    },\n    // eslint-disable-next-line deprecation/deprecation\n    this.getSuggestionsAlert(alertClassName), removedItemText);\n  };\n  // do not dismiss if the window resizes or scrolls within 100ms of opening\n  // this prevents the Android issue where pickers immediately dismiss on open, because the keyboard appears\n  BasePicker.prototype._preventDismissOnScrollOrResize = function (ev) {\n    if (this._overrideScrollDismiss && (ev.type === 'scroll' || ev.type === 'resize')) {\n      return true;\n    }\n    return false;\n  };\n  /** If suggestions are still loading after a predefined amount of time, set state to show user alert */\n  BasePicker.prototype._startLoadTimer = function () {\n    var _this = this;\n    this._async.setTimeout(function () {\n      if (_this.state.suggestionsLoading) {\n        _this.setState({\n          suggestionsExtendedLoading: true\n        });\n      }\n    }, EXTENDED_LOAD_TIME);\n  };\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n  BasePicker.prototype._updateAndResolveValue = function (updatedValue, newSuggestions) {\n    var _a;\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      var maxSuggestionsCount = (_a = this.props.pickerSuggestionsProps) === null || _a === void 0 ? void 0 : _a.resultsMaximumNumber;\n      this.suggestionStore.updateSuggestions(newSuggestions, -1, maxSuggestionsCount);\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false,\n          suggestionsExtendedLoading: false\n        });\n      }\n    }\n  };\n  BasePicker.prototype._getErrorMessage = function (items) {\n    return __awaiter(this, void 0, void 0, function () {\n      var errorMessage, err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.props.errorMessage) {\n              return [2 /*return*/, this.props.errorMessage];\n            }\n            if (!this.props.onGetErrorMessage) return [3 /*break*/, 8];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 7,, 8]);\n            errorMessage = this.props.onGetErrorMessage(items);\n            if (!errorMessage) return [3 /*break*/, 5];\n            if (!errorMessage.then) return [3 /*break*/, 3];\n            return [4 /*yield*/, errorMessage];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            return [2 /*return*/, errorMessage];\n          case 4:\n            return [3 /*break*/, 6];\n          case 5:\n            return [2 /*return*/, undefined];\n          case 6:\n            return [3 /*break*/, 8];\n          case 7:\n            err_1 = _a.sent();\n            return [3 /*break*/, 8];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  BasePicker.prototype._updateErrorMessage = function (items) {\n    var _this = this;\n    var newErrorMessage;\n    this._getErrorMessage(items).then(function (errorMessage) {\n      newErrorMessage = errorMessage;\n    }).catch(function () {\n      /* NO-OP */\n    }).finally(function () {\n      if (_this._isMounted && newErrorMessage !== _this.state.errorMessage) {\n        _this.setState({\n          errorMessage: newErrorMessage\n        });\n      }\n    });\n  };\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n  BasePicker.prototype._updateSelectedItems = function (items) {\n    var _this = this;\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({\n        items: items\n      }, function () {\n        _this._updateErrorMessage(items);\n        _this._onSelectedItemsUpdated(items);\n      });\n    }\n  };\n  BasePicker.prototype._onSelectedItemsUpdated = function (items) {\n    this.onChange(items);\n  };\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n  BasePicker.prototype._getShowSuggestions = function () {\n    var _a;\n    var areSuggestionsVisible = this.input.current !== undefined && this.input.current !== null && this.input.current.inputElement === ((_a = getDocumentEx(this.context)) === null || _a === void 0 ? void 0 : _a.activeElement) && this.input.current.value !== '';\n    return areSuggestionsVisible;\n  };\n  BasePicker.prototype._getTextFromItem = function (item, currentValue) {\n    if (this.props.getTextFromItem) {\n      return this.props.getTextFromItem(item, currentValue);\n    } else {\n      return '';\n    }\n  };\n  BasePicker.contextType = WindowContext;\n  return BasePicker;\n}(React.Component);\nexport { BasePicker };\nvar BasePickerListBelow = /** @class */function (_super) {\n  __extends(BasePickerListBelow, _super);\n  function BasePickerListBelow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  BasePickerListBelow.prototype.render = function () {\n    var _a, _b, _c;\n    var _d = this.state,\n      suggestedDisplayValue = _d.suggestedDisplayValue,\n      isFocused = _d.isFocused,\n      items = _d.items;\n    var _e = this.props,\n      className = _e.className,\n      inputProps = _e.inputProps,\n      disabled = _e.disabled,\n      selectionAriaLabel = _e.selectionAriaLabel,\n      _f = _e.selectionRole,\n      selectionRole = _f === void 0 ? 'list' : _f,\n      theme = _e.theme,\n      styles = _e.styles;\n    var suggestionsVisible = !!this.state.suggestionsVisible;\n    var suggestionsAvailable = suggestionsVisible ? this._ariaMap.suggestionList : undefined;\n    var hasError = !!((_a = this.state.errorMessage) !== null && _a !== void 0 ? _a : this.props.errorMessage);\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      disabled: disabled,\n      hasErrorMessage: hasError,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', legacyStyles.picker, className ? className : ''),\n      error: 'ms-BasePicker-error',\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused, disabled && legacyStyles.inputDisabled),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    var comboLabel = this.props['aria-label'] || (inputProps === null || inputProps === void 0 ? void 0 : inputProps['aria-label']);\n    var inputId = (_b = inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) !== null && _b !== void 0 ? _b : this._ariaMap.combobox;\n    return React.createElement(\"div\", {\n      ref: this.root,\n      onBlur: this.onBlur,\n      onFocus: this.onFocus\n    }, this.renderLabel(inputId, (_c = classNames.subComponentStyles) === null || _c === void 0 ? void 0 : _c.label), React.createElement(\"div\", {\n      className: classNames.root,\n      onKeyDown: this.onKeyDown\n    }, this.renderCustomAlert(classNames.screenReaderText), React.createElement(\"span\", {\n      id: \"\".concat(this._ariaMap.selectedItems, \"-label\"),\n      hidden: true\n    }, selectionAriaLabel || comboLabel), React.createElement(\"div\", {\n      className: classNames.text,\n      \"aria-owns\": suggestionsAvailable\n    }, React.createElement(Autofill, __assign({}, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onClick: this.onClick,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": suggestionsVisible ? this.getActiveDescendant() : undefined,\n      \"aria-controls\": suggestionsAvailable,\n      \"aria-expanded\": suggestionsVisible,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-label\": comboLabel,\n      \"aria-describedby\": this._getDescribedBy(items, hasError),\n      role: \"combobox\",\n      id: inputId,\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    })))), this.renderSuggestions(), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.single\n    }, React.createElement(\"div\", {\n      id: this._ariaMap.selectedItems,\n      className: \"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n      ,\n      role: selectionRole,\n      \"aria-labelledby\": \"\".concat(this._ariaMap.selectedItems, \"-label\")\n    }, this.renderItems())), this.renderError(classNames.error));\n  };\n  BasePickerListBelow.prototype.onBackspace = function (ev) {\n    // override the existing backspace method to not do anything because the list items appear below.\n  };\n  return BasePickerListBelow;\n}(BasePicker);\nexport { BasePickerListBelow };","map":{"version":3,"names":["React","Async","KeyCodes","css","elementContains","format","getId","classNamesFunction","styled","initializeComponentRef","Callout","Selection","SelectionZone","SelectionMode","DirectionalHint","Suggestions","getStyles","suggestionsStyles","SuggestionsController","ValidationState","Autofill","stylesImport","Label","WindowContext","getDocumentEx","legacyStyles","EXTENDED_LOAD_TIME","getClassNames","getStyledSuggestions","suggestionsType","undefined","scope","BasePicker","_super","__extends","basePickerProps","_this","call","root","createRef","input","suggestionElement","SuggestionOfProperType","_styledSuggestions","_isMounted","_overrideScrollDismiss","dismissSuggestions","ev","selectItemFunction","addItemOnDismiss","props","onDismiss","suggestionStore","currentSuggestion","item","defaultPrevented","canAddItems","hasSelectedSuggestion","state","suggestedDisplayValue","addItemByIndex","currentPromise","then","setState","suggestionsVisible","refocusSuggestions","keyCode","resetFocus","suggestions","length","up","setSelectedSuggestion","down","_getDescribedBy","items","hasError","describedBy","_ariaMap","selectedItems","error","onInputChange","value","updateValue","moreSuggestionsAvailable","isMostRecentlyUsedVisible","onSuggestionClick","index","onSuggestionRemove","onRemoveSuggestion","removeSuggestion","onInputFocus","selection","setAllSelected","isFocused","_userTriggeredSuggestions","inputProps","onFocus","onInputBlur","onBlur","relatedTarget","context","activeElement","current","onWrapperClick","onClick","button","onKeyDown","which","escape","preventDefault","stopPropagation","tab","enter","hasSuggestedActionSelected","executeSelectedAction","shiftKey","completeSuggestion","_completeGenericSuggestion","backspace","disabled","onBackspace","del","target","inputElement","currentIndex","forceUpdate","tryHandleKeyDown","hasSuggestedAction","focusAboveSuggestions","deselectAllSuggestions","previousSuggestion","onSuggestionSelect","focusBelowSuggestions","nextSuggestion","onItemChange","changedItem","newItems","_updateSelectedItems","onGetMoreResults","isSearching","suggestionsArray","suggestionsPromiseLike","Array","isArray","updateSuggestions","newSuggestions","focus","isResultsFooterVisible","completeSelection","addItem","clear","getSuggestionAtIndex","processedItem","onItemSelected","processedItemObject","processedItemPromiseLike","resolvedProcessedItem","concat","selectionRemoved","removeItem","indexOf","slice","_async","setTimeout","removeItems","itemsToRemove","filter","_shouldFocusZoneEnterInnerZone","_onResolveSuggestions","updatedValue","onResolveSuggestions","updateSuggestionsList","onValidateInput","invalid","createGenericItem","itemToConvert","createGenericSuggestion","onEmptyInputFocus","_onResolveSuggestionsDebounced","defaultSelectedItems","_id","selectedSuggestionAlert","suggestionList","combobox","onSelectionChanged","onSelectionChange","setItems","selectedIndices","getDerivedStateFromProps","newProps","Object","defineProperty","prototype","get","componentDidMount","_updateErrorMessage","debounce","resolveDelay","componentDidUpdate","oldProps","oldState","currentSelectedIndex","getSelectedIndices","setIndexSelected","clearTimeout","_overrideScrollDimissTimeout","componentWillUnmount","dispose","focusInput","forceComplete","render","_d","_e","className","selectionAriaLabel","_f","selectionRole","theme","styles","suggestionsAvailable","_a","errorMessage","classNames","hasErrorMessage","inputClassName","text","pickerText","inputFocused","itemsWrapper","pickerItems","pickerInput","screenReaderText","screenReaderOnly","comboLabel","inputId","_b","id","createElement","ref","renderLabel","_c","subComponentStyles","label","renderCustomAlert","hidden","selectionMode","multiple","role","renderItems","__assign","spellCheck","componentRef","onInputValueChange","getActiveDescendant","renderError","renderSuggestions","itemLimit","required","htmlFor","StyledTypedSuggestions","isBeakVisible","gapSpace","directionalHint","bottomLeftEdge","directionalHintForRTL","bottomRightEdge","preventDismissOnEvent","_preventDismissOnScrollOrResize","pickerCalloutProps","onRenderSuggestion","onRenderSuggestionsItem","getSuggestions","isLoading","suggestionsLoading","isExtendedLoading","suggestionsExtendedLoading","removeSuggestionAriaLabel","removeButtonAriaLabel","suggestionsListId","pickerSuggestionsProps","removeButtonIconProps","onRenderItem","map","key","selected","onRemoveItem","newEl","querySelectorAll","Math","min","currentValue","itemValue","_getTextFromItem","maxSuggestionsCount","resultsMaximumNumber","emptyResolveSuggestions","onEmptyResolveSuggestions","_updateAndResolveValue","_startLoadTimer","_getShowSuggestions","resolveNewValue","onChange","isValueSelected","cursorLocation","getSelectedCount","getSelection","getSuggestionsAlert","suggestionAlertClassName","enableSelectedSuggestionAlert","selectedSuggestion","selectedSuggestionAlertText","ariaLabel","alertClassName","suggestionRemovedText","removedItemText","itemName","type","_getErrorMessage","onGetErrorMessage","sent","newErrorMessage","catch","finally","_onSelectedItemsUpdated","areSuggestionsVisible","getTextFromItem","contextType","Component","BasePickerListBelow","picker","inputDisabled","single"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\pickers\\BasePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  KeyCodes,\n  css,\n  elementContains,\n  format,\n  getId,\n  classNamesFunction,\n  styled,\n  initializeComponentRef,\n  IStyleFunctionOrObject,\n} from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nimport { Label } from '../../Label';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type {\n  ISuggestions,\n  ISuggestionsProps,\n  ISuggestionsStyleProps,\n  ISuggestionsStyles,\n} from './Suggestions/Suggestions.types';\nimport type { IBasePicker, IBasePickerProps, IBasePickerStyleProps, IBasePickerStyles } from './BasePicker.types';\nimport type { IAutofill } from '../Autofill/index';\nimport type { IPickerItemProps } from './PickerItem.types';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getDocumentEx } from '../../utilities/dom';\nimport type { ILabelStyleProps, ILabelStyles } from '../../Label';\n\nconst legacyStyles: any = stylesImport;\n\nconst EXTENDED_LOAD_TIME = 3000;\n\nexport interface IBasePickerState<T> {\n  items?: any;\n  suggestedDisplayValue?: string;\n  moreSuggestionsAvailable?: boolean;\n  isFocused?: boolean;\n  isSearching?: boolean;\n  isMostRecentlyUsedVisible?: boolean;\n  suggestionsVisible?: boolean;\n  suggestionsLoading?: boolean;\n  suggestionsExtendedLoading?: boolean;\n  isResultsFooterVisible?: boolean;\n  selectedIndices?: number[];\n  selectionRemoved?: T;\n  errorMessage?: string | JSX.Element;\n}\n\n/**\n * Aria id's for internal picker components\n * {@docCategory Pickers}\n */\nexport type IPickerAriaIds = {\n  /**\n   * Aria id for selected suggestion alert component\n   */\n  selectedSuggestionAlert: string;\n  /**\n   * Aria id for selected items container component\n   */\n  selectedItems: string;\n  /**\n   * Aria id for suggestions list component\n   */\n  suggestionList: string;\n  /**\n   * Aria id for element with role=combobox\n   */\n  combobox: string;\n  /**\n   * Aria id for error message component\n   */\n  error: string;\n};\n\nconst getClassNames = classNamesFunction<IBasePickerStyleProps, IBasePickerStyles>();\n\n/**\n * Should be removed once new picker without inheritance is created\n */\nfunction getStyledSuggestions<T>(suggestionsType: new (props: ISuggestionsProps<T>) => Suggestions<T>) {\n  return styled<ISuggestionsProps<any>, ISuggestionsStyleProps, ISuggestionsStyles>(\n    suggestionsType,\n    suggestionsStyles,\n    undefined,\n    {\n      scope: 'Suggestions',\n    },\n  );\n}\n\n/**\n * {@docCategory Pickers}\n */\nexport class BasePicker<T extends {}, P extends IBasePickerProps<T>>\n  extends React.Component<P, IBasePickerState<T>>\n  implements IBasePicker<T>\n{\n  public static contextType = WindowContext;\n\n  // Refs\n  protected root = React.createRef<HTMLDivElement>();\n  protected input = React.createRef<IAutofill>();\n  protected suggestionElement = React.createRef<ISuggestions<T>>();\n  protected selection: Selection;\n  protected suggestionStore: SuggestionsController<T>;\n  /**\n   * @deprecated this is no longer necessary as typescript now supports generic elements\n   */\n  protected SuggestionOfProperType = Suggestions as new (props: ISuggestionsProps<T>) => Suggestions<T>;\n  protected currentPromise: PromiseLike<any> | undefined;\n  protected _ariaMap: IPickerAriaIds;\n  // eslint-disable-next-line deprecation/deprecation\n  private _styledSuggestions = getStyledSuggestions(this.SuggestionOfProperType);\n  private _id: string;\n  private _async: Async;\n  private _isMounted: boolean = false;\n  private _onResolveSuggestionsDebounced: (updatedValue: string) => void;\n  private _overrideScrollDismiss = false;\n  private _overrideScrollDimissTimeout: number;\n\n  public static getDerivedStateFromProps(newProps: IBasePickerProps<any>) {\n    if (newProps.selectedItems) {\n      return { items: newProps.selectedItems };\n    }\n    return null;\n  }\n\n  constructor(basePickerProps: P) {\n    super(basePickerProps);\n\n    initializeComponentRef(this);\n\n    const items: T[] = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n\n    this._id = getId();\n    this._ariaMap = {\n      selectedItems: `selected-items-${this._id}`,\n      selectedSuggestionAlert: `selected-suggestion-alert-${this._id}`,\n      suggestionList: `suggestion-list-${this._id}`,\n      combobox: `combobox-${this._id}`,\n      error: `error-${this._id}`,\n    };\n    this.suggestionStore = new SuggestionsController<T>();\n    this.selection = new Selection({ onSelectionChanged: () => this.onSelectionChange() });\n    this.selection.setItems(items);\n    this.state = {\n      items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: [],\n      selectionRemoved: undefined,\n    };\n  }\n\n  public get items(): T[] {\n    return this.state.items;\n  }\n\n  public componentDidMount(): void {\n    this._isMounted = true;\n    this._async = new Async(this);\n    this._updateErrorMessage(this.state.items);\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestionsDebounced = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  }\n\n  public componentDidUpdate(oldProps: P, oldState: IBasePickerState<T>) {\n    if (this.state.items && this.state.items !== oldState.items) {\n      const currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, false, true);\n          this.resetFocus(currentSelectedIndex);\n        }\n        // Reset focus to last item if the input is removed\n        else if (this.state.items.length > oldState.items.length && !this.canAddItems()) {\n          this.resetFocus(this.state.items.length - 1);\n        }\n      }\n    }\n\n    this._updateErrorMessage(this.state.items);\n\n    // handle dismiss buffer after suggestions are opened\n    if (this.state.suggestionsVisible && !oldState.suggestionsVisible) {\n      this._overrideScrollDismiss = true;\n      this._async.clearTimeout(this._overrideScrollDimissTimeout);\n      this._overrideScrollDimissTimeout = this._async.setTimeout(() => {\n        this._overrideScrollDismiss = false;\n      }, 100);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._isMounted = false;\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n    this._async.dispose();\n  }\n\n  public focus() {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  }\n\n  public focusInput() {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  }\n\n  public dismissSuggestions = (ev?: any): void => {\n    const selectItemFunction = () => {\n      let addItemOnDismiss: boolean | void = true;\n      if (this.props.onDismiss) {\n        addItemOnDismiss = this.props.onDismiss(\n          ev,\n          this.suggestionStore.currentSuggestion ? this.suggestionStore.currentSuggestion.item : undefined,\n        );\n      }\n\n      if (!ev || (ev && !ev.defaultPrevented)) {\n        // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n        if (\n          addItemOnDismiss !== false &&\n          this.canAddItems() &&\n          this.suggestionStore.hasSelectedSuggestion() &&\n          this.state.suggestedDisplayValue\n        ) {\n          this.addItemByIndex(0);\n        }\n      }\n    };\n\n    if (this.currentPromise) {\n      this.currentPromise.then(() => selectItemFunction());\n    } else {\n      selectItemFunction();\n    }\n\n    this.setState({ suggestionsVisible: false });\n  };\n\n  public completeSuggestion(forceComplete?: boolean) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion!.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  }\n\n  public refocusSuggestions = (keyCode: KeyCodes): void => {\n    this.resetFocus();\n    if (this.suggestionStore.suggestions && this.suggestionStore.suggestions.length > 0) {\n      if (keyCode === KeyCodes.up) {\n        this.suggestionStore.setSelectedSuggestion(this.suggestionStore.suggestions.length - 1);\n      } else if (keyCode === KeyCodes.down) {\n        this.suggestionStore.setSelectedSuggestion(0);\n      }\n    }\n  };\n\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused, items } = this.state;\n    const { className, inputProps, disabled, selectionAriaLabel, selectionRole = 'list', theme, styles } = this.props;\n\n    const suggestionsVisible = !!this.state.suggestionsVisible;\n    const suggestionsAvailable = suggestionsVisible ? this._ariaMap.suggestionList : undefined;\n    const hasError = !!(this.state.errorMessage ?? this.props.errorMessage);\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          disabled,\n          hasErrorMessage: hasError,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          error: 'ms-BasePicker-error',\n          text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n          itemsWrapper: legacyStyles.pickerItems,\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    const comboLabel = this.props['aria-label'] || inputProps?.['aria-label'];\n    const inputId = inputProps?.id ?? this._ariaMap.combobox;\n\n    // selectionAriaLabel is contained in a separate <span> rather than an aria-label on the items list\n    // because if the items list has an aria-label, the aria-describedby on the input will only read\n    // that label instead of all the selected items. Using aria-labelledby instead fixes this, since\n    // aria-describedby and aria-labelledby will not follow a second aria-labelledby\n    return (\n      <div\n        ref={this.root}\n        className={classNames.root}\n        onKeyDown={this.onKeyDown}\n        onFocus={this.onFocus}\n        onBlur={this.onBlur}\n        onClick={this.onWrapperClick}\n      >\n        {this.renderLabel(inputId, classNames.subComponentStyles?.label)}\n        {this.renderCustomAlert(classNames.screenReaderText)}\n        <span id={`${this._ariaMap.selectedItems}-label`} hidden>\n          {selectionAriaLabel || comboLabel}\n        </span>\n        <SelectionZone selection={this.selection} selectionMode={SelectionMode.multiple}>\n          <div className={classNames.text} aria-owns={suggestionsAvailable}>\n            {items.length > 0 && (\n              <span\n                id={this._ariaMap.selectedItems}\n                className={classNames.itemsWrapper}\n                role={selectionRole}\n                aria-labelledby={`${this._ariaMap.selectedItems}-label`}\n              >\n                {this.renderItems()}\n              </span>\n            )}\n            {this.canAddItems() && (\n              <Autofill\n                spellCheck={false}\n                {...(inputProps as any)}\n                className={classNames.input}\n                componentRef={this.input}\n                id={inputId}\n                onClick={this.onClick}\n                onFocus={this.onInputFocus}\n                onBlur={this.onInputBlur}\n                onInputValueChange={this.onInputChange}\n                suggestedDisplayValue={suggestedDisplayValue}\n                aria-activedescendant={suggestionsVisible ? this.getActiveDescendant() : undefined}\n                aria-controls={suggestionsAvailable}\n                aria-describedby={this._getDescribedBy(items, hasError)}\n                aria-expanded={suggestionsVisible}\n                aria-haspopup=\"listbox\"\n                aria-label={comboLabel}\n                role=\"combobox\"\n                disabled={disabled}\n                onInputChange={this.props.onInputChange}\n              />\n            )}\n          </div>\n        </SelectionZone>\n        {this.renderError(classNames.error)}\n        {this.renderSuggestions()}\n      </div>\n    );\n  }\n\n  protected _getDescribedBy = (items: T[], hasError: boolean): string => {\n    let describedBy = '';\n    if (items.length > 0) {\n      describedBy += this._ariaMap.selectedItems + ' ';\n    }\n    if (hasError) {\n      describedBy += this._ariaMap.error;\n    }\n    return describedBy;\n  };\n\n  protected canAddItems(): boolean {\n    const { items } = this.state;\n    const { itemLimit } = this.props;\n    return itemLimit === undefined || items.length < itemLimit;\n  }\n\n  protected renderLabel(\n    inputId: string,\n    styles: IStyleFunctionOrObject<ILabelStyleProps, ILabelStyles> | undefined,\n  ): JSX.Element | null {\n    const { label, disabled, required } = this.props;\n    if (!label) {\n      return null;\n    }\n    return (\n      <Label className=\"ms-BasePicker-label\" styles={styles} disabled={disabled} required={required} htmlFor={inputId}>\n        {label}\n      </Label>\n    );\n  }\n\n  protected renderError(className?: string): JSX.Element | null {\n    const { errorMessage = this.state.errorMessage } = this.props;\n    if (!errorMessage) {\n      return null;\n    }\n    return (\n      <div role=\"alert\" id={this._ariaMap.error} className={className}>\n        {errorMessage}\n      </div>\n    );\n  }\n\n  protected renderSuggestions(): JSX.Element | null {\n    const StyledTypedSuggestions: React.FunctionComponent<ISuggestionsProps<T>> = this._styledSuggestions;\n\n    return this.state.suggestionsVisible && this.input ? (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={5}\n        target={this.input.current ? this.input.current.inputElement : undefined}\n        onDismiss={this.dismissSuggestions}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintForRTL={DirectionalHint.bottomRightEdge}\n        // eslint-disable-next-line react/jsx-no-bind\n        preventDismissOnEvent={(ev: Event) => this._preventDismissOnScrollOrResize(ev)}\n        {...this.props.pickerCalloutProps}\n      >\n        <StyledTypedSuggestions\n          // Assumed to set in derived component's defaultProps\n          onRenderSuggestion={this.props.onRenderSuggestionsItem!}\n          onSuggestionClick={this.onSuggestionClick}\n          onSuggestionRemove={this.onSuggestionRemove}\n          suggestions={this.suggestionStore.getSuggestions()}\n          componentRef={this.suggestionElement}\n          onGetMoreResults={this.onGetMoreResults}\n          moreSuggestionsAvailable={this.state.moreSuggestionsAvailable}\n          isLoading={this.state.suggestionsLoading}\n          isExtendedLoading={this.state.suggestionsExtendedLoading}\n          isSearching={this.state.isSearching}\n          isMostRecentlyUsedVisible={this.state.isMostRecentlyUsedVisible}\n          isResultsFooterVisible={this.state.isResultsFooterVisible}\n          refocusSuggestions={this.refocusSuggestions}\n          removeSuggestionAriaLabel={this.props.removeButtonAriaLabel}\n          suggestionsListId={this._ariaMap.suggestionList}\n          createGenericItem={this._completeGenericSuggestion}\n          {...this.props.pickerSuggestionsProps}\n        />\n      </Callout>\n    ) : null;\n  }\n\n  protected renderItems(): JSX.Element[] {\n    const { disabled, removeButtonAriaLabel, removeButtonIconProps } = this.props;\n    const onRenderItem = this.props.onRenderItem as (props: IPickerItemProps<T>) => JSX.Element;\n\n    const { items, selectedIndices } = this.state;\n    return items.map((item: any, index: number) =>\n      onRenderItem({\n        item,\n        index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices!.indexOf(index) !== -1,\n        onRemoveItem: () => this.removeItem(item),\n        disabled,\n        onItemChange: this.onItemChange,\n        removeButtonAriaLabel,\n        removeButtonIconProps,\n      }),\n    );\n  }\n\n  protected resetFocus(index?: number) {\n    const { items } = this.state;\n\n    if (items.length) {\n      // default to focusing the last item\n      index = index ?? items.length - 1;\n      const newEl: HTMLElement | null =\n        this.root.current &&\n        (this.root.current.querySelectorAll('[data-selection-index] > button')[\n          Math.min(index!, items.length - 1)\n        ] as HTMLElement | null);\n      if (newEl) {\n        newEl.focus();\n      }\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  }\n\n  protected onSuggestionSelect() {\n    if (this.suggestionStore.currentSuggestion) {\n      const currentValue: string = this.input.current ? this.input.current.value : '';\n      const itemValue: string = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n      this.setState({ suggestedDisplayValue: itemValue });\n    }\n  }\n\n  protected onSelectionChange() {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices(),\n    });\n  }\n\n  protected updateSuggestions(suggestions: any[]) {\n    const maxSuggestionsCount = this.props.pickerSuggestionsProps?.resultsMaximumNumber;\n    this.suggestionStore.updateSuggestions(suggestions, 0, maxSuggestionsCount);\n    this.forceUpdate();\n  }\n\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n  protected onEmptyInputFocus() {\n    const emptyResolveSuggestions = this.props.onEmptyResolveSuggestions\n      ? this.props.onEmptyResolveSuggestions\n      : // eslint-disable-next-line deprecation/deprecation\n        this.props.onEmptyInputFocus;\n\n    // Only attempt to resolve suggestions if it exists\n    if (emptyResolveSuggestions) {\n      const suggestions = emptyResolveSuggestions(this.state.items);\n\n      this.updateSuggestionsList(suggestions);\n\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false,\n      });\n    }\n  }\n\n  protected updateValue(updatedValue: string) {\n    this._onResolveSuggestionsDebounced(updatedValue);\n  }\n\n  protected updateSuggestionsList(suggestions: T[] | PromiseLike<T[]>, updatedValue?: string) {\n    // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n    if (Array.isArray(suggestions)) {\n      this._updateAndResolveValue(updatedValue, suggestions);\n    } else if (suggestions && (suggestions as PromiseLike<T[]>).then) {\n      this.setState({\n        suggestionsLoading: true,\n      });\n      this._startLoadTimer();\n\n      // Clear suggestions\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions(),\n        });\n      } else {\n        this.setState({\n          suggestionsVisible:\n            this.input.current! && this.input.current!.inputElement === getDocumentEx(this.context)?.activeElement,\n        });\n      }\n\n      // Ensure that the promise will only use the callback if it was the most recent one.\n      this.currentPromise = suggestions;\n      suggestions.then((newSuggestions: T[]) => {\n        if (suggestions === this.currentPromise) {\n          this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  }\n\n  protected resolveNewValue(updatedValue: string, suggestions: T[]) {\n    this.updateSuggestions(suggestions);\n    let itemValue: string | undefined = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    }\n\n    // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n    this.setState(\n      {\n        suggestedDisplayValue: itemValue,\n        suggestionsVisible: this._getShowSuggestions(),\n      },\n      () => this.setState({ suggestionsLoading: false, suggestionsExtendedLoading: false }),\n    );\n  }\n\n  protected onChange(items?: T[]) {\n    if (this.props.onChange) {\n      (this.props.onChange as any)(items);\n    }\n  }\n\n  protected onInputChange = (value: string): void => {\n    this.updateValue(value);\n    this.setState({\n      moreSuggestionsAvailable: true,\n      isMostRecentlyUsedVisible: false,\n    });\n  };\n\n  protected onSuggestionClick = (ev: React.MouseEvent<HTMLElement>, item: any, index: number): void => {\n    this.addItemByIndex(index);\n  };\n\n  protected onSuggestionRemove = (ev: React.MouseEvent<HTMLElement>, item: T, index: number): void => {\n    if (this.props.onRemoveSuggestion) {\n      this.props.onRemoveSuggestion(item);\n    }\n    this.suggestionStore.removeSuggestion(index);\n  };\n\n  protected onInputFocus = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    this.selection.setAllSelected(false);\n    // Only trigger all of the focus if this component isn't already focused.\n    // For example when an item is selected or removed from the selected list it should be treated\n    // as though the input is still focused.\n    if (!this.state.isFocused) {\n      this._userTriggeredSuggestions();\n\n      if (this.props.inputProps && this.props.inputProps.onFocus) {\n        this.props.inputProps.onFocus(ev as React.FocusEvent<HTMLInputElement>);\n      }\n    }\n  };\n\n  protected onInputBlur = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    if (this.props.inputProps && this.props.inputProps.onBlur) {\n      this.props.inputProps.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n    }\n  };\n\n  protected onBlur = (ev: React.FocusEvent<HTMLElement | Autofill>): void => {\n    if (this.state.isFocused) {\n      // Only blur the entire component if an unrelated element gets focus.\n      // Otherwise treat it as though it still has focus.\n      // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really bluring from the whole comboBox\n      let relatedTarget: EventTarget | null = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = getDocumentEx(this.context)!.activeElement;\n      }\n      if (relatedTarget && !elementContains(this.root.current!, relatedTarget as HTMLElement)) {\n        this.setState({ isFocused: false });\n        if (this.props.onBlur) {\n          this.props.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n        }\n      }\n    }\n  };\n\n  /**\n   * Resets focus to last element in wrapper div if clicking back into Picker that has hit item limit\n   */\n  protected onWrapperClick = (ev: React.MouseEvent<HTMLInputElement>): void => {\n    if (this.state.items.length && !this.canAddItems()) {\n      this.resetFocus(this.state.items.length - 1);\n    }\n  };\n\n  /**\n   * Reveals suggestions any time the user clicks on the input element\n   * without shifting focus.\n   */\n  protected onClick = (ev: React.MouseEvent<HTMLInputElement>): void => {\n    if (this.props.inputProps !== undefined && this.props.inputProps.onClick !== undefined) {\n      this.props.inputProps.onClick(ev);\n    }\n\n    // Only primary (left) clicks show suggestions.\n    if (ev.button === 0) {\n      this._userTriggeredSuggestions();\n    }\n  };\n\n  protected onFocus = () => {\n    if (!this.state.isFocused) {\n      this.setState({ isFocused: true });\n    }\n  };\n\n  protected onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    const keyCode = ev.which;\n    switch (keyCode) {\n      case KeyCodes.escape:\n        if (this.state.suggestionsVisible) {\n          this.setState({ suggestionsVisible: false });\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n        break;\n\n      case KeyCodes.tab:\n      case KeyCodes.enter:\n        if (this.suggestionElement.current && this.suggestionElement.current.hasSuggestedActionSelected()) {\n          this.suggestionElement.current.executeSelectedAction();\n        } else if (!ev.shiftKey && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestionsVisible) {\n          this.completeSuggestion();\n          ev.preventDefault();\n          ev.stopPropagation();\n        } else {\n          this._completeGenericSuggestion();\n        }\n\n        break;\n\n      case KeyCodes.backspace:\n        if (!this.props.disabled) {\n          this.onBackspace(ev);\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.del:\n        if (!this.props.disabled) {\n          if (\n            this.input.current &&\n            ev.target === this.input.current.inputElement &&\n            this.state.suggestionsVisible &&\n            this.suggestionStore.currentIndex !== -1\n          ) {\n            if (this.props.onRemoveSuggestion) {\n              this.props.onRemoveSuggestion(this.suggestionStore.currentSuggestion!.item);\n            }\n            this.suggestionStore.removeSuggestion(this.suggestionStore.currentIndex);\n            this.forceUpdate();\n          } else {\n            this.onBackspace(ev);\n          }\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.up:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.forceUpdate();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex === 0\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusAboveSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.previousSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n\n      case KeyCodes.down:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.forceUpdate();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex + 1 === this.suggestionStore.suggestions.length\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusBelowSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.nextSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n    }\n  };\n\n  protected onItemChange = (changedItem: T, index: number): void => {\n    const { items } = this.state;\n\n    if (index >= 0) {\n      const newItems: T[] = items;\n      newItems[index] = changedItem;\n\n      this._updateSelectedItems(newItems);\n    }\n  };\n\n  protected onGetMoreResults = (): void => {\n    this.setState(\n      {\n        isSearching: true,\n      },\n      () => {\n        if (this.props.onGetMoreResults && this.input.current) {\n          const suggestions: T[] | PromiseLike<T[]> = (this.props.onGetMoreResults as any)(\n            this.input.current.value,\n            this.state.items,\n          );\n          const suggestionsArray: T[] = suggestions as T[];\n          const suggestionsPromiseLike: PromiseLike<T[]> = suggestions as PromiseLike<T[]>;\n\n          if (Array.isArray(suggestionsArray)) {\n            this.updateSuggestions(suggestionsArray);\n            this.setState({ isSearching: false });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then((newSuggestions: T[]) => {\n              this.updateSuggestions(newSuggestions);\n              this.setState({ isSearching: false });\n            });\n          }\n        } else {\n          this.setState({ isSearching: false });\n        }\n\n        if (this.input.current) {\n          this.input.current.focus();\n        }\n\n        this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true,\n        });\n      },\n    );\n  };\n\n  protected completeSelection = (item: T) => {\n    this.addItem(item);\n    this.updateValue('');\n    if (this.input.current) {\n      this.input.current.clear();\n    }\n    this.setState({ suggestionsVisible: false });\n  };\n\n  protected addItemByIndex = (index: number): void => {\n    this.completeSelection(this.suggestionStore.getSuggestionAtIndex(index).item);\n  };\n\n  protected addItem = (item: T): void => {\n    const processedItem: T | PromiseLike<T> | null = this.props.onItemSelected\n      ? (this.props.onItemSelected as any)(item)\n      : item;\n\n    if (processedItem === null) {\n      return;\n    }\n\n    const processedItemObject: T = processedItem as T;\n    const processedItemPromiseLike: PromiseLike<T> = processedItem as PromiseLike<T>;\n\n    if (processedItemPromiseLike && processedItemPromiseLike.then) {\n      processedItemPromiseLike.then((resolvedProcessedItem: T) => {\n        const newItems: T[] = this.state.items.concat([resolvedProcessedItem]);\n        this._updateSelectedItems(newItems);\n      });\n    } else {\n      const newItems: T[] = this.state.items.concat([processedItemObject]);\n      this._updateSelectedItems(newItems);\n    }\n    this.setState({ suggestedDisplayValue: '', selectionRemoved: undefined });\n  };\n\n  protected removeItem = (item: T): void => {\n    const { items } = this.state;\n    const index: number = items.indexOf(item);\n\n    if (index >= 0) {\n      const newItems: T[] = items.slice(0, index).concat(items.slice(index + 1));\n      this.setState({ selectionRemoved: item });\n      this._updateSelectedItems(newItems);\n\n      // reset selection removed text after a timeout so it isn't reached by screen reader virtual cursor.\n      // the exact timing isn't important, the live region will fully read even if the text is removed.\n      this._async.setTimeout(() => {\n        this.setState({ selectionRemoved: undefined });\n      }, 1000);\n    }\n  };\n\n  protected removeItems = (itemsToRemove: any[]): void => {\n    const { items } = this.state;\n    const newItems: T[] = items.filter((item: any) => itemsToRemove.indexOf(item) === -1);\n\n    this._updateSelectedItems(newItems);\n  };\n\n  // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    if (\n      (this.state.items.length && !this.input.current) ||\n      (this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0)\n    ) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  }\n\n  /**\n   * @deprecated this is no longer necessary as focuszone has been removed\n   */\n  protected _shouldFocusZoneEnterInnerZone = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n    if (this.state.suggestionsVisible) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.up:\n        case KeyCodes.down:\n          return true;\n      }\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.enter) {\n      return true;\n    }\n\n    return false;\n  };\n\n  protected getActiveDescendant() {\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n\n    const currentIndex = this.suggestionStore.currentIndex;\n\n    if (currentIndex < 0) {\n      // if the suggestions element has actions and the currentIndex does not point to a suggestion,\n      // return the action id\n      if (this.suggestionElement.current?.hasSuggestedAction()) {\n        return 'sug-selectedAction';\n      }\n\n      // If there are no suggestions and no action suggested, then return the ID for the no results found.\n      if (this.suggestionStore.suggestions.length === 0) {\n        return 'sug-noResultsFound';\n      }\n\n      return undefined;\n    } else {\n      return `sug-${currentIndex}`;\n    }\n  }\n\n  /** @deprecated use renderCustomAlert instead */\n  protected getSuggestionsAlert(suggestionAlertClassName: string = legacyStyles.screenReaderOnly) {\n    const currentIndex = this.suggestionStore.currentIndex;\n    if (this.props.enableSelectedSuggestionAlert) {\n      const selectedSuggestion =\n        currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      const selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      // keeping the id/className here for legacy support\n      return (\n        <div id={this._ariaMap.selectedSuggestionAlert} className={suggestionAlertClassName}>\n          {`${selectedSuggestionAlertText} `}\n        </div>\n      );\n    }\n  }\n\n  protected renderCustomAlert(alertClassName: string = legacyStyles.screenReaderOnly) {\n    const { suggestionRemovedText = 'removed {0}' } = this.props;\n    let removedItemText = '';\n\n    if (this.state.selectionRemoved) {\n      const itemName = this._getTextFromItem(this.state.selectionRemoved, '');\n      removedItemText = format(suggestionRemovedText, itemName);\n    }\n\n    return (\n      <div className={alertClassName} id={this._ariaMap.selectedSuggestionAlert} aria-live=\"assertive\">\n        {\n          // eslint-disable-next-line deprecation/deprecation\n          this.getSuggestionsAlert(alertClassName)\n        }\n        {removedItemText}\n      </div>\n    );\n  }\n\n  // do not dismiss if the window resizes or scrolls within 100ms of opening\n  // this prevents the Android issue where pickers immediately dismiss on open, because the keyboard appears\n  private _preventDismissOnScrollOrResize(ev: Event) {\n    if (this._overrideScrollDismiss && (ev.type === 'scroll' || ev.type === 'resize')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /** If suggestions are still loading after a predefined amount of time, set state to show user alert */\n  private _startLoadTimer() {\n    this._async.setTimeout(() => {\n      if (this.state.suggestionsLoading) {\n        this.setState({ suggestionsExtendedLoading: true });\n      }\n    }, EXTENDED_LOAD_TIME);\n  }\n\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n  private _updateAndResolveValue(updatedValue: string | undefined, newSuggestions: T[]) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      const maxSuggestionsCount = this.props.pickerSuggestionsProps?.resultsMaximumNumber;\n      this.suggestionStore.updateSuggestions(newSuggestions, -1, maxSuggestionsCount);\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false,\n          suggestionsExtendedLoading: false,\n        });\n      }\n    }\n  }\n\n  private async _getErrorMessage(items: T[]): Promise<string | JSX.Element | undefined> {\n    if (this.props.errorMessage) {\n      return this.props.errorMessage;\n    }\n    if (this.props.onGetErrorMessage) {\n      try {\n        const errorMessage = this.props.onGetErrorMessage(items);\n        if (errorMessage) {\n          if ((errorMessage as PromiseLike<string | JSX.Element>).then) {\n            return await (errorMessage as PromiseLike<string | JSX.Element>);\n          } else {\n            return errorMessage as string | JSX.Element;\n          }\n        } else {\n          return undefined;\n        }\n      } catch (err) {\n        /* NO-OP */\n      }\n    }\n  }\n\n  private _updateErrorMessage(items: T[]): void {\n    let newErrorMessage: string | JSX.Element | undefined;\n    this._getErrorMessage(items)\n      .then(errorMessage => {\n        newErrorMessage = errorMessage;\n      })\n      .catch(() => {\n        /* NO-OP */\n      })\n      .finally(() => {\n        if (this._isMounted && newErrorMessage !== this.state.errorMessage) {\n          this.setState({ errorMessage: newErrorMessage });\n        }\n      });\n  }\n\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n  private _updateSelectedItems(items: T[]): void {\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({ items }, () => {\n        this._updateErrorMessage(items);\n        this._onSelectedItemsUpdated(items);\n      });\n    }\n  }\n\n  private _onSelectedItemsUpdated(items?: T[]): void {\n    this.onChange(items);\n  }\n\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n  private _getShowSuggestions(): boolean {\n    const areSuggestionsVisible =\n      this.input.current !== undefined &&\n      this.input.current !== null &&\n      this.input.current.inputElement === getDocumentEx(this.context)?.activeElement &&\n      this.input.current.value !== '';\n\n    return areSuggestionsVisible;\n  }\n\n  private _onResolveSuggestions = (updatedValue: string): void => {\n    const suggestions: T[] | PromiseLike<T[]> | null = this.props.onResolveSuggestions(updatedValue, this.state.items);\n\n    if (suggestions !== null) {\n      this.updateSuggestionsList(suggestions, updatedValue);\n    }\n  };\n\n  private _completeGenericSuggestion = (): void => {\n    if (\n      this.props.onValidateInput &&\n      this.input.current &&\n      (this.props.onValidateInput as any)(this.input.current.value) !== ValidationState.invalid &&\n      this.props.createGenericItem\n    ) {\n      const itemToConvert = this.props.createGenericItem(\n        this.input.current.value,\n        this.props.onValidateInput(this.input.current.value),\n      );\n      this.suggestionStore.createGenericSuggestion(itemToConvert);\n      this.completeSuggestion();\n    }\n  };\n\n  private _getTextFromItem(item: T, currentValue?: string): string {\n    if (this.props.getTextFromItem) {\n      return (this.props.getTextFromItem as any)(item, currentValue);\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * This should be called when the user does something other than use text entry to trigger suggestions.\n   *\n   */\n  private _userTriggeredSuggestions = () => {\n    if (!this.state.suggestionsVisible) {\n      const input = this.input.current ? this.input.current.value : '';\n      if (!input) {\n        this.onEmptyInputFocus();\n      } else {\n        if (this.suggestionStore.suggestions.length === 0) {\n          this._onResolveSuggestionsDebounced(input);\n        } else {\n          this.setState({\n            isMostRecentlyUsedVisible: false,\n            suggestionsVisible: true,\n          });\n        }\n      }\n    }\n  };\n}\n\nexport class BasePickerListBelow<T extends {}, P extends IBasePickerProps<T>> extends BasePicker<T, P> {\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused, items } = this.state;\n    const { className, inputProps, disabled, selectionAriaLabel, selectionRole = 'list', theme, styles } = this.props;\n\n    const suggestionsVisible = !!this.state.suggestionsVisible;\n\n    const suggestionsAvailable: string | undefined = suggestionsVisible ? this._ariaMap.suggestionList : undefined;\n    const hasError = !!(this.state.errorMessage ?? this.props.errorMessage);\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          disabled,\n          hasErrorMessage: hasError,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', legacyStyles.picker, className ? className : ''),\n          error: 'ms-BasePicker-error',\n          text: css(\n            'ms-BasePicker-text',\n            legacyStyles.pickerText,\n            this.state.isFocused && legacyStyles.inputFocused,\n            disabled && legacyStyles.inputDisabled,\n          ),\n          itemsWrapper: legacyStyles.pickerItems,\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    const comboLabel = this.props['aria-label'] || inputProps?.['aria-label'];\n    const inputId = inputProps?.id ?? this._ariaMap.combobox;\n\n    return (\n      <div ref={this.root} onBlur={this.onBlur} onFocus={this.onFocus}>\n        {this.renderLabel(inputId, classNames.subComponentStyles?.label)}\n        <div className={classNames.root} onKeyDown={this.onKeyDown}>\n          {this.renderCustomAlert(classNames.screenReaderText)}\n          <span id={`${this._ariaMap.selectedItems}-label`} hidden>\n            {selectionAriaLabel || comboLabel}\n          </span>\n          <div className={classNames.text} aria-owns={suggestionsAvailable}>\n            <Autofill\n              {...(inputProps as any)}\n              className={classNames.input}\n              componentRef={this.input}\n              onFocus={this.onInputFocus}\n              onBlur={this.onInputBlur}\n              onClick={this.onClick}\n              onInputValueChange={this.onInputChange}\n              suggestedDisplayValue={suggestedDisplayValue}\n              aria-activedescendant={suggestionsVisible ? this.getActiveDescendant() : undefined}\n              aria-controls={suggestionsAvailable}\n              aria-expanded={suggestionsVisible}\n              aria-haspopup=\"listbox\"\n              aria-label={comboLabel}\n              aria-describedby={this._getDescribedBy(items, hasError)}\n              role=\"combobox\"\n              id={inputId}\n              disabled={disabled}\n              onInputChange={this.props.onInputChange}\n            />\n          </div>\n        </div>\n        {this.renderSuggestions()}\n        <SelectionZone selection={this.selection} selectionMode={SelectionMode.single}>\n          <div\n            id={this._ariaMap.selectedItems}\n            className=\"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n            role={selectionRole}\n            aria-labelledby={`${this._ariaMap.selectedItems}-label`}\n          >\n            {this.renderItems()}\n          </div>\n        </SelectionZone>\n        {this.renderError(classNames.error)}\n      </div>\n    );\n  }\n\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    // override the existing backspace method to not do anything because the list items appear below.\n  }\n}\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SACEC,KAAK,EACLC,QAAQ,EACRC,GAAG,EACHC,eAAe,EACfC,MAAM,EACNC,KAAK,EACLC,kBAAkB,EAClBC,MAAM,EACNC,sBAAsB,QAEjB,iBAAiB;AACxB,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,SAAS,EAAEC,aAAa,EAAEC,aAAa,QAAQ,iCAAiC;AACzF,SAASC,eAAe,QAAQ,8BAA8B;AAC9D,SAASC,WAAW,QAAQ,2BAA2B;AACvD,SAASC,SAAS,IAAIC,iBAAiB,QAAQ,kCAAkC;AACjF,SAASC,qBAAqB,QAAQ,qCAAqC;AAC3E,SAASC,eAAe,QAAQ,oBAAoB;AACpD,SAASC,QAAQ,QAAQ,mBAAmB;AAC5C,OAAO,KAAKC,YAAY,MAAM,mBAAmB;AACjD,SAASC,KAAK,QAAQ,aAAa;AAWnC,SAASC,aAAa,QAAQ,iCAAiC;AAC/D,SAASC,aAAa,QAAQ,qBAAqB;AAGnD,IAAMC,YAAY,GAAQJ,YAAY;AAEtC,IAAMK,kBAAkB,GAAG,IAAI;AA6C/B,IAAMC,aAAa,GAAGpB,kBAAkB,EAA4C;AAEpF;;;AAGA,SAASqB,oBAAoBA,CAAIC,eAAoE;EACnG,OAAOrB,MAAM,CACXqB,eAAe,EACfZ,iBAAiB,EACjBa,SAAS,EACT;IACEC,KAAK,EAAE;GACR,CACF;AACH;AAEA;;;AAGA,IAAAC,UAAA,0BAAAC,MAAA;EACUC,SAAA,CAAAF,UAAA,EAAAC,MAAA;EAiCR,SAAAD,WAAYG,eAAkB;IAA9B,IAAAC,KAAA,GACEH,MAAA,CAAAI,IAAA,OAAMF,eAAe,CAAC;IA7BxB;IACUC,KAAA,CAAAE,IAAI,GAAGtC,KAAK,CAACuC,SAAS,EAAkB;IACxCH,KAAA,CAAAI,KAAK,GAAGxC,KAAK,CAACuC,SAAS,EAAa;IACpCH,KAAA,CAAAK,iBAAiB,GAAGzC,KAAK,CAACuC,SAAS,EAAmB;IAGhE;;;IAGUH,KAAA,CAAAM,sBAAsB,GAAG3B,WAAkE;IAGrG;IACQqB,KAAA,CAAAO,kBAAkB,GAAGf,oBAAoB,CAACQ,KAAI,CAACM,sBAAsB,CAAC;IAGtEN,KAAA,CAAAQ,UAAU,GAAY,KAAK;IAE3BR,KAAA,CAAAS,sBAAsB,GAAG,KAAK;IAsG/BT,KAAA,CAAAU,kBAAkB,GAAG,UAACC,EAAQ;MACnC,IAAMC,kBAAkB,GAAG,SAAAA,CAAA;QACzB,IAAIC,gBAAgB,GAAmB,IAAI;QAC3C,IAAIb,KAAI,CAACc,KAAK,CAACC,SAAS,EAAE;UACxBF,gBAAgB,GAAGb,KAAI,CAACc,KAAK,CAACC,SAAS,CACrCJ,EAAE,EACFX,KAAI,CAACgB,eAAe,CAACC,iBAAiB,GAAGjB,KAAI,CAACgB,eAAe,CAACC,iBAAiB,CAACC,IAAI,GAAGxB,SAAS,CACjG;;QAGH,IAAI,CAACiB,EAAE,IAAKA,EAAE,IAAI,CAACA,EAAE,CAACQ,gBAAiB,EAAE;UACvC;UACA,IACEN,gBAAgB,KAAK,KAAK,IAC1Bb,KAAI,CAACoB,WAAW,EAAE,IAClBpB,KAAI,CAACgB,eAAe,CAACK,qBAAqB,EAAE,IAC5CrB,KAAI,CAACsB,KAAK,CAACC,qBAAqB,EAChC;YACAvB,KAAI,CAACwB,cAAc,CAAC,CAAC,CAAC;;;MAG5B,CAAC;MAED,IAAIxB,KAAI,CAACyB,cAAc,EAAE;QACvBzB,KAAI,CAACyB,cAAc,CAACC,IAAI,CAAC;UAAM,OAAAd,kBAAkB,EAAE;QAApB,CAAoB,CAAC;OACrD,MAAM;QACLA,kBAAkB,EAAE;;MAGtBZ,KAAI,CAAC2B,QAAQ,CAAC;QAAEC,kBAAkB,EAAE;MAAK,CAAE,CAAC;IAC9C,CAAC;IAUM5B,KAAA,CAAA6B,kBAAkB,GAAG,UAACC,OAAiB;MAC5C9B,KAAI,CAAC+B,UAAU,EAAE;MACjB,IAAI/B,KAAI,CAACgB,eAAe,CAACgB,WAAW,IAAIhC,KAAI,CAACgB,eAAe,CAACgB,WAAW,CAACC,MAAM,GAAG,CAAC,EAAE;QACnF,IAAIH,OAAO,KAAKhE,QAAQ,CAACoE,EAAE,EAAE;UAC3BlC,KAAI,CAACgB,eAAe,CAACmB,qBAAqB,CAACnC,KAAI,CAACgB,eAAe,CAACgB,WAAW,CAACC,MAAM,GAAG,CAAC,CAAC;SACxF,MAAM,IAAIH,OAAO,KAAKhE,QAAQ,CAACsE,IAAI,EAAE;UACpCpC,KAAI,CAACgB,eAAe,CAACmB,qBAAqB,CAAC,CAAC,CAAC;;;IAGnD,CAAC;IAoGSnC,KAAA,CAAAqC,eAAe,GAAG,UAACC,KAAU,EAAEC,QAAiB;MACxD,IAAIC,WAAW,GAAG,EAAE;MACpB,IAAIF,KAAK,CAACL,MAAM,GAAG,CAAC,EAAE;QACpBO,WAAW,IAAIxC,KAAI,CAACyC,QAAQ,CAACC,aAAa,GAAG,GAAG;;MAElD,IAAIH,QAAQ,EAAE;QACZC,WAAW,IAAIxC,KAAI,CAACyC,QAAQ,CAACE,KAAK;;MAEpC,OAAOH,WAAW;IACpB,CAAC;IAiOSxC,KAAA,CAAA4C,aAAa,GAAG,UAACC,KAAa;MACtC7C,KAAI,CAAC8C,WAAW,CAACD,KAAK,CAAC;MACvB7C,KAAI,CAAC2B,QAAQ,CAAC;QACZoB,wBAAwB,EAAE,IAAI;QAC9BC,yBAAyB,EAAE;OAC5B,CAAC;IACJ,CAAC;IAEShD,KAAA,CAAAiD,iBAAiB,GAAG,UAACtC,EAAiC,EAAEO,IAAS,EAAEgC,KAAa;MACxFlD,KAAI,CAACwB,cAAc,CAAC0B,KAAK,CAAC;IAC5B,CAAC;IAESlD,KAAA,CAAAmD,kBAAkB,GAAG,UAACxC,EAAiC,EAAEO,IAAO,EAAEgC,KAAa;MACvF,IAAIlD,KAAI,CAACc,KAAK,CAACsC,kBAAkB,EAAE;QACjCpD,KAAI,CAACc,KAAK,CAACsC,kBAAkB,CAAClC,IAAI,CAAC;;MAErClB,KAAI,CAACgB,eAAe,CAACqC,gBAAgB,CAACH,KAAK,CAAC;IAC9C,CAAC;IAESlD,KAAA,CAAAsD,YAAY,GAAG,UAAC3C,EAAiD;MACzEX,KAAI,CAACuD,SAAS,CAACC,cAAc,CAAC,KAAK,CAAC;MACpC;MACA;MACA;MACA,IAAI,CAACxD,KAAI,CAACsB,KAAK,CAACmC,SAAS,EAAE;QACzBzD,KAAI,CAAC0D,yBAAyB,EAAE;QAEhC,IAAI1D,KAAI,CAACc,KAAK,CAAC6C,UAAU,IAAI3D,KAAI,CAACc,KAAK,CAAC6C,UAAU,CAACC,OAAO,EAAE;UAC1D5D,KAAI,CAACc,KAAK,CAAC6C,UAAU,CAACC,OAAO,CAACjD,EAAwC,CAAC;;;IAG7E,CAAC;IAESX,KAAA,CAAA6D,WAAW,GAAG,UAAClD,EAAiD;MACxE,IAAIX,KAAI,CAACc,KAAK,CAAC6C,UAAU,IAAI3D,KAAI,CAACc,KAAK,CAAC6C,UAAU,CAACG,MAAM,EAAE;QACzD9D,KAAI,CAACc,KAAK,CAAC6C,UAAU,CAACG,MAAM,CAACnD,EAAwC,CAAC;;IAE1E,CAAC;IAESX,KAAA,CAAA8D,MAAM,GAAG,UAACnD,EAA4C;MAC9D,IAAIX,KAAI,CAACsB,KAAK,CAACmC,SAAS,EAAE;QACxB;QACA;QACA;QACA;QACA;QACA,IAAIM,aAAa,GAAuBpD,EAAE,CAACoD,aAAa;QAExD,IAAIpD,EAAE,CAACoD,aAAa,KAAK,IAAI,EAAE;UAC7B;UACA;UACA;UACA;UACA;UACAA,aAAa,GAAG3E,aAAa,CAACY,KAAI,CAACgE,OAAO,CAAE,CAACC,aAAa;;QAE5D,IAAIF,aAAa,IAAI,CAAC/F,eAAe,CAACgC,KAAI,CAACE,IAAI,CAACgE,OAAQ,EAAEH,aAA4B,CAAC,EAAE;UACvF/D,KAAI,CAAC2B,QAAQ,CAAC;YAAE8B,SAAS,EAAE;UAAK,CAAE,CAAC;UACnC,IAAIzD,KAAI,CAACc,KAAK,CAACgD,MAAM,EAAE;YACrB9D,KAAI,CAACc,KAAK,CAACgD,MAAM,CAACnD,EAAwC,CAAC;;;;IAInE,CAAC;IAED;;;IAGUX,KAAA,CAAAmE,cAAc,GAAG,UAACxD,EAAsC;MAChE,IAAIX,KAAI,CAACsB,KAAK,CAACgB,KAAK,CAACL,MAAM,IAAI,CAACjC,KAAI,CAACoB,WAAW,EAAE,EAAE;QAClDpB,KAAI,CAAC+B,UAAU,CAAC/B,KAAI,CAACsB,KAAK,CAACgB,KAAK,CAACL,MAAM,GAAG,CAAC,CAAC;;IAEhD,CAAC;IAED;;;;IAIUjC,KAAA,CAAAoE,OAAO,GAAG,UAACzD,EAAsC;MACzD,IAAIX,KAAI,CAACc,KAAK,CAAC6C,UAAU,KAAKjE,SAAS,IAAIM,KAAI,CAACc,KAAK,CAAC6C,UAAU,CAACS,OAAO,KAAK1E,SAAS,EAAE;QACtFM,KAAI,CAACc,KAAK,CAAC6C,UAAU,CAACS,OAAO,CAACzD,EAAE,CAAC;;MAGnC;MACA,IAAIA,EAAE,CAAC0D,MAAM,KAAK,CAAC,EAAE;QACnBrE,KAAI,CAAC0D,yBAAyB,EAAE;;IAEpC,CAAC;IAES1D,KAAA,CAAA4D,OAAO,GAAG;MAClB,IAAI,CAAC5D,KAAI,CAACsB,KAAK,CAACmC,SAAS,EAAE;QACzBzD,KAAI,CAAC2B,QAAQ,CAAC;UAAE8B,SAAS,EAAE;QAAI,CAAE,CAAC;;IAEtC,CAAC;IAESzD,KAAA,CAAAsE,SAAS,GAAG,UAAC3D,EAAoC;MACzD;MACA,IAAMmB,OAAO,GAAGnB,EAAE,CAAC4D,KAAK;MACxB,QAAQzC,OAAO;QACb,KAAKhE,QAAQ,CAAC0G,MAAM;UAClB,IAAIxE,KAAI,CAACsB,KAAK,CAACM,kBAAkB,EAAE;YACjC5B,KAAI,CAAC2B,QAAQ,CAAC;cAAEC,kBAAkB,EAAE;YAAK,CAAE,CAAC;YAC5CjB,EAAE,CAAC8D,cAAc,EAAE;YACnB9D,EAAE,CAAC+D,eAAe,EAAE;;UAEtB;QAEF,KAAK5G,QAAQ,CAAC6G,GAAG;QACjB,KAAK7G,QAAQ,CAAC8G,KAAK;UACjB,IAAI5E,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,IAAIlE,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAACW,0BAA0B,EAAE,EAAE;YACjG7E,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAACY,qBAAqB,EAAE;WACvD,MAAM,IAAI,CAACnE,EAAE,CAACoE,QAAQ,IAAI/E,KAAI,CAACgB,eAAe,CAACK,qBAAqB,EAAE,IAAIrB,KAAI,CAACsB,KAAK,CAACM,kBAAkB,EAAE;YACxG5B,KAAI,CAACgF,kBAAkB,EAAE;YACzBrE,EAAE,CAAC8D,cAAc,EAAE;YACnB9D,EAAE,CAAC+D,eAAe,EAAE;WACrB,MAAM;YACL1E,KAAI,CAACiF,0BAA0B,EAAE;;UAGnC;QAEF,KAAKnH,QAAQ,CAACoH,SAAS;UACrB,IAAI,CAAClF,KAAI,CAACc,KAAK,CAACqE,QAAQ,EAAE;YACxBnF,KAAI,CAACoF,WAAW,CAACzE,EAAE,CAAC;;UAEtBA,EAAE,CAAC+D,eAAe,EAAE;UACpB;QAEF,KAAK5G,QAAQ,CAACuH,GAAG;UACf,IAAI,CAACrF,KAAI,CAACc,KAAK,CAACqE,QAAQ,EAAE;YACxB,IACEnF,KAAI,CAACI,KAAK,CAAC8D,OAAO,IAClBvD,EAAE,CAAC2E,MAAM,KAAKtF,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACqB,YAAY,IAC7CvF,KAAI,CAACsB,KAAK,CAACM,kBAAkB,IAC7B5B,KAAI,CAACgB,eAAe,CAACwE,YAAY,KAAK,CAAC,CAAC,EACxC;cACA,IAAIxF,KAAI,CAACc,KAAK,CAACsC,kBAAkB,EAAE;gBACjCpD,KAAI,CAACc,KAAK,CAACsC,kBAAkB,CAACpD,KAAI,CAACgB,eAAe,CAACC,iBAAkB,CAACC,IAAI,CAAC;;cAE7ElB,KAAI,CAACgB,eAAe,CAACqC,gBAAgB,CAACrD,KAAI,CAACgB,eAAe,CAACwE,YAAY,CAAC;cACxExF,KAAI,CAACyF,WAAW,EAAE;aACnB,MAAM;cACLzF,KAAI,CAACoF,WAAW,CAACzE,EAAE,CAAC;;;UAGxBA,EAAE,CAAC+D,eAAe,EAAE;UACpB;QAEF,KAAK5G,QAAQ,CAACoE,EAAE;UACd,IAAIlC,KAAI,CAACI,KAAK,CAAC8D,OAAO,IAAIvD,EAAE,CAAC2E,MAAM,KAAKtF,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACqB,YAAY,IAAIvF,KAAI,CAACsB,KAAK,CAACM,kBAAkB,EAAE;YACxG,IACE5B,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,IAC9BlE,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAACwB,gBAAgB,CAAC5D,OAAO,EAAE9B,KAAI,CAACgB,eAAe,CAACwE,YAAY,CAAC,EAC3F;cACA7E,EAAE,CAAC8D,cAAc,EAAE;cACnB9D,EAAE,CAAC+D,eAAe,EAAE;cACpB1E,KAAI,CAACyF,WAAW,EAAE;aACnB,MAAM;cACL,IACEzF,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,IAC9BlE,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAACyB,kBAAkB,EAAE,IACnD3F,KAAI,CAACgB,eAAe,CAACwE,YAAY,KAAK,CAAC,EACvC;gBACA7E,EAAE,CAAC8D,cAAc,EAAE;gBACnB9D,EAAE,CAAC+D,eAAe,EAAE;gBACpB1E,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAAC0B,qBAAqB,EAAE;gBACtD5F,KAAI,CAACgB,eAAe,CAAC6E,sBAAsB,EAAE;gBAC7C7F,KAAI,CAACyF,WAAW,EAAE;eACnB,MAAM;gBACL,IAAIzF,KAAI,CAACgB,eAAe,CAAC8E,kBAAkB,EAAE,EAAE;kBAC7CnF,EAAE,CAAC8D,cAAc,EAAE;kBACnB9D,EAAE,CAAC+D,eAAe,EAAE;kBACpB1E,KAAI,CAAC+F,kBAAkB,EAAE;;;;;UAKjC;QAEF,KAAKjI,QAAQ,CAACsE,IAAI;UAChB,IAAIpC,KAAI,CAACI,KAAK,CAAC8D,OAAO,IAAIvD,EAAE,CAAC2E,MAAM,KAAKtF,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACqB,YAAY,IAAIvF,KAAI,CAACsB,KAAK,CAACM,kBAAkB,EAAE;YACxG,IACE5B,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,IAC9BlE,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAACwB,gBAAgB,CAAC5D,OAAO,EAAE9B,KAAI,CAACgB,eAAe,CAACwE,YAAY,CAAC,EAC3F;cACA7E,EAAE,CAAC8D,cAAc,EAAE;cACnB9D,EAAE,CAAC+D,eAAe,EAAE;cACpB1E,KAAI,CAACyF,WAAW,EAAE;aACnB,MAAM;cACL,IACEzF,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,IAC9BlE,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAACyB,kBAAkB,EAAE,IACnD3F,KAAI,CAACgB,eAAe,CAACwE,YAAY,GAAG,CAAC,KAAKxF,KAAI,CAACgB,eAAe,CAACgB,WAAW,CAACC,MAAM,EACjF;gBACAtB,EAAE,CAAC8D,cAAc,EAAE;gBACnB9D,EAAE,CAAC+D,eAAe,EAAE;gBACpB1E,KAAI,CAACK,iBAAiB,CAAC6D,OAAO,CAAC8B,qBAAqB,EAAE;gBACtDhG,KAAI,CAACgB,eAAe,CAAC6E,sBAAsB,EAAE;gBAC7C7F,KAAI,CAACyF,WAAW,EAAE;eACnB,MAAM;gBACL,IAAIzF,KAAI,CAACgB,eAAe,CAACiF,cAAc,EAAE,EAAE;kBACzCtF,EAAE,CAAC8D,cAAc,EAAE;kBACnB9D,EAAE,CAAC+D,eAAe,EAAE;kBACpB1E,KAAI,CAAC+F,kBAAkB,EAAE;;;;;UAKjC;;IAEN,CAAC;IAES/F,KAAA,CAAAkG,YAAY,GAAG,UAACC,WAAc,EAAEjD,KAAa;MAC7C,IAAAZ,KAAK,GAAKtC,KAAI,CAACsB,KAAK,CAAAgB,KAAf;MAEb,IAAIY,KAAK,IAAI,CAAC,EAAE;QACd,IAAMkD,QAAQ,GAAQ9D,KAAK;QAC3B8D,QAAQ,CAAClD,KAAK,CAAC,GAAGiD,WAAW;QAE7BnG,KAAI,CAACqG,oBAAoB,CAACD,QAAQ,CAAC;;IAEvC,CAAC;IAESpG,KAAA,CAAAsG,gBAAgB,GAAG;MAC3BtG,KAAI,CAAC2B,QAAQ,CACX;QACE4E,WAAW,EAAE;OACd,EACD;QACE,IAAIvG,KAAI,CAACc,KAAK,CAACwF,gBAAgB,IAAItG,KAAI,CAACI,KAAK,CAAC8D,OAAO,EAAE;UACrD,IAAMlC,WAAW,GAA4BhC,KAAI,CAACc,KAAK,CAACwF,gBAAwB,CAC9EtG,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACrB,KAAK,EACxB7C,KAAI,CAACsB,KAAK,CAACgB,KAAK,CACjB;UACD,IAAMkE,gBAAgB,GAAQxE,WAAkB;UAChD,IAAMyE,sBAAsB,GAAqBzE,WAA+B;UAEhF,IAAI0E,KAAK,CAACC,OAAO,CAACH,gBAAgB,CAAC,EAAE;YACnCxG,KAAI,CAAC4G,iBAAiB,CAACJ,gBAAgB,CAAC;YACxCxG,KAAI,CAAC2B,QAAQ,CAAC;cAAE4E,WAAW,EAAE;YAAK,CAAE,CAAC;WACtC,MAAM,IAAIE,sBAAsB,CAAC/E,IAAI,EAAE;YACtC+E,sBAAsB,CAAC/E,IAAI,CAAC,UAACmF,cAAmB;cAC9C7G,KAAI,CAAC4G,iBAAiB,CAACC,cAAc,CAAC;cACtC7G,KAAI,CAAC2B,QAAQ,CAAC;gBAAE4E,WAAW,EAAE;cAAK,CAAE,CAAC;YACvC,CAAC,CAAC;;SAEL,MAAM;UACLvG,KAAI,CAAC2B,QAAQ,CAAC;YAAE4E,WAAW,EAAE;UAAK,CAAE,CAAC;;QAGvC,IAAIvG,KAAI,CAACI,KAAK,CAAC8D,OAAO,EAAE;UACtBlE,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAAC4C,KAAK,EAAE;;QAG5B9G,KAAI,CAAC2B,QAAQ,CAAC;UACZoB,wBAAwB,EAAE,KAAK;UAC/BgE,sBAAsB,EAAE;SACzB,CAAC;MACJ,CAAC,CACF;IACH,CAAC;IAES/G,KAAA,CAAAgH,iBAAiB,GAAG,UAAC9F,IAAO;MACpClB,KAAI,CAACiH,OAAO,CAAC/F,IAAI,CAAC;MAClBlB,KAAI,CAAC8C,WAAW,CAAC,EAAE,CAAC;MACpB,IAAI9C,KAAI,CAACI,KAAK,CAAC8D,OAAO,EAAE;QACtBlE,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACgD,KAAK,EAAE;;MAE5BlH,KAAI,CAAC2B,QAAQ,CAAC;QAAEC,kBAAkB,EAAE;MAAK,CAAE,CAAC;IAC9C,CAAC;IAES5B,KAAA,CAAAwB,cAAc,GAAG,UAAC0B,KAAa;MACvClD,KAAI,CAACgH,iBAAiB,CAAChH,KAAI,CAACgB,eAAe,CAACmG,oBAAoB,CAACjE,KAAK,CAAC,CAAChC,IAAI,CAAC;IAC/E,CAAC;IAESlB,KAAA,CAAAiH,OAAO,GAAG,UAAC/F,IAAO;MAC1B,IAAMkG,aAAa,GAA8BpH,KAAI,CAACc,KAAK,CAACuG,cAAc,GACrErH,KAAI,CAACc,KAAK,CAACuG,cAAsB,CAACnG,IAAI,CAAC,GACxCA,IAAI;MAER,IAAIkG,aAAa,KAAK,IAAI,EAAE;QAC1B;;MAGF,IAAME,mBAAmB,GAAMF,aAAkB;MACjD,IAAMG,wBAAwB,GAAmBH,aAA+B;MAEhF,IAAIG,wBAAwB,IAAIA,wBAAwB,CAAC7F,IAAI,EAAE;QAC7D6F,wBAAwB,CAAC7F,IAAI,CAAC,UAAC8F,qBAAwB;UACrD,IAAMpB,QAAQ,GAAQpG,KAAI,CAACsB,KAAK,CAACgB,KAAK,CAACmF,MAAM,CAAC,CAACD,qBAAqB,CAAC,CAAC;UACtExH,KAAI,CAACqG,oBAAoB,CAACD,QAAQ,CAAC;QACrC,CAAC,CAAC;OACH,MAAM;QACL,IAAMA,QAAQ,GAAQpG,KAAI,CAACsB,KAAK,CAACgB,KAAK,CAACmF,MAAM,CAAC,CAACH,mBAAmB,CAAC,CAAC;QACpEtH,KAAI,CAACqG,oBAAoB,CAACD,QAAQ,CAAC;;MAErCpG,KAAI,CAAC2B,QAAQ,CAAC;QAAEJ,qBAAqB,EAAE,EAAE;QAAEmG,gBAAgB,EAAEhI;MAAS,CAAE,CAAC;IAC3E,CAAC;IAESM,KAAA,CAAA2H,UAAU,GAAG,UAACzG,IAAO;MACrB,IAAAoB,KAAK,GAAKtC,KAAI,CAACsB,KAAK,CAAAgB,KAAf;MACb,IAAMY,KAAK,GAAWZ,KAAK,CAACsF,OAAO,CAAC1G,IAAI,CAAC;MAEzC,IAAIgC,KAAK,IAAI,CAAC,EAAE;QACd,IAAMkD,QAAQ,GAAQ9D,KAAK,CAACuF,KAAK,CAAC,CAAC,EAAE3E,KAAK,CAAC,CAACuE,MAAM,CAACnF,KAAK,CAACuF,KAAK,CAAC3E,KAAK,GAAG,CAAC,CAAC,CAAC;QAC1ElD,KAAI,CAAC2B,QAAQ,CAAC;UAAE+F,gBAAgB,EAAExG;QAAI,CAAE,CAAC;QACzClB,KAAI,CAACqG,oBAAoB,CAACD,QAAQ,CAAC;QAEnC;QACA;QACApG,KAAI,CAAC8H,MAAM,CAACC,UAAU,CAAC;UACrB/H,KAAI,CAAC2B,QAAQ,CAAC;YAAE+F,gBAAgB,EAAEhI;UAAS,CAAE,CAAC;QAChD,CAAC,EAAE,IAAI,CAAC;;IAEZ,CAAC;IAESM,KAAA,CAAAgI,WAAW,GAAG,UAACC,aAAoB;MACnC,IAAA3F,KAAK,GAAKtC,KAAI,CAACsB,KAAK,CAAAgB,KAAf;MACb,IAAM8D,QAAQ,GAAQ9D,KAAK,CAAC4F,MAAM,CAAC,UAAChH,IAAS;QAAK,OAAA+G,aAAa,CAACL,OAAO,CAAC1G,IAAI,CAAC,KAAK,CAAC,CAAC;MAAlC,CAAkC,CAAC;MAErFlB,KAAI,CAACqG,oBAAoB,CAACD,QAAQ,CAAC;IACrC,CAAC;IAiBD;;;IAGUpG,KAAA,CAAAmI,8BAA8B,GAAG,UAACxH,EAAoC;MAC9E;MACA,IAAIX,KAAI,CAACsB,KAAK,CAACM,kBAAkB,EAAE;QACjC;QACA,QAAQjB,EAAE,CAAC4D,KAAK;UACd,KAAKzG,QAAQ,CAACoE,EAAE;UAChB,KAAKpE,QAAQ,CAACsE,IAAI;YAChB,OAAO,IAAI;;;MAIjB;MACA,IAAIzB,EAAE,CAAC4D,KAAK,KAAKzG,QAAQ,CAAC8G,KAAK,EAAE;QAC/B,OAAO,IAAI;;MAGb,OAAO,KAAK;IACd,CAAC;IA8KO5E,KAAA,CAAAoI,qBAAqB,GAAG,UAACC,YAAoB;MACnD,IAAMrG,WAAW,GAAkChC,KAAI,CAACc,KAAK,CAACwH,oBAAoB,CAACD,YAAY,EAAErI,KAAI,CAACsB,KAAK,CAACgB,KAAK,CAAC;MAElH,IAAIN,WAAW,KAAK,IAAI,EAAE;QACxBhC,KAAI,CAACuI,qBAAqB,CAACvG,WAAW,EAAEqG,YAAY,CAAC;;IAEzD,CAAC;IAEOrI,KAAA,CAAAiF,0BAA0B,GAAG;MACnC,IACEjF,KAAI,CAACc,KAAK,CAAC0H,eAAe,IAC1BxI,KAAI,CAACI,KAAK,CAAC8D,OAAO,IACjBlE,KAAI,CAACc,KAAK,CAAC0H,eAAuB,CAACxI,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACrB,KAAK,CAAC,KAAK9D,eAAe,CAAC0J,OAAO,IACzFzI,KAAI,CAACc,KAAK,CAAC4H,iBAAiB,EAC5B;QACA,IAAMC,aAAa,GAAG3I,KAAI,CAACc,KAAK,CAAC4H,iBAAiB,CAChD1I,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACrB,KAAK,EACxB7C,KAAI,CAACc,KAAK,CAAC0H,eAAe,CAACxI,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACrB,KAAK,CAAC,CACrD;QACD7C,KAAI,CAACgB,eAAe,CAAC4H,uBAAuB,CAACD,aAAa,CAAC;QAC3D3I,KAAI,CAACgF,kBAAkB,EAAE;;IAE7B,CAAC;IAUD;;;;IAIQhF,KAAA,CAAA0D,yBAAyB,GAAG;MAClC,IAAI,CAAC1D,KAAI,CAACsB,KAAK,CAACM,kBAAkB,EAAE;QAClC,IAAMxB,KAAK,GAAGJ,KAAI,CAACI,KAAK,CAAC8D,OAAO,GAAGlE,KAAI,CAACI,KAAK,CAAC8D,OAAO,CAACrB,KAAK,GAAG,EAAE;QAChE,IAAI,CAACzC,KAAK,EAAE;UACVJ,KAAI,CAAC6I,iBAAiB,EAAE;SACzB,MAAM;UACL,IAAI7I,KAAI,CAACgB,eAAe,CAACgB,WAAW,CAACC,MAAM,KAAK,CAAC,EAAE;YACjDjC,KAAI,CAAC8I,8BAA8B,CAAC1I,KAAK,CAAC;WAC3C,MAAM;YACLJ,KAAI,CAAC2B,QAAQ,CAAC;cACZqB,yBAAyB,EAAE,KAAK;cAChCpB,kBAAkB,EAAE;aACrB,CAAC;;;;IAIV,CAAC;IAhiCCvD,sBAAsB,CAAC2B,KAAI,CAAC;IAE5B,IAAMsC,KAAK,GAAQvC,eAAe,CAAC2C,aAAa,IAAI3C,eAAe,CAACgJ,oBAAoB,IAAI,EAAE;IAE9F/I,KAAI,CAACgJ,GAAG,GAAG9K,KAAK,EAAE;IAClB8B,KAAI,CAACyC,QAAQ,GAAG;MACdC,aAAa,EAAE,kBAAA+E,MAAA,CAAkBzH,KAAI,CAACgJ,GAAG,CAAE;MAC3CC,uBAAuB,EAAE,6BAAAxB,MAAA,CAA6BzH,KAAI,CAACgJ,GAAG,CAAE;MAChEE,cAAc,EAAE,mBAAAzB,MAAA,CAAmBzH,KAAI,CAACgJ,GAAG,CAAE;MAC7CG,QAAQ,EAAE,YAAA1B,MAAA,CAAYzH,KAAI,CAACgJ,GAAG,CAAE;MAChCrG,KAAK,EAAE,SAAA8E,MAAA,CAASzH,KAAI,CAACgJ,GAAG;KACzB;IACDhJ,KAAI,CAACgB,eAAe,GAAG,IAAIlC,qBAAqB,EAAK;IACrDkB,KAAI,CAACuD,SAAS,GAAG,IAAIhF,SAAS,CAAC;MAAE6K,kBAAkB,EAAE,SAAAA,CAAA;QAAM,OAAApJ,KAAI,CAACqJ,iBAAiB,EAAE;MAAxB;IAAwB,CAAE,CAAC;IACtFrJ,KAAI,CAACuD,SAAS,CAAC+F,QAAQ,CAAChH,KAAK,CAAC;IAC9BtC,KAAI,CAACsB,KAAK,GAAG;MACXgB,KAAK,EAAAA,KAAA;MACLf,qBAAqB,EAAE,EAAE;MACzByB,yBAAyB,EAAE,KAAK;MAChCD,wBAAwB,EAAE,KAAK;MAC/BU,SAAS,EAAE,KAAK;MAChB8C,WAAW,EAAE,KAAK;MAClBgD,eAAe,EAAE,EAAE;MACnB7B,gBAAgB,EAAEhI;KACnB;;EACH;EAnCcE,UAAA,CAAA4J,wBAAwB,GAAtC,UAAuCC,QAA+B;IACpE,IAAIA,QAAQ,CAAC/G,aAAa,EAAE;MAC1B,OAAO;QAAEJ,KAAK,EAAEmH,QAAQ,CAAC/G;MAAa,CAAE;;IAE1C,OAAO,IAAI;EACb,CAAC;EAgCDgH,MAAA,CAAAC,cAAA,CAAW/J,UAAA,CAAAgK,SAAA,SAAK;SAAhB,SAAAC,CAAA;MACE,OAAO,IAAI,CAACvI,KAAK,CAACgB,KAAK;IACzB,CAAC;;;;EAEM1C,UAAA,CAAAgK,SAAA,CAAAE,iBAAiB,GAAxB;IACE,IAAI,CAACtJ,UAAU,GAAG,IAAI;IACtB,IAAI,CAACsH,MAAM,GAAG,IAAIjK,KAAK,CAAC,IAAI,CAAC;IAC7B,IAAI,CAACkM,mBAAmB,CAAC,IAAI,CAACzI,KAAK,CAACgB,KAAK,CAAC;IAC1C,IAAI,CAACiB,SAAS,CAAC+F,QAAQ,CAAC,IAAI,CAAChI,KAAK,CAACgB,KAAK,CAAC;IACzC,IAAI,CAACwG,8BAA8B,GAAG,IAAI,CAAChB,MAAM,CAACkC,QAAQ,CAAC,IAAI,CAAC5B,qBAAqB,EAAE,IAAI,CAACtH,KAAK,CAACmJ,YAAY,CAAC;EACjH,CAAC;EAEMrK,UAAA,CAAAgK,SAAA,CAAAM,kBAAkB,GAAzB,UAA0BC,QAAW,EAAEC,QAA6B;IAApE,IAAApK,KAAA;IACE,IAAI,IAAI,CAACsB,KAAK,CAACgB,KAAK,IAAI,IAAI,CAAChB,KAAK,CAACgB,KAAK,KAAK8H,QAAQ,CAAC9H,KAAK,EAAE;MAC3D,IAAM+H,oBAAoB,GAAG,IAAI,CAAC9G,SAAS,CAAC+G,kBAAkB,EAAE,CAAC,CAAC,CAAC;MACnE,IAAI,CAAC/G,SAAS,CAAC+F,QAAQ,CAAC,IAAI,CAAChI,KAAK,CAACgB,KAAK,CAAC;MACzC,IAAI,IAAI,CAAChB,KAAK,CAACmC,SAAS,EAAE;QACxB;QACA;QACA,IAAI,IAAI,CAACnC,KAAK,CAACgB,KAAK,CAACL,MAAM,GAAGmI,QAAQ,CAAC9H,KAAK,CAACL,MAAM,EAAE;UACnD,IAAI,CAACsB,SAAS,CAACgH,gBAAgB,CAACF,oBAAoB,EAAE,KAAK,EAAE,IAAI,CAAC;UAClE,IAAI,CAACtI,UAAU,CAACsI,oBAAoB,CAAC;;QAEvC;QAAA,KACK,IAAI,IAAI,CAAC/I,KAAK,CAACgB,KAAK,CAACL,MAAM,GAAGmI,QAAQ,CAAC9H,KAAK,CAACL,MAAM,IAAI,CAAC,IAAI,CAACb,WAAW,EAAE,EAAE;UAC/E,IAAI,CAACW,UAAU,CAAC,IAAI,CAACT,KAAK,CAACgB,KAAK,CAACL,MAAM,GAAG,CAAC,CAAC;;;;IAKlD,IAAI,CAAC8H,mBAAmB,CAAC,IAAI,CAACzI,KAAK,CAACgB,KAAK,CAAC;IAE1C;IACA,IAAI,IAAI,CAAChB,KAAK,CAACM,kBAAkB,IAAI,CAACwI,QAAQ,CAACxI,kBAAkB,EAAE;MACjE,IAAI,CAACnB,sBAAsB,GAAG,IAAI;MAClC,IAAI,CAACqH,MAAM,CAAC0C,YAAY,CAAC,IAAI,CAACC,4BAA4B,CAAC;MAC3D,IAAI,CAACA,4BAA4B,GAAG,IAAI,CAAC3C,MAAM,CAACC,UAAU,CAAC;QACzD/H,KAAI,CAACS,sBAAsB,GAAG,KAAK;MACrC,CAAC,EAAE,GAAG,CAAC;;EAEX,CAAC;EAEMb,UAAA,CAAAgK,SAAA,CAAAc,oBAAoB,GAA3B;IACE,IAAI,CAAClK,UAAU,GAAG,KAAK;IACvB,IAAI,IAAI,CAACiB,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,GAAG/B,SAAS;;IAEjC,IAAI,CAACoI,MAAM,CAAC6C,OAAO,EAAE;EACvB,CAAC;EAEM/K,UAAA,CAAAgK,SAAA,CAAA9C,KAAK,GAAZ;IACE,IAAI,IAAI,CAAC1G,KAAK,CAAC8D,OAAO,EAAE;MACtB,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAAC4C,KAAK,EAAE;;EAE9B,CAAC;EAEMlH,UAAA,CAAAgK,SAAA,CAAAgB,UAAU,GAAjB;IACE,IAAI,IAAI,CAACxK,KAAK,CAAC8D,OAAO,EAAE;MACtB,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAAC4C,KAAK,EAAE;;EAE9B,CAAC;EAkCMlH,UAAA,CAAAgK,SAAA,CAAA5E,kBAAkB,GAAzB,UAA0B6F,aAAuB;IAC/C,IAAI,IAAI,CAAC7J,eAAe,CAACK,qBAAqB,EAAE,IAAI,IAAI,CAACjB,KAAK,CAAC8D,OAAO,EAAE;MACtE,IAAI,CAAC8C,iBAAiB,CAAC,IAAI,CAAChG,eAAe,CAACC,iBAAkB,CAACC,IAAI,CAAC;KACrE,MAAM,IAAI2J,aAAa,EAAE;MACxB,IAAI,CAAC5F,0BAA0B,EAAE;;EAErC,CAAC;EAaMrF,UAAA,CAAAgK,SAAA,CAAAkB,MAAM,GAAb;;IACQ,IAAAC,EAAA,GAA8C,IAAI,CAACzJ,KAAK;MAAtDC,qBAAqB,GAAAwJ,EAAA,CAAAxJ,qBAAA;MAAEkC,SAAS,GAAAsH,EAAA,CAAAtH,SAAA;MAAEnB,KAAK,GAAAyI,EAAA,CAAAzI,KAAe;IACxD,IAAA0I,EAAA,GAAiG,IAAI,CAAClK,KAAK;MAAzGmK,SAAS,GAAAD,EAAA,CAAAC,SAAA;MAAEtH,UAAU,GAAAqH,EAAA,CAAArH,UAAA;MAAEwB,QAAQ,GAAA6F,EAAA,CAAA7F,QAAA;MAAE+F,kBAAkB,GAAAF,EAAA,CAAAE,kBAAA;MAAEC,EAAA,GAAAH,EAAA,CAAAI,aAAsB;MAAtBA,aAAa,GAAAD,EAAA,cAAG,MAAM,GAAAA,EAAA;MAAEE,KAAK,GAAAL,EAAA,CAAAK,KAAA;MAAEC,MAAM,GAAAN,EAAA,CAAAM,MAAe;IAEjH,IAAM1J,kBAAkB,GAAG,CAAC,CAAC,IAAI,CAACN,KAAK,CAACM,kBAAkB;IAC1D,IAAM2J,oBAAoB,GAAG3J,kBAAkB,GAAG,IAAI,CAACa,QAAQ,CAACyG,cAAc,GAAGxJ,SAAS;IAC1F,IAAM6C,QAAQ,GAAG,CAAC,EAAE,CAAAiJ,EAAA,OAAI,CAAClK,KAAK,CAACmK,YAAY,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAC1K,KAAK,CAAC2K,YAAY,CAAC;IACvE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAMC,UAAU,GAAmDJ,MAAM,GACrE/L,aAAa,CAAC+L,MAAM,EAAE;MACpBD,KAAK,EAAAA,KAAA;MACLJ,SAAS,EAAAA,SAAA;MACTxH,SAAS,EAAAA,SAAA;MACT0B,QAAQ,EAAAA,QAAA;MACRwG,eAAe,EAAEpJ,QAAQ;MACzBqJ,cAAc,EAAEjI,UAAU,IAAIA,UAAU,CAACsH;KAC1C,CAAC,GACF;MACE/K,IAAI,EAAEnC,GAAG,CAAC,eAAe,EAAEkN,SAAS,GAAGA,SAAS,GAAG,EAAE,CAAC;MACtDtI,KAAK,EAAE,qBAAqB;MAC5BkJ,IAAI,EAAE9N,GAAG,CAAC,oBAAoB,EAAEsB,YAAY,CAACyM,UAAU,EAAE,IAAI,CAACxK,KAAK,CAACmC,SAAS,IAAIpE,YAAY,CAAC0M,YAAY,CAAC;MAC3GC,YAAY,EAAE3M,YAAY,CAAC4M,WAAW;MACtC7L,KAAK,EAAErC,GAAG,CAAC,qBAAqB,EAAEsB,YAAY,CAAC6M,WAAW,EAAEvI,UAAU,IAAIA,UAAU,CAACsH,SAAS,CAAC;MAC/FkB,gBAAgB,EAAE9M,YAAY,CAAC+M;KAChC;IAEL,IAAMC,UAAU,GAAG,IAAI,CAACvL,KAAK,CAAC,YAAY,CAAC,KAAI6C,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAG,YAAY,CAAC;IACzE,IAAM2I,OAAO,GAAG,CAAAC,EAAA,GAAA5I,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE6I,EAAE,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAC9J,QAAQ,CAAC0G,QAAQ;IAExD;IACA;IACA;IACA;IACA,OACEvL,KAAA,CAAA6O,aAAA;MACEC,GAAG,EAAE,IAAI,CAACxM,IAAI;MACd+K,SAAS,EAAES,UAAU,CAACxL,IAAI;MAC1BoE,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBV,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBE,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBM,OAAO,EAAE,IAAI,CAACD;IAAc,GAE3B,IAAI,CAACwI,WAAW,CAACL,OAAO,EAAE,CAAAM,EAAA,GAAAlB,UAAU,CAACmB,kBAAkB,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,KAAK,CAAC,EAC/D,IAAI,CAACC,iBAAiB,CAACrB,UAAU,CAACS,gBAAgB,CAAC,EACpDvO,KAAA,CAAA6O,aAAA;MAAMD,EAAE,EAAE,GAAA/E,MAAA,CAAG,IAAI,CAAChF,QAAQ,CAACC,aAAa,WAAQ;MAAEsK,MAAM;IAAA,GACrD9B,kBAAkB,IAAImB,UAAU,CAC5B,EACPzO,KAAA,CAAA6O,aAAA,CAACjO,aAAa;MAAC+E,SAAS,EAAE,IAAI,CAACA,SAAS;MAAE0J,aAAa,EAAExO,aAAa,CAACyO;IAAQ,GAC7EtP,KAAA,CAAA6O,aAAA;MAAKxB,SAAS,EAAES,UAAU,CAACG,IAAI;MAAA,aAAaN;IAAoB,GAC7DjJ,KAAK,CAACL,MAAM,GAAG,CAAC,IACfrE,KAAA,CAAA6O,aAAA;MACED,EAAE,EAAE,IAAI,CAAC/J,QAAQ,CAACC,aAAa;MAC/BuI,SAAS,EAAES,UAAU,CAACM,YAAY;MAClCmB,IAAI,EAAE/B,aAAa;MAAA,mBACF,GAAA3D,MAAA,CAAG,IAAI,CAAChF,QAAQ,CAACC,aAAa;IAAQ,GAEtD,IAAI,CAAC0K,WAAW,EAAE,CAEtB,EACA,IAAI,CAAChM,WAAW,EAAE,IACjBxD,KAAA,CAAA6O,aAAA,CAACzN,QAAQ,EAAAqO,QAAA;MACPC,UAAU,EAAE;IAAK,GACZ3J,UAAkB;MACvBsH,SAAS,EAAES,UAAU,CAACtL,KAAK;MAC3BmN,YAAY,EAAE,IAAI,CAACnN,KAAK;MACxBoM,EAAE,EAAEF,OAAO;MACXlI,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBR,OAAO,EAAE,IAAI,CAACN,YAAY;MAC1BQ,MAAM,EAAE,IAAI,CAACD,WAAW;MACxB2J,kBAAkB,EAAE,IAAI,CAAC5K,aAAa;MACtCrB,qBAAqB,EAAEA,qBAAqB;MAAA,yBACrBK,kBAAkB,GAAG,IAAI,CAAC6L,mBAAmB,EAAE,GAAG/N,SAAS;MAAA,iBACnE6L,oBAAoB;MAAA,oBACjB,IAAI,CAAClJ,eAAe,CAACC,KAAK,EAAEC,QAAQ,CAAC;MAAA,iBACxCX,kBAAkB;MAAA,iBACnB,SAAS;MAAA,cACXyK,UAAU;MACtBc,IAAI,EAAC,UAAU;MACfhI,QAAQ,EAAEA,QAAQ;MAClBvC,aAAa,EAAE,IAAI,CAAC9B,KAAK,CAAC8B;IAAa,GAE1C,CACG,CACQ,EACf,IAAI,CAAC8K,WAAW,CAAChC,UAAU,CAAC/I,KAAK,CAAC,EAClC,IAAI,CAACgL,iBAAiB,EAAE,CACrB;EAEV,CAAC;EAaS/N,UAAA,CAAAgK,SAAA,CAAAxI,WAAW,GAArB;IACU,IAAAkB,KAAK,GAAK,IAAI,CAAChB,KAAK,CAAAgB,KAAf;IACL,IAAAsL,SAAS,GAAK,IAAI,CAAC9M,KAAK,CAAA8M,SAAf;IACjB,OAAOA,SAAS,KAAKlO,SAAS,IAAI4C,KAAK,CAACL,MAAM,GAAG2L,SAAS;EAC5D,CAAC;EAEShO,UAAA,CAAAgK,SAAA,CAAA+C,WAAW,GAArB,UACEL,OAAe,EACfhB,MAA0E;IAEpE,IAAAE,EAAA,GAAgC,IAAI,CAAC1K,KAAK;MAAxCgM,KAAK,GAAAtB,EAAA,CAAAsB,KAAA;MAAE3H,QAAQ,GAAAqG,EAAA,CAAArG,QAAA;MAAE0I,QAAQ,GAAArC,EAAA,CAAAqC,QAAe;IAChD,IAAI,CAACf,KAAK,EAAE;MACV,OAAO,IAAI;;IAEb,OACElP,KAAA,CAAA6O,aAAA,CAACvN,KAAK;MAAC+L,SAAS,EAAC,qBAAqB;MAACK,MAAM,EAAEA,MAAM;MAAEnG,QAAQ,EAAEA,QAAQ;MAAE0I,QAAQ,EAAEA,QAAQ;MAAEC,OAAO,EAAExB;IAAO,GAC5GQ,KAAK,CACA;EAEZ,CAAC;EAESlN,UAAA,CAAAgK,SAAA,CAAA8D,WAAW,GAArB,UAAsBzC,SAAkB;IAC9B,IAAAO,EAAA,GAA2C,IAAI,CAAC1K,KAAK,CAAA2K,YAAf;MAAtCA,YAAY,GAAAD,EAAA,cAAG,IAAI,CAAClK,KAAK,CAACmK,YAAY,GAAAD,EAAA;IAC9C,IAAI,CAACC,YAAY,EAAE;MACjB,OAAO,IAAI;;IAEb,OACE7N,KAAA,CAAA6O,aAAA;MAAKU,IAAI,EAAC,OAAO;MAACX,EAAE,EAAE,IAAI,CAAC/J,QAAQ,CAACE,KAAK;MAAEsI,SAAS,EAAEA;IAAS,GAC5DQ,YAAY,CACT;EAEV,CAAC;EAES7L,UAAA,CAAAgK,SAAA,CAAA+D,iBAAiB,GAA3B;IAAA,IAAA3N,KAAA;IACE,IAAM+N,sBAAsB,GAAkD,IAAI,CAACxN,kBAAkB;IAErG,OAAO,IAAI,CAACe,KAAK,CAACM,kBAAkB,IAAI,IAAI,CAACxB,KAAK,GAChDxC,KAAA,CAAA6O,aAAA,CAACnO,OAAO,EAAA+O,QAAA;MACNW,aAAa,EAAE,KAAK;MACpBC,QAAQ,EAAE,CAAC;MACX3I,MAAM,EAAE,IAAI,CAAClF,KAAK,CAAC8D,OAAO,GAAG,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAACqB,YAAY,GAAG7F,SAAS;MACxEqB,SAAS,EAAE,IAAI,CAACL,kBAAkB;MAClCwN,eAAe,EAAExP,eAAe,CAACyP,cAAc;MAC/CC,qBAAqB,EAAE1P,eAAe,CAAC2P,eAAe;MACtD;MACAC,qBAAqB,EAAE,SAAAA,CAAC3N,EAAS;QAAK,OAAAX,KAAI,CAACuO,+BAA+B,CAAC5N,EAAE,CAAC;MAAxC;IAAwC,GAC1E,IAAI,CAACG,KAAK,CAAC0N,kBAAkB,GAEjC5Q,KAAA,CAAA6O,aAAA,CAACsB;IACC;IAAA,E;MAAA;MACAU,kBAAkB,EAAE,IAAI,CAAC3N,KAAK,CAAC4N,uBAAwB;MACvDzL,iBAAiB,EAAE,IAAI,CAACA,iBAAiB;MACzCE,kBAAkB,EAAE,IAAI,CAACA,kBAAkB;MAC3CnB,WAAW,EAAE,IAAI,CAAChB,eAAe,CAAC2N,cAAc,EAAE;MAClDpB,YAAY,EAAE,IAAI,CAAClN,iBAAiB;MACpCiG,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;MACvCvD,wBAAwB,EAAE,IAAI,CAACzB,KAAK,CAACyB,wBAAwB;MAC7D6L,SAAS,EAAE,IAAI,CAACtN,KAAK,CAACuN,kBAAkB;MACxCC,iBAAiB,EAAE,IAAI,CAACxN,KAAK,CAACyN,0BAA0B;MACxDxI,WAAW,EAAE,IAAI,CAACjF,KAAK,CAACiF,WAAW;MACnCvD,yBAAyB,EAAE,IAAI,CAAC1B,KAAK,CAAC0B,yBAAyB;MAC/D+D,sBAAsB,EAAE,IAAI,CAACzF,KAAK,CAACyF,sBAAsB;MACzDlF,kBAAkB,EAAE,IAAI,CAACA,kBAAkB;MAC3CmN,yBAAyB,EAAE,IAAI,CAAClO,KAAK,CAACmO,qBAAqB;MAC3DC,iBAAiB,EAAE,IAAI,CAACzM,QAAQ,CAACyG,cAAc;MAC/CR,iBAAiB,EAAE,IAAI,CAACzD;IAA0B,GAC9C,IAAI,CAACnE,KAAK,CAACqO,sBAAsB,EACrC,CACM,GACR,IAAI;EACV,CAAC;EAESvP,UAAA,CAAAgK,SAAA,CAAAwD,WAAW,GAArB;IAAA,IAAApN,KAAA;IACQ,IAAAwL,EAAA,GAA6D,IAAI,CAAC1K,KAAK;MAArEqE,QAAQ,GAAAqG,EAAA,CAAArG,QAAA;MAAE8J,qBAAqB,GAAAzD,EAAA,CAAAyD,qBAAA;MAAEG,qBAAqB,GAAA5D,EAAA,CAAA4D,qBAAe;IAC7E,IAAMC,YAAY,GAAG,IAAI,CAACvO,KAAK,CAACuO,YAA2D;IAErF,IAAA9C,EAAA,GAA6B,IAAI,CAACjL,KAAK;MAArCgB,KAAK,GAAAiK,EAAA,CAAAjK,KAAA;MAAEiH,eAAe,GAAAgD,EAAA,CAAAhD,eAAe;IAC7C,OAAOjH,KAAK,CAACgN,GAAG,CAAC,UAACpO,IAAS,EAAEgC,KAAa;MACxC,OAAAmM,YAAY,CAAC;QACXnO,IAAI,EAAAA,IAAA;QACJgC,KAAK,EAAAA,KAAA;QACLqM,GAAG,EAAErO,IAAI,CAACqO,GAAG,GAAGrO,IAAI,CAACqO,GAAG,GAAGrM,KAAK;QAChCsM,QAAQ,EAAEjG,eAAgB,CAAC3B,OAAO,CAAC1E,KAAK,CAAC,KAAK,CAAC,CAAC;QAChDuM,YAAY,EAAE,SAAAA,CAAA;UAAM,OAAAzP,KAAI,CAAC2H,UAAU,CAACzG,IAAI,CAAC;QAArB,CAAqB;QACzCiE,QAAQ,EAAAA,QAAA;QACRe,YAAY,EAAElG,KAAI,CAACkG,YAAY;QAC/B+I,qBAAqB,EAAAA,qBAAA;QACrBG,qBAAqB,EAAAA;OACtB,CAAC;IAVF,CAUE,CACH;EACH,CAAC;EAESxP,UAAA,CAAAgK,SAAA,CAAA7H,UAAU,GAApB,UAAqBmB,KAAc;IACzB,IAAAZ,KAAK,GAAK,IAAI,CAAChB,KAAK,CAAAgB,KAAf;IAEb,IAAIA,KAAK,CAACL,MAAM,EAAE;MAChB;MACAiB,KAAK,GAAGA,KAAK,aAALA,KAAK,cAALA,KAAK,GAAIZ,KAAK,CAACL,MAAM,GAAG,CAAC;MACjC,IAAMyN,KAAK,GACT,IAAI,CAACxP,IAAI,CAACgE,OAAO,IAChB,IAAI,CAAChE,IAAI,CAACgE,OAAO,CAACyL,gBAAgB,CAAC,iCAAiC,CAAC,CACpEC,IAAI,CAACC,GAAG,CAAC3M,KAAM,EAAEZ,KAAK,CAACL,MAAM,GAAG,CAAC,CAAC,CACZ;MAC1B,IAAIyN,KAAK,EAAE;QACTA,KAAK,CAAC5I,KAAK,EAAE;;KAEhB,MAAM;MACL,IAAI,IAAI,CAAC1G,KAAK,CAAC8D,OAAO,EAAE;QACtB,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAAC4C,KAAK,EAAE;;;EAGhC,CAAC;EAESlH,UAAA,CAAAgK,SAAA,CAAA7D,kBAAkB,GAA5B;IACE,IAAI,IAAI,CAAC/E,eAAe,CAACC,iBAAiB,EAAE;MAC1C,IAAM6O,YAAY,GAAW,IAAI,CAAC1P,KAAK,CAAC8D,OAAO,GAAG,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAACrB,KAAK,GAAG,EAAE;MAC/E,IAAMkN,SAAS,GAAW,IAAI,CAACC,gBAAgB,CAAC,IAAI,CAAChP,eAAe,CAACC,iBAAiB,CAACC,IAAI,EAAE4O,YAAY,CAAC;MAC1G,IAAI,CAACnO,QAAQ,CAAC;QAAEJ,qBAAqB,EAAEwO;MAAS,CAAE,CAAC;;EAEvD,CAAC;EAESnQ,UAAA,CAAAgK,SAAA,CAAAP,iBAAiB,GAA3B;IACE,IAAI,CAAC1H,QAAQ,CAAC;MACZ4H,eAAe,EAAE,IAAI,CAAChG,SAAS,CAAC+G,kBAAkB;KACnD,CAAC;EACJ,CAAC;EAES1K,UAAA,CAAAgK,SAAA,CAAAhD,iBAAiB,GAA3B,UAA4B5E,WAAkB;;IAC5C,IAAMiO,mBAAmB,GAAG,CAAAzE,EAAA,OAAI,CAAC1K,KAAK,CAACqO,sBAAsB,cAAA3D,EAAA,uBAAAA,EAAA,CAAE0E,oBAAoB;IACnF,IAAI,CAAClP,eAAe,CAAC4F,iBAAiB,CAAC5E,WAAW,EAAE,CAAC,EAAEiO,mBAAmB,CAAC;IAC3E,IAAI,CAACxK,WAAW,EAAE;EACpB,CAAC;EAED;;;;EAIU7F,UAAA,CAAAgK,SAAA,CAAAf,iBAAiB,GAA3B;IACE,IAAMsH,uBAAuB,GAAG,IAAI,CAACrP,KAAK,CAACsP,yBAAyB,GAChE,IAAI,CAACtP,KAAK,CAACsP,yBAAyB;IACpC;IACA,IAAI,CAACtP,KAAK,CAAC+H,iBAAiB;IAEhC;IACA,IAAIsH,uBAAuB,EAAE;MAC3B,IAAMnO,WAAW,GAAGmO,uBAAuB,CAAC,IAAI,CAAC7O,KAAK,CAACgB,KAAK,CAAC;MAE7D,IAAI,CAACiG,qBAAqB,CAACvG,WAAW,CAAC;MAEvC,IAAI,CAACL,QAAQ,CAAC;QACZqB,yBAAyB,EAAE,IAAI;QAC/BpB,kBAAkB,EAAE,IAAI;QACxBmB,wBAAwB,EAAE;OAC3B,CAAC;;EAEN,CAAC;EAESnD,UAAA,CAAAgK,SAAA,CAAA9G,WAAW,GAArB,UAAsBuF,YAAoB;IACxC,IAAI,CAACS,8BAA8B,CAACT,YAAY,CAAC;EACnD,CAAC;EAESzI,UAAA,CAAAgK,SAAA,CAAArB,qBAAqB,GAA/B,UAAgCvG,WAAmC,EAAEqG,YAAqB;IAA1F,IAAArI,KAAA;;IACE;IACA;IACA;IACA,IAAI0G,KAAK,CAACC,OAAO,CAAC3E,WAAW,CAAC,EAAE;MAC9B,IAAI,CAACqO,sBAAsB,CAAChI,YAAY,EAAErG,WAAW,CAAC;KACvD,MAAM,IAAIA,WAAW,IAAKA,WAAgC,CAACN,IAAI,EAAE;MAChE,IAAI,CAACC,QAAQ,CAAC;QACZkN,kBAAkB,EAAE;OACrB,CAAC;MACF,IAAI,CAACyB,eAAe,EAAE;MAEtB;MACA,IAAI,CAACtP,eAAe,CAAC4F,iBAAiB,CAAC,EAAE,CAAC;MAE1C,IAAIyB,YAAY,KAAK3I,SAAS,EAAE;QAC9B,IAAI,CAACiC,QAAQ,CAAC;UACZC,kBAAkB,EAAE,IAAI,CAAC2O,mBAAmB;SAC7C,CAAC;OACH,MAAM;QACL,IAAI,CAAC5O,QAAQ,CAAC;UACZC,kBAAkB,EAChB,IAAI,CAACxB,KAAK,CAAC8D,OAAQ,IAAI,IAAI,CAAC9D,KAAK,CAAC8D,OAAQ,CAACqB,YAAY,MAAK,CAAAiG,EAAA,GAAApM,aAAa,CAAC,IAAI,CAAC4E,OAAO,CAAC,cAAAwH,EAAA,uBAAAA,EAAA,CAAEvH,aAAa;SACzG,CAAC;;MAGJ;MACA,IAAI,CAACxC,cAAc,GAAGO,WAAW;MACjCA,WAAW,CAACN,IAAI,CAAC,UAACmF,cAAmB;QACnC,IAAI7E,WAAW,KAAKhC,KAAI,CAACyB,cAAc,EAAE;UACvCzB,KAAI,CAACqQ,sBAAsB,CAAChI,YAAY,EAAExB,cAAc,CAAC;;MAE7D,CAAC,CAAC;;EAEN,CAAC;EAESjH,UAAA,CAAAgK,SAAA,CAAA4G,eAAe,GAAzB,UAA0BnI,YAAoB,EAAErG,WAAgB;IAAhE,IAAAhC,KAAA;IACE,IAAI,CAAC4G,iBAAiB,CAAC5E,WAAW,CAAC;IACnC,IAAI+N,SAAS,GAAuBrQ,SAAS;IAE7C,IAAI,IAAI,CAACsB,eAAe,CAACC,iBAAiB,EAAE;MAC1C8O,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAAC,IAAI,CAAChP,eAAe,CAACC,iBAAiB,CAACC,IAAI,EAAEmH,YAAY,CAAC;;IAG9F;IACA;IACA;IACA,IAAI,CAAC1G,QAAQ,CACX;MACEJ,qBAAqB,EAAEwO,SAAS;MAChCnO,kBAAkB,EAAE,IAAI,CAAC2O,mBAAmB;KAC7C,EACD;MAAM,OAAAvQ,KAAI,CAAC2B,QAAQ,CAAC;QAAEkN,kBAAkB,EAAE,KAAK;QAAEE,0BAA0B,EAAE;MAAK,CAAE,CAAC;IAA/E,CAA+E,CACtF;EACH,CAAC;EAESnP,UAAA,CAAAgK,SAAA,CAAA6G,QAAQ,GAAlB,UAAmBnO,KAAW;IAC5B,IAAI,IAAI,CAACxB,KAAK,CAAC2P,QAAQ,EAAE;MACtB,IAAI,CAAC3P,KAAK,CAAC2P,QAAgB,CAACnO,KAAK,CAAC;;EAEvC,CAAC;EAqUD;EACA;EACU1C,UAAA,CAAAgK,SAAA,CAAAxE,WAAW,GAArB,UAAsBzE,EAAoC;IACxD,IACG,IAAI,CAACW,KAAK,CAACgB,KAAK,CAACL,MAAM,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAAC8D,OAAO,IAC9C,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,IAAI,CAAC,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAACwM,eAAe,IAAI,IAAI,CAACtQ,KAAK,CAAC8D,OAAO,CAACyM,cAAc,KAAK,CAAE,EACtG;MACA,IAAI,IAAI,CAACpN,SAAS,CAACqN,gBAAgB,EAAE,GAAG,CAAC,EAAE;QACzC,IAAI,CAAC5I,WAAW,CAAC,IAAI,CAACzE,SAAS,CAACsN,YAAY,EAAE,CAAC;OAChD,MAAM;QACL,IAAI,CAAClJ,UAAU,CAAC,IAAI,CAACrG,KAAK,CAACgB,KAAK,CAAC,IAAI,CAAChB,KAAK,CAACgB,KAAK,CAACL,MAAM,GAAG,CAAC,CAAC,CAAC;;;EAGpE,CAAC;EAwBSrC,UAAA,CAAAgK,SAAA,CAAA6D,mBAAmB,GAA7B;;IACE,IAAI,IAAI,CAACnM,KAAK,CAACuN,kBAAkB,EAAE;MACjC,OAAOnP,SAAS;;IAGlB,IAAM8F,YAAY,GAAG,IAAI,CAACxE,eAAe,CAACwE,YAAY;IAEtD,IAAIA,YAAY,GAAG,CAAC,EAAE;MACpB;MACA;MACA,IAAI,CAAAgG,EAAA,OAAI,CAACnL,iBAAiB,CAAC6D,OAAO,cAAAsH,EAAA,uBAAAA,EAAA,CAAE7F,kBAAkB,EAAE,EAAE;QACxD,OAAO,oBAAoB;;MAG7B;MACA,IAAI,IAAI,CAAC3E,eAAe,CAACgB,WAAW,CAACC,MAAM,KAAK,CAAC,EAAE;QACjD,OAAO,oBAAoB;;MAG7B,OAAOvC,SAAS;KACjB,MAAM;MACL,OAAO,OAAA+H,MAAA,CAAOjC,YAAY,CAAE;;EAEhC,CAAC;EAED;EACU5F,UAAA,CAAAgK,SAAA,CAAAkH,mBAAmB,GAA7B,UAA8BC,wBAAgE;IAAhE,IAAAA,wBAAA;MAAAA,wBAAA,GAAmC1R,YAAY,CAAC+M,gBAAgB;IAAA;IAC5F,IAAM5G,YAAY,GAAG,IAAI,CAACxE,eAAe,CAACwE,YAAY;IACtD,IAAI,IAAI,CAAC1E,KAAK,CAACkQ,6BAA6B,EAAE;MAC5C,IAAMC,kBAAkB,GACtBzL,YAAY,GAAG,CAAC,CAAC,GAAG,IAAI,CAACxE,eAAe,CAACmG,oBAAoB,CAAC,IAAI,CAACnG,eAAe,CAACwE,YAAY,CAAC,GAAG9F,SAAS;MAC9G,IAAMwR,2BAA2B,GAAGD,kBAAkB,GAAGA,kBAAkB,CAACE,SAAS,GAAGzR,SAAS;MACjG;MACA,OACE9B,KAAA,CAAA6O,aAAA;QAAKD,EAAE,EAAE,IAAI,CAAC/J,QAAQ,CAACwG,uBAAuB;QAAEgC,SAAS,EAAE8F;MAAwB,GAChF,GAAAtJ,MAAA,CAAGyJ,2BAA2B,MAAG,CAC9B;;EAGZ,CAAC;EAEStR,UAAA,CAAAgK,SAAA,CAAAmD,iBAAiB,GAA3B,UAA4BqE,cAAsD;IAAtD,IAAAA,cAAA;MAAAA,cAAA,GAAyB/R,YAAY,CAAC+M,gBAAgB;IAAA;IACxE,IAAAZ,EAAA,GAA0C,IAAI,CAAC1K,KAAK,CAAAuQ,qBAAf;MAArCA,qBAAqB,GAAA7F,EAAA,cAAG,aAAa,GAAAA,EAAA;IAC7C,IAAI8F,eAAe,GAAG,EAAE;IAExB,IAAI,IAAI,CAAChQ,KAAK,CAACoG,gBAAgB,EAAE;MAC/B,IAAM6J,QAAQ,GAAG,IAAI,CAACvB,gBAAgB,CAAC,IAAI,CAAC1O,KAAK,CAACoG,gBAAgB,EAAE,EAAE,CAAC;MACvE4J,eAAe,GAAGrT,MAAM,CAACoT,qBAAqB,EAAEE,QAAQ,CAAC;;IAG3D,OACE3T,KAAA,CAAA6O,aAAA;MAAKxB,SAAS,EAAEmG,cAAc;MAAE5E,EAAE,EAAE,IAAI,CAAC/J,QAAQ,CAACwG,uBAAuB;MAAA,aAAY;IAAW;IAE5F;IACA,IAAI,CAAC6H,mBAAmB,CAACM,cAAc,CAAC,EAEzCE,eAAe,CACZ;EAEV,CAAC;EAED;EACA;EACQ1R,UAAA,CAAAgK,SAAA,CAAA2E,+BAA+B,GAAvC,UAAwC5N,EAAS;IAC/C,IAAI,IAAI,CAACF,sBAAsB,KAAKE,EAAE,CAAC6Q,IAAI,KAAK,QAAQ,IAAI7Q,EAAE,CAAC6Q,IAAI,KAAK,QAAQ,CAAC,EAAE;MACjF,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd,CAAC;EAED;EACQ5R,UAAA,CAAAgK,SAAA,CAAA0G,eAAe,GAAvB;IAAA,IAAAtQ,KAAA;IACE,IAAI,CAAC8H,MAAM,CAACC,UAAU,CAAC;MACrB,IAAI/H,KAAI,CAACsB,KAAK,CAACuN,kBAAkB,EAAE;QACjC7O,KAAI,CAAC2B,QAAQ,CAAC;UAAEoN,0BAA0B,EAAE;QAAI,CAAE,CAAC;;IAEvD,CAAC,EAAEzP,kBAAkB,CAAC;EACxB,CAAC;EAED;;;;EAIQM,UAAA,CAAAgK,SAAA,CAAAyG,sBAAsB,GAA9B,UAA+BhI,YAAgC,EAAExB,cAAmB;;IAClF,IAAIwB,YAAY,KAAK3I,SAAS,EAAE;MAC9B,IAAI,CAAC8Q,eAAe,CAACnI,YAAY,EAAExB,cAAc,CAAC;KACnD,MAAM;MACL,IAAMoJ,mBAAmB,GAAG,CAAAzE,EAAA,OAAI,CAAC1K,KAAK,CAACqO,sBAAsB,cAAA3D,EAAA,uBAAAA,EAAA,CAAE0E,oBAAoB;MACnF,IAAI,CAAClP,eAAe,CAAC4F,iBAAiB,CAACC,cAAc,EAAE,CAAC,CAAC,EAAEoJ,mBAAmB,CAAC;MAC/E,IAAI,IAAI,CAAC3O,KAAK,CAACuN,kBAAkB,EAAE;QACjC,IAAI,CAAClN,QAAQ,CAAC;UACZkN,kBAAkB,EAAE,KAAK;UACzBE,0BAA0B,EAAE;SAC7B,CAAC;;;EAGR,CAAC;EAEanP,UAAA,CAAAgK,SAAA,CAAA6H,gBAAgB,GAA9B,UAA+BnP,KAAU;;;;;;YACvC,IAAI,IAAI,CAACxB,KAAK,CAAC2K,YAAY,EAAE;cAC3B,sBAAO,IAAI,CAAC3K,KAAK,CAAC2K,YAAY;;iBAE5B,IAAI,CAAC3K,KAAK,CAAC4Q,iBAAiB,EAA5B;;;;YAEMjG,YAAY,GAAG,IAAI,CAAC3K,KAAK,CAAC4Q,iBAAiB,CAACpP,KAAK,CAAC;iBACpDmJ,YAAY,EAAZ;iBACGA,YAAkD,CAAC/J,IAAI,EAAxD;YACK,qBAAO+J,YAAkD;;YAAhE,sBAAOD,EAAA,CAAAmG,IAAA,EAAyD;;YAEhE,sBAAOlG,YAAoC;;;;YAG7C,sBAAO/L,SAAS;;;;;;;;;;;GAMvB;EAEOE,UAAA,CAAAgK,SAAA,CAAAG,mBAAmB,GAA3B,UAA4BzH,KAAU;IAAtC,IAAAtC,KAAA;IACE,IAAI4R,eAAiD;IACrD,IAAI,CAACH,gBAAgB,CAACnP,KAAK,CAAC,CACzBZ,IAAI,CAAC,UAAA+J,YAAY;MAChBmG,eAAe,GAAGnG,YAAY;IAChC,CAAC,CAAC,CACDoG,KAAK,CAAC;MACL;IAAA,CACD,CAAC,CACDC,OAAO,CAAC;MACP,IAAI9R,KAAI,CAACQ,UAAU,IAAIoR,eAAe,KAAK5R,KAAI,CAACsB,KAAK,CAACmK,YAAY,EAAE;QAClEzL,KAAI,CAAC2B,QAAQ,CAAC;UAAE8J,YAAY,EAAEmG;QAAe,CAAE,CAAC;;IAEpD,CAAC,CAAC;EACN,CAAC;EAED;;;;EAIQhS,UAAA,CAAAgK,SAAA,CAAAvD,oBAAoB,GAA5B,UAA6B/D,KAAU;IAAvC,IAAAtC,KAAA;IACE,IAAI,IAAI,CAACc,KAAK,CAAC4B,aAAa,EAAE;MAC5B;MACA,IAAI,CAAC+N,QAAQ,CAACnO,KAAK,CAAC;KACrB,MAAM;MACL,IAAI,CAACX,QAAQ,CAAC;QAAEW,KAAK,EAAAA;MAAA,CAAE,EAAE;QACvBtC,KAAI,CAAC+J,mBAAmB,CAACzH,KAAK,CAAC;QAC/BtC,KAAI,CAAC+R,uBAAuB,CAACzP,KAAK,CAAC;MACrC,CAAC,CAAC;;EAEN,CAAC;EAEO1C,UAAA,CAAAgK,SAAA,CAAAmI,uBAAuB,GAA/B,UAAgCzP,KAAW;IACzC,IAAI,CAACmO,QAAQ,CAACnO,KAAK,CAAC;EACtB,CAAC;EAED;;;;;EAKQ1C,UAAA,CAAAgK,SAAA,CAAA2G,mBAAmB,GAA3B;;IACE,IAAMyB,qBAAqB,GACzB,IAAI,CAAC5R,KAAK,CAAC8D,OAAO,KAAKxE,SAAS,IAChC,IAAI,CAACU,KAAK,CAAC8D,OAAO,KAAK,IAAI,IAC3B,IAAI,CAAC9D,KAAK,CAAC8D,OAAO,CAACqB,YAAY,MAAK,CAAAiG,EAAA,GAAApM,aAAa,CAAC,IAAI,CAAC4E,OAAO,CAAC,cAAAwH,EAAA,uBAAAA,EAAA,CAAEvH,aAAa,KAC9E,IAAI,CAAC7D,KAAK,CAAC8D,OAAO,CAACrB,KAAK,KAAK,EAAE;IAEjC,OAAOmP,qBAAqB;EAC9B,CAAC;EA0BOpS,UAAA,CAAAgK,SAAA,CAAAoG,gBAAgB,GAAxB,UAAyB9O,IAAO,EAAE4O,YAAqB;IACrD,IAAI,IAAI,CAAChP,KAAK,CAACmR,eAAe,EAAE;MAC9B,OAAQ,IAAI,CAACnR,KAAK,CAACmR,eAAuB,CAAC/Q,IAAI,EAAE4O,YAAY,CAAC;KAC/D,MAAM;MACL,OAAO,EAAE;;EAEb,CAAC;EA3iCalQ,UAAA,CAAAsS,WAAW,GAAG/S,aAAa;EAkkC3C,OAAAS,UAAC;CAAA,CArkCShC,KAAK,CAACuU,SAAS;SADZvS,UAAU;AAwkCvB,IAAAwS,mBAAA,0BAAAvS,MAAA;EAAsFC,SAAA,CAAAsS,mBAAA,EAAAvS,MAAA;EAAtF,SAAAuS,oBAAA;;EA8FA;EA7FSA,mBAAA,CAAAxI,SAAA,CAAAkB,MAAM,GAAb;;IACQ,IAAAC,EAAA,GAA8C,IAAI,CAACzJ,KAAK;MAAtDC,qBAAqB,GAAAwJ,EAAA,CAAAxJ,qBAAA;MAAEkC,SAAS,GAAAsH,EAAA,CAAAtH,SAAA;MAAEnB,KAAK,GAAAyI,EAAA,CAAAzI,KAAe;IACxD,IAAA0I,EAAA,GAAiG,IAAI,CAAClK,KAAK;MAAzGmK,SAAS,GAAAD,EAAA,CAAAC,SAAA;MAAEtH,UAAU,GAAAqH,EAAA,CAAArH,UAAA;MAAEwB,QAAQ,GAAA6F,EAAA,CAAA7F,QAAA;MAAE+F,kBAAkB,GAAAF,EAAA,CAAAE,kBAAA;MAAEC,EAAA,GAAAH,EAAA,CAAAI,aAAsB;MAAtBA,aAAa,GAAAD,EAAA,cAAG,MAAM,GAAAA,EAAA;MAAEE,KAAK,GAAAL,EAAA,CAAAK,KAAA;MAAEC,MAAM,GAAAN,EAAA,CAAAM,MAAe;IAEjH,IAAM1J,kBAAkB,GAAG,CAAC,CAAC,IAAI,CAACN,KAAK,CAACM,kBAAkB;IAE1D,IAAM2J,oBAAoB,GAAuB3J,kBAAkB,GAAG,IAAI,CAACa,QAAQ,CAACyG,cAAc,GAAGxJ,SAAS;IAC9G,IAAM6C,QAAQ,GAAG,CAAC,EAAE,CAAAiJ,EAAA,OAAI,CAAClK,KAAK,CAACmK,YAAY,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAC1K,KAAK,CAAC2K,YAAY,CAAC;IACvE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAMC,UAAU,GAAmDJ,MAAM,GACrE/L,aAAa,CAAC+L,MAAM,EAAE;MACpBD,KAAK,EAAAA,KAAA;MACLJ,SAAS,EAAAA,SAAA;MACTxH,SAAS,EAAAA,SAAA;MACT0B,QAAQ,EAAAA,QAAA;MACRwG,eAAe,EAAEpJ,QAAQ;MACzBqJ,cAAc,EAAEjI,UAAU,IAAIA,UAAU,CAACsH;KAC1C,CAAC,GACF;MACE/K,IAAI,EAAEnC,GAAG,CAAC,eAAe,EAAEsB,YAAY,CAACgT,MAAM,EAAEpH,SAAS,GAAGA,SAAS,GAAG,EAAE,CAAC;MAC3EtI,KAAK,EAAE,qBAAqB;MAC5BkJ,IAAI,EAAE9N,GAAG,CACP,oBAAoB,EACpBsB,YAAY,CAACyM,UAAU,EACvB,IAAI,CAACxK,KAAK,CAACmC,SAAS,IAAIpE,YAAY,CAAC0M,YAAY,EACjD5G,QAAQ,IAAI9F,YAAY,CAACiT,aAAa,CACvC;MACDtG,YAAY,EAAE3M,YAAY,CAAC4M,WAAW;MACtC7L,KAAK,EAAErC,GAAG,CAAC,qBAAqB,EAAEsB,YAAY,CAAC6M,WAAW,EAAEvI,UAAU,IAAIA,UAAU,CAACsH,SAAS,CAAC;MAC/FkB,gBAAgB,EAAE9M,YAAY,CAAC+M;KAChC;IAEL,IAAMC,UAAU,GAAG,IAAI,CAACvL,KAAK,CAAC,YAAY,CAAC,KAAI6C,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAG,YAAY,CAAC;IACzE,IAAM2I,OAAO,GAAG,CAAAC,EAAA,GAAA5I,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE6I,EAAE,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI,CAAC9J,QAAQ,CAAC0G,QAAQ;IAExD,OACEvL,KAAA,CAAA6O,aAAA;MAAKC,GAAG,EAAE,IAAI,CAACxM,IAAI;MAAE4D,MAAM,EAAE,IAAI,CAACA,MAAM;MAAEF,OAAO,EAAE,IAAI,CAACA;IAAO,GAC5D,IAAI,CAAC+I,WAAW,CAACL,OAAO,EAAE,CAAAM,EAAA,GAAAlB,UAAU,CAACmB,kBAAkB,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,KAAK,CAAC,EAChElP,KAAA,CAAA6O,aAAA;MAAKxB,SAAS,EAAES,UAAU,CAACxL,IAAI;MAAEoE,SAAS,EAAE,IAAI,CAACA;IAAS,GACvD,IAAI,CAACyI,iBAAiB,CAACrB,UAAU,CAACS,gBAAgB,CAAC,EACpDvO,KAAA,CAAA6O,aAAA;MAAMD,EAAE,EAAE,GAAA/E,MAAA,CAAG,IAAI,CAAChF,QAAQ,CAACC,aAAa,WAAQ;MAAEsK,MAAM;IAAA,GACrD9B,kBAAkB,IAAImB,UAAU,CAC5B,EACPzO,KAAA,CAAA6O,aAAA;MAAKxB,SAAS,EAAES,UAAU,CAACG,IAAI;MAAA,aAAaN;IAAoB,GAC9D3N,KAAA,CAAA6O,aAAA,CAACzN,QAAQ,EAAAqO,QAAA,KACF1J,UAAkB;MACvBsH,SAAS,EAAES,UAAU,CAACtL,KAAK;MAC3BmN,YAAY,EAAE,IAAI,CAACnN,KAAK;MACxBwD,OAAO,EAAE,IAAI,CAACN,YAAY;MAC1BQ,MAAM,EAAE,IAAI,CAACD,WAAW;MACxBO,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBoJ,kBAAkB,EAAE,IAAI,CAAC5K,aAAa;MACtCrB,qBAAqB,EAAEA,qBAAqB;MAAA,yBACrBK,kBAAkB,GAAG,IAAI,CAAC6L,mBAAmB,EAAE,GAAG/N,SAAS;MAAA,iBACnE6L,oBAAoB;MAAA,iBACpB3J,kBAAkB;MAAA,iBACnB,SAAS;MAAA,cACXyK,UAAU;MAAA,oBACJ,IAAI,CAAChK,eAAe,CAACC,KAAK,EAAEC,QAAQ,CAAC;MACvD4K,IAAI,EAAC,UAAU;MACfX,EAAE,EAAEF,OAAO;MACXnH,QAAQ,EAAEA,QAAQ;MAClBvC,aAAa,EAAE,IAAI,CAAC9B,KAAK,CAAC8B;IAAa,GACvC,CACE,CACF,EACL,IAAI,CAAC+K,iBAAiB,EAAE,EACzB/P,KAAA,CAAA6O,aAAA,CAACjO,aAAa;MAAC+E,SAAS,EAAE,IAAI,CAACA,SAAS;MAAE0J,aAAa,EAAExO,aAAa,CAAC8T;IAAM,GAC3E3U,KAAA,CAAA6O,aAAA;MACED,EAAE,EAAE,IAAI,CAAC/J,QAAQ,CAACC,aAAa;MAC/BuI,SAAS,EAAC,6BAA6B,CAAC;MAAA;MACxCkC,IAAI,EAAE/B,aAAa;MAAA,mBACF,GAAA3D,MAAA,CAAG,IAAI,CAAChF,QAAQ,CAACC,aAAa;IAAQ,GAEtD,IAAI,CAAC0K,WAAW,EAAE,CACf,CACQ,EACf,IAAI,CAACM,WAAW,CAAChC,UAAU,CAAC/I,KAAK,CAAC,CAC/B;EAEV,CAAC;EAESyP,mBAAA,CAAAxI,SAAA,CAAAxE,WAAW,GAArB,UAAsBzE,EAAoC;IACxD;EAAA,CACD;EACH,OAAAyR,mBAAC;AAAD,CAAC,CA9FqFxS,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}