{"ast":null,"code":"import { getDocument } from '@fluentui/utilities';\nimport { MAX_COLOR_ALPHA } from './consts';\nimport { hsl2rgb } from './hsl2rgb';\n/**\n * Converts a valid CSS color string to an RGB color.\n * Note that hex colors *must* be prefixed with # to be considered valid.\n * Alpha in returned color defaults to 100.\n * Four and eight digit hex values (with alpha) are supported if the current browser supports them.\n */\nexport function cssColor(color, doc) {\n  if (!color) {\n    return undefined;\n  }\n  var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();\n  // Need to check the following valid color formats: RGB(A), HSL(A), hex, named color\n  // First check for well formatted RGB(A), HSL(A), and hex formats at the start.\n  // This is for perf (no creating an element) and catches the intentional \"transparent\" color\n  //   case early on.\n  var easyColor = _rgba(color) || _hex6(color) || _hex3(color) || _hsla(color);\n  if (easyColor) {\n    return easyColor;\n  }\n  // if the above fails, do the more expensive catch-all\n  return _browserCompute(color, theDoc);\n}\n/**\n * Uses the browser's getComputedStyle() to determine what the passed-in color is.\n * This assumes _rgba, _hex6, _hex3, and _hsla have already been tried and all failed.\n * This works by attaching an element to the DOM, which may fail in server-side rendering\n *   or with headless browsers.\n */\nfunction _browserCompute(str, doc) {\n  var _a;\n  if (typeof doc === 'undefined') {\n    // don't throw an error when used server-side\n    return undefined;\n  }\n  var elem = doc.createElement('div');\n  elem.style.backgroundColor = str;\n  // This element must be attached to the DOM for getComputedStyle() to have a value\n  elem.style.position = 'absolute';\n  elem.style.top = '-9999px';\n  elem.style.left = '-9999px';\n  elem.style.height = '1px';\n  elem.style.width = '1px';\n  doc.body.appendChild(elem);\n  var eComputedStyle = (_a = doc.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(elem);\n  var computedColor = eComputedStyle && eComputedStyle.backgroundColor;\n  doc.body.removeChild(elem);\n  // computedColor is always an RGB(A) string, except for invalid colors in IE/Edge which return 'transparent'\n  // browsers return one of these if the color string is invalid,\n  // so need to differentiate between an actual error and intentionally passing in this color\n  if (computedColor === 'rgba(0, 0, 0, 0)' || computedColor === 'transparent') {\n    switch (str.trim()) {\n      // RGB and HSL were already checked at the start of the function\n      case 'transparent':\n      case '#0000':\n      case '#00000000':\n        return {\n          r: 0,\n          g: 0,\n          b: 0,\n          a: 0\n        };\n    }\n    return undefined;\n  }\n  return _rgba(computedColor);\n}\n/**\n * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _rgba(str) {\n  if (!str) {\n    return undefined;\n  }\n  var match = str.match(/^rgb(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    var hasAlpha = !!match[1];\n    var expectedPartCount = hasAlpha ? 4 : 3;\n    var parts = match[2].split(/ *, */).map(Number);\n    if (parts.length === expectedPartCount) {\n      return {\n        r: parts[0],\n        g: parts[1],\n        b: parts[2],\n        a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA\n      };\n    }\n  }\n}\n/**\n * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _hsla(str) {\n  var match = str.match(/^hsl(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    var hasAlpha = !!match[1];\n    var expectedPartCount = hasAlpha ? 4 : 3;\n    var parts = match[2].split(/ *, */).map(Number);\n    if (parts.length === expectedPartCount) {\n      var rgba = hsl2rgb(parts[0], parts[1], parts[2]);\n      rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;\n      return rgba;\n    }\n  }\n}\n/**\n * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex6(str) {\n  if (str[0] === '#' && str.length === 7 && /^#[\\da-fA-F]{6}$/.test(str)) {\n    return {\n      r: parseInt(str.slice(1, 3), 16),\n      g: parseInt(str.slice(3, 5), 16),\n      b: parseInt(str.slice(5, 7), 16),\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}\n/**\n * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex3(str) {\n  if (str[0] === '#' && str.length === 4 && /^#[\\da-fA-F]{3}$/.test(str)) {\n    return {\n      r: parseInt(str[1] + str[1], 16),\n      g: parseInt(str[2] + str[2], 16),\n      b: parseInt(str[3] + str[3], 16),\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}","map":{"version":3,"names":["getDocument","MAX_COLOR_ALPHA","hsl2rgb","cssColor","color","doc","undefined","theDoc","easyColor","_rgba","_hex6","_hex3","_hsla","_browserCompute","str","elem","createElement","style","backgroundColor","position","top","left","height","width","body","appendChild","eComputedStyle","_a","defaultView","getComputedStyle","computedColor","removeChild","trim","r","g","b","a","match","hasAlpha","expectedPartCount","parts","split","map","Number","length","rgba","test","parseInt","slice"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\utilities\\src\\utilities\\color\\cssColor.ts"],"sourcesContent":["import { getDocument } from '@fluentui/utilities';\nimport { MAX_COLOR_ALPHA } from './consts';\nimport { hsl2rgb } from './hsl2rgb';\nimport type { IRGB } from './interfaces';\n\n/**\n * Converts a valid CSS color string to an RGB color.\n * Note that hex colors *must* be prefixed with # to be considered valid.\n * Alpha in returned color defaults to 100.\n * Four and eight digit hex values (with alpha) are supported if the current browser supports them.\n */\nexport function cssColor(color?: string, doc?: Document): IRGB | undefined {\n  if (!color) {\n    return undefined;\n  }\n\n  const theDoc = doc ?? getDocument()!;\n\n  // Need to check the following valid color formats: RGB(A), HSL(A), hex, named color\n\n  // First check for well formatted RGB(A), HSL(A), and hex formats at the start.\n  // This is for perf (no creating an element) and catches the intentional \"transparent\" color\n  //   case early on.\n  const easyColor: IRGB | undefined = _rgba(color) || _hex6(color) || _hex3(color) || _hsla(color);\n  if (easyColor) {\n    return easyColor;\n  }\n\n  // if the above fails, do the more expensive catch-all\n  return _browserCompute(color, theDoc);\n}\n\n/**\n * Uses the browser's getComputedStyle() to determine what the passed-in color is.\n * This assumes _rgba, _hex6, _hex3, and _hsla have already been tried and all failed.\n * This works by attaching an element to the DOM, which may fail in server-side rendering\n *   or with headless browsers.\n */\nfunction _browserCompute(str: string, doc: Document): IRGB | undefined {\n  if (typeof doc === 'undefined') {\n    // don't throw an error when used server-side\n    return undefined;\n  }\n  const elem = doc.createElement('div');\n  elem.style.backgroundColor = str;\n  // This element must be attached to the DOM for getComputedStyle() to have a value\n  elem.style.position = 'absolute';\n  elem.style.top = '-9999px';\n  elem.style.left = '-9999px';\n  elem.style.height = '1px';\n  elem.style.width = '1px';\n  doc.body.appendChild(elem);\n  const eComputedStyle = doc.defaultView?.getComputedStyle(elem);\n  const computedColor = eComputedStyle && eComputedStyle.backgroundColor;\n  doc.body.removeChild(elem);\n  // computedColor is always an RGB(A) string, except for invalid colors in IE/Edge which return 'transparent'\n\n  // browsers return one of these if the color string is invalid,\n  // so need to differentiate between an actual error and intentionally passing in this color\n  if (computedColor === 'rgba(0, 0, 0, 0)' || computedColor === 'transparent') {\n    switch (str.trim()) {\n      // RGB and HSL were already checked at the start of the function\n      case 'transparent':\n      case '#0000':\n      case '#00000000':\n        return { r: 0, g: 0, b: 0, a: 0 };\n    }\n    return undefined;\n  }\n\n  return _rgba(computedColor);\n}\n\n/**\n * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _rgba(str?: string | null): IRGB | undefined {\n  if (!str) {\n    return undefined;\n  }\n\n  const match = str.match(/^rgb(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    const hasAlpha = !!match[1];\n    const expectedPartCount = hasAlpha ? 4 : 3;\n    const parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      return {\n        r: parts[0],\n        g: parts[1],\n        b: parts[2],\n        a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA,\n      };\n    }\n  }\n}\n\n/**\n * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _hsla(str: string): IRGB | undefined {\n  const match = str.match(/^hsl(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    const hasAlpha = !!match[1];\n    const expectedPartCount = hasAlpha ? 4 : 3;\n    const parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      const rgba = hsl2rgb(parts[0], parts[1], parts[2]);\n      rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;\n      return rgba;\n    }\n  }\n}\n\n/**\n * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex6(str: string): IRGB | undefined {\n  if (str[0] === '#' && str.length === 7 && /^#[\\da-fA-F]{6}$/.test(str)) {\n    return {\n      r: parseInt(str.slice(1, 3), 16),\n      g: parseInt(str.slice(3, 5), 16),\n      b: parseInt(str.slice(5, 7), 16),\n      a: MAX_COLOR_ALPHA,\n    };\n  }\n}\n\n/**\n * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex3(str: string): IRGB | undefined {\n  if (str[0] === '#' && str.length === 4 && /^#[\\da-fA-F]{3}$/.test(str)) {\n    return {\n      r: parseInt(str[1] + str[1], 16),\n      g: parseInt(str[2] + str[2], 16),\n      b: parseInt(str[3] + str[3], 16),\n      a: MAX_COLOR_ALPHA,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}