{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { GLOBAL_STYLESHEET_KEY, SHADOW_DOM_STYLESHEET_SETTING } from './shadowConfig';\nexport var InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0,\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1,\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2\n};\nexport var STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nvar REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\nvar _global = {};\n// Grab window.\ntry {\n  // Why the cast?\n  // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global\n  // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion\n  _global = window || {};\n} catch (_a) {\n  /* leave as blank object */\n}\nvar _stylesheet;\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nvar Stylesheet = /** @class */function () {\n  function Stylesheet(config, serializedStylesheet) {\n    var _a, _b, _c, _d, _e, _f;\n    this._rules = [];\n    this._preservedRules = [];\n    this._counter = 0;\n    this._keyToClassName = {};\n    this._onInsertRuleCallbacks = [];\n    this._onResetCallbacks = [];\n    this._classNameToArgs = {};\n    // If there is no document we won't have an element to inject into.\n    this._config = __assign({\n      injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined\n    }, config);\n    this._classNameToArgs = (_a = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a !== void 0 ? _a : this._classNameToArgs;\n    this._counter = (_b = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b !== void 0 ? _b : this._counter;\n    this._keyToClassName = (_d = (_c = this._config.classNameCache) !== null && _c !== void 0 ? _c : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d !== void 0 ? _d : this._keyToClassName;\n    this._preservedRules = (_e = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e !== void 0 ? _e : this._preservedRules;\n    this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;\n  }\n  /**\n   * Gets the singleton instance.\n   */\n  Stylesheet.getInstance = function (shadowConfig) {\n    _stylesheet = _global[STYLESHEET_SETTING];\n    if (_global[SHADOW_DOM_STYLESHEET_SETTING]) {\n      return _global[SHADOW_DOM_STYLESHEET_SETTING].getInstance(shadowConfig);\n    }\n    if (!_stylesheet || _stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document) {\n      var fabricConfig = (_global === null || _global === void 0 ? void 0 : _global.FabricConfig) || {};\n      var stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n      _stylesheet = stylesheet;\n      _global[STYLESHEET_SETTING] = stylesheet;\n    }\n    return _stylesheet;\n  };\n  /**\n   * Serializes the Stylesheet instance into a format which allows rehydration on creation.\n   * @returns string representation of `ISerializedStylesheet` interface.\n   */\n  Stylesheet.prototype.serialize = function () {\n    return JSON.stringify({\n      classNameToArgs: this._classNameToArgs,\n      counter: this._counter,\n      keyToClassName: this._keyToClassName,\n      preservedRules: this._preservedRules,\n      rules: this._rules\n    });\n  };\n  /**\n   * Configures the stylesheet.\n   */\n  Stylesheet.prototype.setConfig = function (config) {\n    this._config = __assign(__assign({}, this._config), config);\n  };\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   * @returns function which when called un-registers provided callback.\n   */\n  Stylesheet.prototype.onReset = function (callback) {\n    var _this = this;\n    this._onResetCallbacks.push(callback);\n    return function () {\n      _this._onResetCallbacks = _this._onResetCallbacks.filter(function (cb) {\n        return cb !== callback;\n      });\n    };\n  };\n  /**\n   * Configures an insert rule callback.\n   *\n   * @param callback - A callback which will be called when a rule is inserted.\n   * @returns function which when called un-registers provided callback.\n   */\n  Stylesheet.prototype.onInsertRule = function (callback) {\n    var _this = this;\n    this._onInsertRuleCallbacks.push(callback);\n    return function () {\n      _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function (cb) {\n        return cb !== callback;\n      });\n    };\n  };\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n  Stylesheet.prototype.getClassName = function (displayName) {\n    var namespace = this._config.namespace;\n    var prefix = displayName || this._config.defaultPrefix;\n    return \"\".concat(namespace ? namespace + '-' : '').concat(prefix, \"-\").concat(this._counter++);\n  };\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n  Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {\n    this._keyToClassName[this._getCacheKey(key)] = className;\n    this._classNameToArgs[className] = {\n      args: args,\n      rules: rules\n    };\n  };\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n  Stylesheet.prototype.classNameFromKey = function (key) {\n    return this._keyToClassName[this._getCacheKey(key)];\n  };\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n  Stylesheet.prototype.getClassNameCache = function () {\n    return this._keyToClassName;\n  };\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  Stylesheet.prototype.argsFromClassName = function (className) {\n    var entry = this._classNameToArgs[className];\n    return entry && entry.args;\n  };\n  /**\n   * Gets the rules associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  Stylesheet.prototype.insertedRulesFromClassName = function (className) {\n    var entry = this._classNameToArgs[className];\n    return entry && entry.rules;\n  };\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n  Stylesheet.prototype.insertRule = function (rule, preserve, stylesheetKey) {\n    if (stylesheetKey === void 0) {\n      stylesheetKey = GLOBAL_STYLESHEET_KEY;\n    }\n    var injectionMode = this._config.injectionMode;\n    var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n    if (element) {\n      switch (injectionMode) {\n        case InjectionMode.insertNode:\n          this._insertRuleIntoSheet(element.sheet, rule);\n          break;\n        case InjectionMode.appendChild:\n          element.appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._config.onInsertRule) {\n      // eslint-disable-next-line deprecation/deprecation\n      this._config.onInsertRule(rule);\n    }\n    this._onInsertRuleCallbacks.forEach(function (callback) {\n      return callback({\n        key: stylesheetKey,\n        sheet: element ? element.sheet : undefined,\n        rule: rule\n      });\n    });\n  };\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n  Stylesheet.prototype.getRules = function (includePreservedRules) {\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');\n  };\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n  Stylesheet.prototype.reset = function () {\n    this._rules = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n    this._onResetCallbacks.forEach(function (callback) {\n      return callback();\n    });\n  };\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n  Stylesheet.prototype.resetKeys = function () {\n    this._keyToClassName = {};\n  };\n  Stylesheet.prototype._createStyleElement = function () {\n    var _a;\n    var doc = ((_a = this._config.window) === null || _a === void 0 ? void 0 : _a.document) || document;\n    var head = doc.head;\n    var styleElement = doc.createElement('style');\n    var nodeToInsertBefore = null;\n    styleElement.setAttribute('data-merge-styles', 'true');\n    var cspSettings = this._config.cspSettings;\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      nodeToInsertBefore = this._lastStyleElement.nextElementSibling;\n    } else {\n      var placeholderStyleTag = this._findPlaceholderStyleTag();\n      if (placeholderStyleTag) {\n        nodeToInsertBefore = placeholderStyleTag.nextElementSibling;\n      } else {\n        nodeToInsertBefore = head.childNodes[0];\n      }\n    }\n    head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);\n    this._lastStyleElement = styleElement;\n    return styleElement;\n  };\n  Stylesheet.prototype._insertRuleIntoSheet = function (sheet, rule) {\n    if (!sheet) {\n      return false;\n    }\n    try {\n      sheet.insertRule(rule, sheet.cssRules.length);\n      return true;\n    } catch (e) {\n      // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n      // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n      // which could be slower and bulkier.\n    }\n    return false;\n  };\n  Stylesheet.prototype._getCacheKey = function (key) {\n    return key;\n  };\n  Stylesheet.prototype._getStyleElement = function () {\n    var _this = this;\n    if (!this._styleElement) {\n      this._styleElement = this._createStyleElement();\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        var win = this._config.window || window;\n        win.requestAnimationFrame(function () {\n          _this._styleElement = undefined;\n        });\n      }\n    }\n    return this._styleElement;\n  };\n  Stylesheet.prototype._findPlaceholderStyleTag = function () {\n    var head = document.head;\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n    return null;\n  };\n  return Stylesheet;\n}();\nexport { Stylesheet };","map":{"version":3,"names":["GLOBAL_STYLESHEET_KEY","SHADOW_DOM_STYLESHEET_SETTING","InjectionMode","none","insertNode","appendChild","STYLESHEET_SETTING","REUSE_STYLE_NODE","navigator","test","userAgent","_global","window","_a","_stylesheet","Stylesheet","config","serializedStylesheet","_rules","_preservedRules","_counter","_keyToClassName","_onInsertRuleCallbacks","_onResetCallbacks","_classNameToArgs","_config","__assign","injectionMode","document","defaultPrefix","namespace","undefined","cspSettings","classNameToArgs","_b","counter","_d","_c","classNameCache","keyToClassName","_e","preservedRules","_f","rules","getInstance","shadowConfig","_lastStyleElement","ownerDocument","fabricConfig","FabricConfig","stylesheet","mergeStyles","prototype","serialize","JSON","stringify","setConfig","onReset","callback","_this","push","filter","cb","onInsertRule","getClassName","displayName","prefix","concat","cacheClassName","className","key","args","_getCacheKey","classNameFromKey","getClassNameCache","argsFromClassName","entry","insertedRulesFromClassName","insertRule","rule","preserve","stylesheetKey","element","_getStyleElement","_insertRuleIntoSheet","sheet","createTextNode","forEach","getRules","includePreservedRules","join","reset","resetKeys","_createStyleElement","doc","head","styleElement","createElement","nodeToInsertBefore","setAttribute","nonce","nextElementSibling","placeholderStyleTag","_findPlaceholderStyleTag","childNodes","insertBefore","contains","cssRules","length","e","_styleElement","win","requestAnimationFrame","querySelector"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\merge-styles\\src\\Stylesheet.ts"],"sourcesContent":["/* eslint no-restricted-globals: 0 */\n// globals in stylesheets will be addressed as part of shadow DOM work.\n// See: https://github.com/microsoft/fluentui/issues/28058\nimport { IStyle } from './IStyle';\nimport { GLOBAL_STYLESHEET_KEY, SHADOW_DOM_STYLESHEET_SETTING } from './shadowConfig';\nimport type { ShadowConfig } from './shadowConfig';\n\nexport const InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0 as 0,\n\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1 as 1,\n\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2 as 2,\n};\n\nexport type InjectionMode = (typeof InjectionMode)[keyof typeof InjectionMode];\n\n/**\n * CSP settings for the stylesheet\n */\nexport interface ICSPSettings {\n  /**\n   * Nonce to inject into script tag\n   */\n  nonce?: string;\n}\n\n/**\n * Stylesheet config.\n *\n * @public\n */\nexport interface IStyleSheetConfig {\n  /**\n   * Injection mode for how rules are inserted.\n   */\n  injectionMode?: InjectionMode;\n\n  /**\n   * Default 'displayName' to use for a className.\n   * @defaultvalue 'css'\n   */\n  defaultPrefix?: string;\n\n  /**\n   * Defines the default direction of rules for auto-rtlifying things.\n   * While typically this is represented as a DIR attribute in the markup,\n   * the DIR is not enough to control whether padding goes on the left or\n   * right. Use this to set the default direction when rules are registered.\n   */\n  rtl?: boolean;\n\n  /**\n   * Default 'namespace' to attach before the className.\n   */\n  namespace?: string;\n\n  /**\n   * CSP settings\n   */\n  cspSettings?: ICSPSettings;\n\n  /**\n   * Callback executed when a rule is inserted.\n   * @deprecated Use `Stylesheet.onInsertRule` instead.\n   */\n  onInsertRule?: (rule: string) => void;\n\n  /**\n   * Initial value for classnames cache. Key is serialized css rules associated with a classname.\n   */\n  classNameCache?: { [key: string]: string };\n\n  window?: Window;\n\n  inShadow?: boolean;\n\n  stylesheetKey?: string;\n}\n\n/**\n * Representation of Stylesheet used for rehydration.\n */\nexport interface ISerializedStylesheet {\n  classNameToArgs: Stylesheet['_classNameToArgs'];\n  counter: Stylesheet['_counter'];\n  keyToClassName: Stylesheet['_keyToClassName'];\n  preservedRules: Stylesheet['_preservedRules'];\n  rules: Stylesheet['_rules'];\n}\n\nexport const STYLESHEET_SETTING = '__stylesheet__';\n\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nconst REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  interface Document {\n    adoptedStyleSheets: CSSStyleSheet[];\n  }\n}\n\nexport type WindowWithMergeStyles = (Window | {}) & {\n  [STYLESHEET_SETTING]?: Stylesheet;\n  [SHADOW_DOM_STYLESHEET_SETTING]?: typeof Stylesheet;\n  FabricConfig?: {\n    mergeStyles?: IStyleSheetConfig;\n    serializedStylesheet?: ISerializedStylesheet;\n  };\n};\n\nlet _global: WindowWithMergeStyles = {};\n\n// Grab window.\ntry {\n  // Why the cast?\n  // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global\n  // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion\n  _global = (window || {}) as WindowWithMergeStyles;\n} catch {\n  /* leave as blank object */\n}\n\nlet _stylesheet: Stylesheet | undefined;\n\nexport type ExtendedCSSStyleSheet = CSSStyleSheet & {\n  bucketName: string;\n  metadata: Record<string, unknown>;\n};\n\ntype InsertRuleArgs = {\n  key?: string;\n  sheet?: ExtendedCSSStyleSheet | null;\n  rule?: string;\n};\n\nexport type InsertRuleCallback = ({ key, sheet, rule }: InsertRuleArgs) => void;\n\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nexport class Stylesheet {\n  protected _lastStyleElement?: HTMLStyleElement;\n  protected _config: IStyleSheetConfig;\n\n  private _styleElement?: HTMLStyleElement;\n\n  private _rules: string[] = [];\n  private _preservedRules: string[] = [];\n  private _counter = 0;\n  private _keyToClassName: { [key: string]: string } = {};\n  private _onInsertRuleCallbacks: (Function | InsertRuleCallback)[] = [];\n  private _onResetCallbacks: Function[] = [];\n  private _classNameToArgs: { [key: string]: { args: any; rules: string[] } } = {};\n\n  /**\n   * Gets the singleton instance.\n   */\n  public static getInstance(shadowConfig?: ShadowConfig): Stylesheet {\n    _stylesheet = _global[STYLESHEET_SETTING] as Stylesheet;\n\n    if (_global[SHADOW_DOM_STYLESHEET_SETTING]) {\n      return _global[SHADOW_DOM_STYLESHEET_SETTING].getInstance(shadowConfig);\n    }\n\n    if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\n      const fabricConfig = _global?.FabricConfig || {};\n\n      const stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n      _stylesheet = stylesheet;\n      _global[STYLESHEET_SETTING] = stylesheet;\n    }\n\n    return _stylesheet;\n  }\n\n  constructor(config?: IStyleSheetConfig, serializedStylesheet?: ISerializedStylesheet) {\n    // If there is no document we won't have an element to inject into.\n    this._config = {\n      injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined,\n      ...config,\n    };\n\n    this._classNameToArgs = serializedStylesheet?.classNameToArgs ?? this._classNameToArgs;\n    this._counter = serializedStylesheet?.counter ?? this._counter;\n    this._keyToClassName = this._config.classNameCache ?? serializedStylesheet?.keyToClassName ?? this._keyToClassName;\n    this._preservedRules = serializedStylesheet?.preservedRules ?? this._preservedRules;\n    this._rules = serializedStylesheet?.rules ?? this._rules;\n  }\n\n  /**\n   * Serializes the Stylesheet instance into a format which allows rehydration on creation.\n   * @returns string representation of `ISerializedStylesheet` interface.\n   */\n  public serialize(): string {\n    return JSON.stringify({\n      classNameToArgs: this._classNameToArgs,\n      counter: this._counter,\n      keyToClassName: this._keyToClassName,\n      preservedRules: this._preservedRules,\n      rules: this._rules,\n    });\n  }\n\n  /**\n   * Configures the stylesheet.\n   */\n  public setConfig(config?: IStyleSheetConfig): void {\n    this._config = {\n      ...this._config,\n      ...config,\n    };\n  }\n\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   * @returns function which when called un-registers provided callback.\n   */\n  public onReset(callback: Function): Function {\n    this._onResetCallbacks.push(callback);\n\n    return () => {\n      this._onResetCallbacks = this._onResetCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Configures an insert rule callback.\n   *\n   * @param callback - A callback which will be called when a rule is inserted.\n   * @returns function which when called un-registers provided callback.\n   */\n  public onInsertRule(callback: Function | InsertRuleCallback): Function {\n    this._onInsertRuleCallbacks.push(callback);\n\n    return () => {\n      this._onInsertRuleCallbacks = this._onInsertRuleCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n  public getClassName(displayName?: string): string {\n    const { namespace } = this._config;\n    const prefix = displayName || this._config.defaultPrefix;\n\n    return `${namespace ? namespace + '-' : ''}${prefix}-${this._counter++}`;\n  }\n\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n  public cacheClassName(className: string, key: string, args: IStyle[], rules: string[]): void {\n    this._keyToClassName[this._getCacheKey(key)] = className;\n    this._classNameToArgs[className] = {\n      args,\n      rules,\n    };\n  }\n\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n  public classNameFromKey(key: string): string | undefined {\n    return this._keyToClassName[this._getCacheKey(key)];\n  }\n\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n  public getClassNameCache(): { [key: string]: string } {\n    return this._keyToClassName;\n  }\n\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public argsFromClassName(className: string): IStyle[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.args;\n  }\n\n  /**\n   * Gets the rules associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public insertedRulesFromClassName(className: string): string[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.rules;\n  }\n\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n  public insertRule(rule: string, preserve?: boolean, stylesheetKey: string = GLOBAL_STYLESHEET_KEY): void {\n    const { injectionMode } = this._config;\n\n    const element: HTMLStyleElement | undefined =\n      injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n\n    if (element) {\n      switch (injectionMode) {\n        case InjectionMode.insertNode:\n          this._insertRuleIntoSheet(element.sheet, rule);\n          break;\n\n        case InjectionMode.appendChild:\n          (element as HTMLStyleElement).appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._config.onInsertRule) {\n      // eslint-disable-next-line deprecation/deprecation\n      this._config.onInsertRule(rule);\n    }\n\n    this._onInsertRuleCallbacks.forEach(callback =>\n      callback({ key: stylesheetKey, sheet: (element ? element.sheet : undefined) as ExtendedCSSStyleSheet, rule }),\n    );\n  }\n\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n  public getRules(includePreservedRules?: boolean): string {\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');\n  }\n\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n  public reset(): void {\n    this._rules = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n\n    this._onResetCallbacks.forEach(callback => callback());\n  }\n\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n  public resetKeys(): void {\n    this._keyToClassName = {};\n  }\n\n  protected _createStyleElement(): HTMLStyleElement {\n    const doc = this._config.window?.document || document;\n    const head: HTMLHeadElement = doc.head;\n    const styleElement = doc.createElement('style');\n    let nodeToInsertBefore: Node | null = null;\n\n    styleElement.setAttribute('data-merge-styles', 'true');\n\n    const { cspSettings } = this._config;\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      nodeToInsertBefore = this._lastStyleElement.nextElementSibling;\n    } else {\n      const placeholderStyleTag: Element | null = this._findPlaceholderStyleTag();\n\n      if (placeholderStyleTag) {\n        nodeToInsertBefore = placeholderStyleTag.nextElementSibling;\n      } else {\n        nodeToInsertBefore = head.childNodes[0];\n      }\n    }\n\n    head!.insertBefore(styleElement, head!.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);\n    this._lastStyleElement = styleElement;\n\n    return styleElement;\n  }\n\n  protected _insertRuleIntoSheet(sheet: CSSStyleSheet | undefined | null, rule: string): boolean {\n    if (!sheet) {\n      return false;\n    }\n\n    try {\n      sheet!.insertRule(rule, sheet!.cssRules.length);\n      return true;\n    } catch (e) {\n      // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n      // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n      // which could be slower and bulkier.\n    }\n\n    return false;\n  }\n\n  protected _getCacheKey(key: string): string {\n    return key;\n  }\n\n  private _getStyleElement(): HTMLStyleElement | undefined {\n    if (!this._styleElement) {\n      this._styleElement = this._createStyleElement();\n\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        const win = this._config.window || window;\n        win.requestAnimationFrame(() => {\n          this._styleElement = undefined;\n        });\n      }\n    }\n    return this._styleElement;\n  }\n\n  private _findPlaceholderStyleTag(): Element | null {\n    const head: HTMLHeadElement = document.head;\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}