{"ast":null,"code":"var _a;\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { ZIndexes } from '../../../Styling';\nimport { Layer } from '../../../Layer';\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, EventGroup, getPropsWithDefaults } from '../../../Utilities';\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../Positioning';\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nimport { useMergedRefs, useAsync, useTarget } from '@fluentui/react-hooks';\nimport { useDocumentEx, useWindowEx } from '../../../utilities/dom';\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n};\n// In order for some of the max height logic to work properly we need to set the border.\n// The value is arbitrary.\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = 'slideUpIn20', _a[RectangleEdge.bottom] = 'slideDownIn20', _a[RectangleEdge.left] = 'slideLeftIn20', _a[RectangleEdge.right] = 'slideRightIn20', _a);\nvar DEFAULT_PROPS = {\n  preventDismissOnScroll: false,\n  offsetFromTarget: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\nfunction useBounds(props, targetWindow) {\n  /** The bounds used when determining if and where the PositioningContainer should be placed. */\n  var getBounds = function () {\n    var currentBounds = props.bounds;\n    if (!currentBounds) {\n      currentBounds = {\n        top: 0 + props.minPagePadding,\n        left: 0 + props.minPagePadding,\n        right: targetWindow.innerWidth - props.minPagePadding,\n        bottom: targetWindow.innerHeight - props.minPagePadding,\n        width: targetWindow.innerWidth - props.minPagePadding * 2,\n        height: targetWindow.innerHeight - props.minPagePadding * 2\n      };\n    }\n    return currentBounds;\n  };\n  return getBounds;\n}\nfunction usePositionState(props, positionedHost, contentHost, targetRef, getCachedBounds) {\n  var async = useAsync();\n  var doc = useDocumentEx();\n  var win = useWindowEx();\n  /**\n   * Current set of calculated positions for the outermost parent container.\n   */\n  var _a = React.useState(),\n    positions = _a[0],\n    setPositions = _a[1];\n  var positionAttempts = React.useRef(0);\n  var updateAsyncPosition = function () {\n    async.requestAnimationFrame(function () {\n      return updatePosition();\n    });\n  };\n  var updatePosition = function () {\n    var offsetFromTarget = props.offsetFromTarget,\n      onPositioned = props.onPositioned;\n    var hostElement = positionedHost.current;\n    var positioningContainerElement = contentHost.current;\n    if (hostElement && positioningContainerElement) {\n      var currentProps = __assign({}, props);\n      currentProps.bounds = getCachedBounds();\n      currentProps.target = targetRef.current;\n      var target = currentProps.target;\n      if (target) {\n        // Check if the target is an Element or a MouseEvent and the document contains it\n        // or don't check anything else if the target is a Point or Rectangle\n        if (!target.getBoundingClientRect && !target.preventDefault || (doc === null || doc === void 0 ? void 0 : doc.body.contains(target))) {\n          currentProps.gapSpace = offsetFromTarget;\n          var newPositions = positionElement(currentProps, hostElement, positioningContainerElement, undefined, win);\n          // Set the new position only when the positions are not exists or one of the new positioningContainer\n          // positions are different. The position should not change if the position is within 2 decimal places.\n          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n            // We should not reposition the positioningContainer more than a few times, if it is then the content is\n            // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(newPositions);\n          } else {\n            positionAttempts.current = 0;\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(newPositions);\n          }\n        } else if (positions !== undefined) {\n          setPositions(undefined);\n        }\n      } else if (positions !== undefined) {\n        setPositions(undefined);\n      }\n    }\n  };\n  React.useEffect(updateAsyncPosition);\n  return [positions, updateAsyncPosition];\n}\nfunction useSetInitialFocus(_a, contentHost, positions) {\n  var setInitialFocus = _a.setInitialFocus;\n  var didSetInitialFocus = React.useRef(false);\n  React.useEffect(function () {\n    if (!didSetInitialFocus.current && contentHost.current && setInitialFocus && positions) {\n      didSetInitialFocus.current = true;\n      focusFirstChild(contentHost.current);\n    }\n  });\n}\nfunction useMaxHeight(_a, targetRef, getCachedBounds) {\n  var directionalHintFixed = _a.directionalHintFixed,\n    offsetFromTarget = _a.offsetFromTarget,\n    directionalHint = _a.directionalHint,\n    target = _a.target;\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going beyond the window or target bounds\n   */\n  var maxHeight = React.useRef();\n  var win = useWindowEx();\n  // If the target element changed, reset the max height. If we are tracking\n  // target with class name, always reset because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n  if (typeof target === 'string') {\n    maxHeight.current = undefined;\n  }\n  React.useEffect(function () {\n    maxHeight.current = undefined;\n  }, [target, offsetFromTarget]);\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  var getCachedMaxHeight = function () {\n    if (!maxHeight.current) {\n      if (directionalHintFixed && targetRef.current) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        maxHeight.current = getMaxHeight(targetRef.current, directionalHint, gapSpace, getCachedBounds(), undefined, win);\n      } else {\n        maxHeight.current = getCachedBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n    return maxHeight.current;\n  };\n  return getCachedMaxHeight;\n}\nfunction useAutoDismissEvents(_a, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition) {\n  var onDismiss = _a.onDismiss,\n    preventDismissOnScroll = _a.preventDismissOnScroll;\n  var async = useAsync();\n  var onResize = React.useCallback(function (ev) {\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      updateAsyncPosition();\n    }\n  }, [onDismiss, updateAsyncPosition]);\n  var dismissOnLostFocus = React.useCallback(function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = positionedHost.current && !elementContains(positionedHost.current, target);\n    if (!targetRef.current && clickedOutsideCallout || ev.target !== targetWindow && clickedOutsideCallout && (targetRef.current.stopPropagation || !targetRef.current || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n      onResize(ev);\n    }\n  }, [onResize, positionedHost, targetRef, targetWindow]);\n  var dismissOnScroll = React.useCallback(function (ev) {\n    if (positions && !preventDismissOnScroll) {\n      dismissOnLostFocus(ev);\n    }\n  }, [dismissOnLostFocus, positions, preventDismissOnScroll]);\n  React.useEffect(function () {\n    var events = new EventGroup({});\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    async.setTimeout(function () {\n      var _a, _b;\n      events.on(targetWindow, 'scroll', async.throttle(dismissOnScroll, 10), true);\n      events.on(targetWindow, 'resize', async.throttle(onResize, 10), true);\n      events.on((_a = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document) === null || _a === void 0 ? void 0 : _a.body, 'focus', dismissOnLostFocus, true);\n      events.on((_b = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document) === null || _b === void 0 ? void 0 : _b.body, 'click', dismissOnLostFocus, true);\n    }, 0);\n    return function () {\n      return events.dispose();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on mount\n  }, [dismissOnScroll]);\n}\nexport function useHeightOffset(_a, contentHost) {\n  var finalHeight = _a.finalHeight;\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   * State stored as object to ensure re-render even if the value does not change.\n   *  See https://github.com/microsoft/fluentui/issues/23545\n   */\n  var _b = React.useState({\n      value: 0\n    }),\n    heightOffset = _b[0],\n    setHeightOffset = _b[1];\n  var async = useAsync();\n  var setHeightOffsetTimer = React.useRef(0);\n  /** Animates the height if finalHeight was given. */\n  var setHeightOffsetEveryFrame = function () {\n    if (contentHost && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(function () {\n        if (!contentHost.current) {\n          return;\n        }\n        var positioningContainerMainElem = contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n        setHeightOffset({\n          value: heightOffset.value + scrollDiff\n        });\n        if (positioningContainerMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current);\n        }\n      });\n    }\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only re-run if finalHeight changes\n  React.useEffect(setHeightOffsetEveryFrame, [finalHeight]);\n  return heightOffset.value;\n}\nexport var PositioningContainer = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  // @TODO rename to reflect the name of this class\n  var contentHost = React.useRef(null);\n  /**\n   * The primary positioned div.\n   */\n  var positionedHost = React.useRef(null);\n  var rootRef = useMergedRefs(forwardedRef, positionedHost);\n  var _a = useTarget(props.target, positionedHost),\n    targetRef = _a[0],\n    targetWindow = _a[1];\n  var getCachedBounds = useBounds(props, targetWindow);\n  var _b = usePositionState(props, positionedHost, contentHost, targetRef, getCachedBounds),\n    positions = _b[0],\n    updateAsyncPosition = _b[1];\n  var getCachedMaxHeight = useMaxHeight(props, targetRef, getCachedBounds);\n  var heightOffset = useHeightOffset(props, contentHost);\n  useSetInitialFocus(props, contentHost, positions);\n  useAutoDismissEvents(props, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition);\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on initial render\n  React.useEffect(function () {\n    var _a;\n    return (_a = props.onLayerMounted) === null || _a === void 0 ? void 0 : _a.call(props);\n  }, []);\n  // If there is no target window then we are likely in server side rendering and we should not render anything.\n  if (!targetWindow) {\n    return null;\n  }\n  var className = props.className,\n    doNotLayer = props.doNotLayer,\n    positioningContainerWidth = props.positioningContainerWidth,\n    positioningContainerMaxHeight = props.positioningContainerMaxHeight,\n    children = props.children;\n  var styles = getClassNames();\n  var directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n  var getContentMaxHeight = getCachedMaxHeight() + heightOffset;\n  var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n  var content = React.createElement(\"div\", {\n    ref: rootRef,\n    className: css('ms-PositioningContainer', styles.container)\n  }, React.createElement(\"div\", {\n    className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n      width: positioningContainerWidth\n    }, doNotLayer && {\n      zIndex: ZIndexes.Layer\n    }),\n    style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: contentHost\n  }, children,\n  // @TODO apply to the content container\n  contentMaxHeight));\n  return doNotLayer ? content : React.createElement(Layer, __assign({}, props.layerProps), content);\n});\nPositioningContainer.displayName = 'PositioningContainer';\nfunction arePositionsEqual(positions, newPosition) {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition);\n}\nfunction comparePositions(oldPositions, newPositions) {\n  for (var key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = oldPositions[key];\n      var newPositionEdge = newPositions[key];\n      if (oldPositionEdge && newPositionEdge) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["React","getClassNames","ZIndexes","Layer","DirectionalHint","css","elementContains","focusFirstChild","EventGroup","getPropsWithDefaults","getMaxHeight","positionElement","RectangleEdge","AnimationClassNames","mergeStyles","useMergedRefs","useAsync","useTarget","useDocumentEx","useWindowEx","OFF_SCREEN_STYLE","opacity","BORDER_WIDTH","SLIDE_ANIMATIONS","_a","top","bottom","left","right","DEFAULT_PROPS","preventDismissOnScroll","offsetFromTarget","minPagePadding","directionalHint","bottomAutoEdge","useBounds","props","targetWindow","getBounds","currentBounds","bounds","innerWidth","innerHeight","width","height","usePositionState","positionedHost","contentHost","targetRef","getCachedBounds","async","doc","win","useState","positions","setPositions","positionAttempts","useRef","updateAsyncPosition","requestAnimationFrame","updatePosition","onPositioned","hostElement","current","positioningContainerElement","currentProps","__assign","target","getBoundingClientRect","preventDefault","body","contains","gapSpace","newPositions","undefined","arePositionsEqual","useEffect","useSetInitialFocus","setInitialFocus","didSetInitialFocus","useMaxHeight","directionalHintFixed","maxHeight","getCachedMaxHeight","useAutoDismissEvents","onDismiss","onResize","useCallback","ev","dismissOnLostFocus","clickedOutsideCallout","stopPropagation","dismissOnScroll","events","setTimeout","on","throttle","document","_b","dispose","useHeightOffset","finalHeight","value","heightOffset","setHeightOffset","setHeightOffsetTimer","setHeightOffsetEveryFrame","positioningContainerMainElem","lastChild","cardScrollHeight","scrollHeight","cardCurrHeight","offsetHeight","scrollDiff","cancelAnimationFrame","PositioningContainer","forwardRef","propsWithoutDefaults","forwardedRef","rootRef","onLayerMounted","call","className","doNotLayer","positioningContainerWidth","positioningContainerMaxHeight","children","styles","directionalClassName","targetEdge","getContentMaxHeight","contentMaxHeight","content","createElement","ref","container","root","zIndex","style","elementPosition","tabIndex","layerProps","displayName","newPosition","comparePositions","oldPositions","key","hasOwnProperty","oldPositionEdge","newPositionEdge","toFixed"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\components\\Coachmark\\src\\components\\Coachmark\\PositioningContainer\\PositioningContainer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { ZIndexes } from '../../../Styling';\nimport { Layer } from '../../../Layer';\n\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, EventGroup, getPropsWithDefaults } from '../../../Utilities';\n\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../Positioning';\n\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nimport { useMergedRefs, useAsync, useTarget } from '@fluentui/react-hooks';\nimport type { IPositioningContainerProps } from './PositioningContainer.types';\nimport type { Point, IRectangle } from '../../../Utilities';\nimport type { IPositionedData, IPositionProps, IPosition } from '../../../Positioning';\nimport { useDocumentEx, useWindowEx } from '../../../utilities/dom';\n\nconst OFF_SCREEN_STYLE = { opacity: 0 };\n\n// In order for some of the max height logic to work properly we need to set the border.\n// The value is arbitrary.\nconst BORDER_WIDTH = 1;\nconst SLIDE_ANIMATIONS = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20',\n} as const;\n\nconst DEFAULT_PROPS = {\n  preventDismissOnScroll: false,\n  offsetFromTarget: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n};\n\nfunction useBounds(props: IPositioningContainerProps, targetWindow: Window | undefined) {\n  /** The bounds used when determining if and where the PositioningContainer should be placed. */\n\n  const getBounds = (): IRectangle => {\n    let currentBounds = props.bounds;\n\n    if (!currentBounds) {\n      currentBounds = {\n        top: 0 + props.minPagePadding!,\n        left: 0 + props.minPagePadding!,\n        right: targetWindow!.innerWidth - props.minPagePadding!,\n        bottom: targetWindow!.innerHeight - props.minPagePadding!,\n        width: targetWindow!.innerWidth - props.minPagePadding! * 2,\n        height: targetWindow!.innerHeight - props.minPagePadding! * 2,\n      };\n    }\n    return currentBounds;\n  };\n\n  return getBounds;\n}\n\nfunction usePositionState(\n  props: IPositioningContainerProps,\n  positionedHost: React.RefObject<HTMLDivElement | null>,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getCachedBounds: () => IRectangle,\n) {\n  const async = useAsync();\n  const doc = useDocumentEx();\n  const win = useWindowEx();\n  /**\n   * Current set of calculated positions for the outermost parent container.\n   */\n  const [positions, setPositions] = React.useState<IPositionedData>();\n  const positionAttempts = React.useRef(0);\n\n  const updateAsyncPosition = (): void => {\n    async.requestAnimationFrame(() => updatePosition());\n  };\n\n  const updatePosition = (): void => {\n    const { offsetFromTarget, onPositioned } = props;\n    const hostElement = positionedHost.current;\n    const positioningContainerElement = contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      const currentProps: IPositionProps = { ...props } as IPositionProps;\n      currentProps!.bounds = getCachedBounds();\n      currentProps!.target = targetRef.current!;\n      const { target } = currentProps;\n\n      if (target) {\n        // Check if the target is an Element or a MouseEvent and the document contains it\n        // or don't check anything else if the target is a Point or Rectangle\n        if (\n          (!(target as Element).getBoundingClientRect && !(target as MouseEvent).preventDefault) ||\n          doc?.body.contains(target as Node)\n        ) {\n          currentProps!.gapSpace = offsetFromTarget;\n          const newPositions: IPositionedData = positionElement(\n            currentProps!,\n            hostElement,\n            positioningContainerElement,\n            undefined,\n            win,\n          );\n          // Set the new position only when the positions are not exists or one of the new positioningContainer\n          // positions are different. The position should not change if the position is within 2 decimal places.\n          if (\n            (!positions && newPositions) ||\n            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n          ) {\n            // We should not reposition the positioningContainer more than a few times, if it is then the content is\n            // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n            onPositioned?.(newPositions);\n          } else {\n            positionAttempts.current = 0;\n            onPositioned?.(newPositions);\n          }\n        } else if (positions !== undefined) {\n          setPositions(undefined);\n        }\n      } else if (positions !== undefined) {\n        setPositions(undefined);\n      }\n    }\n  };\n\n  React.useEffect(updateAsyncPosition);\n\n  return [positions, updateAsyncPosition] as const;\n}\n\nfunction useSetInitialFocus(\n  { setInitialFocus }: IPositioningContainerProps,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n  positions: IPositionedData | undefined,\n) {\n  const didSetInitialFocus = React.useRef(false);\n\n  React.useEffect((): void => {\n    if (!didSetInitialFocus.current && contentHost.current && setInitialFocus && positions) {\n      didSetInitialFocus.current = true;\n      focusFirstChild(contentHost.current);\n    }\n  });\n}\n\nfunction useMaxHeight(\n  { directionalHintFixed, offsetFromTarget, directionalHint, target }: IPositioningContainerProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getCachedBounds: () => IRectangle,\n) {\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going beyond the window or target bounds\n   */\n  const maxHeight = React.useRef<number | undefined>();\n  const win = useWindowEx();\n\n  // If the target element changed, reset the max height. If we are tracking\n  // target with class name, always reset because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n  if (typeof target === 'string') {\n    maxHeight.current = undefined;\n  }\n  React.useEffect(() => {\n    maxHeight.current = undefined;\n  }, [target, offsetFromTarget]);\n\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  const getCachedMaxHeight = (): number => {\n    if (!maxHeight.current) {\n      if (directionalHintFixed && targetRef.current) {\n        const gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        maxHeight.current = getMaxHeight(\n          targetRef.current,\n          directionalHint!,\n          gapSpace,\n          getCachedBounds(),\n          undefined,\n          win,\n        );\n      } else {\n        maxHeight.current = getCachedBounds().height! - BORDER_WIDTH * 2;\n      }\n    }\n    return maxHeight.current!;\n  };\n\n  return getCachedMaxHeight;\n}\n\nfunction useAutoDismissEvents(\n  { onDismiss, preventDismissOnScroll }: IPositioningContainerProps,\n  positionedHost: React.RefObject<HTMLDivElement | null>,\n  targetWindow: Window | undefined,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  positions: IPositionedData | undefined,\n  updateAsyncPosition: () => void,\n) {\n  const async = useAsync();\n\n  const onResize = React.useCallback(\n    (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n      if (onDismiss) {\n        onDismiss(ev);\n      } else {\n        updateAsyncPosition();\n      }\n    },\n    [onDismiss, updateAsyncPosition],\n  );\n\n  const dismissOnLostFocus = React.useCallback(\n    (ev: Event): void => {\n      const target = ev.target as HTMLElement;\n      const clickedOutsideCallout = positionedHost.current && !elementContains(positionedHost.current, target);\n\n      if (\n        (!targetRef.current && clickedOutsideCallout) ||\n        (ev.target !== targetWindow &&\n          clickedOutsideCallout &&\n          ((targetRef.current as MouseEvent).stopPropagation ||\n            !targetRef.current ||\n            (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n      ) {\n        onResize(ev);\n      }\n    },\n    [onResize, positionedHost, targetRef, targetWindow],\n  );\n\n  const dismissOnScroll = React.useCallback(\n    (ev: Event): void => {\n      if (positions && !preventDismissOnScroll) {\n        dismissOnLostFocus(ev);\n      }\n    },\n    [dismissOnLostFocus, positions, preventDismissOnScroll],\n  );\n\n  React.useEffect(() => {\n    const events = new EventGroup({});\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    async.setTimeout(() => {\n      events.on(targetWindow, 'scroll', async.throttle(dismissOnScroll, 10), true);\n      events.on(targetWindow, 'resize', async.throttle(onResize, 10), true);\n      events.on(targetWindow?.document?.body, 'focus', dismissOnLostFocus, true);\n      events.on(targetWindow?.document?.body, 'click', dismissOnLostFocus, true);\n    }, 0);\n\n    return () => events.dispose();\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on mount\n  }, [dismissOnScroll]);\n}\n\nexport function useHeightOffset(\n  { finalHeight }: IPositioningContainerProps,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n) {\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   * State stored as object to ensure re-render even if the value does not change.\n   *  See https://github.com/microsoft/fluentui/issues/23545\n   */\n  const [heightOffset, setHeightOffset] = React.useState<{ value: number }>({ value: 0 });\n  const async = useAsync();\n  const setHeightOffsetTimer = React.useRef<number>(0);\n\n  /** Animates the height if finalHeight was given. */\n  const setHeightOffsetEveryFrame = (): void => {\n    if (contentHost && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(() => {\n        if (!contentHost.current) {\n          return;\n        }\n\n        const positioningContainerMainElem = contentHost.current.lastChild as HTMLElement;\n        const cardScrollHeight: number = positioningContainerMainElem.scrollHeight;\n        const cardCurrHeight: number = positioningContainerMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        setHeightOffset({ value: heightOffset.value + scrollDiff });\n\n        if (positioningContainerMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current);\n        }\n      });\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only re-run if finalHeight changes\n  React.useEffect(setHeightOffsetEveryFrame, [finalHeight]);\n\n  return heightOffset.value;\n}\n\nexport const PositioningContainer: React.FunctionComponent<IPositioningContainerProps> = React.forwardRef<\n  HTMLDivElement,\n  IPositioningContainerProps\n>((propsWithoutDefaults, forwardedRef) => {\n  const props = getPropsWithDefaults<IPositioningContainerProps>(DEFAULT_PROPS, propsWithoutDefaults);\n\n  // @TODO rename to reflect the name of this class\n  const contentHost = React.useRef<HTMLDivElement>(null);\n  /**\n   * The primary positioned div.\n   */\n  const positionedHost = React.useRef<HTMLDivElement>(null);\n  const rootRef = useMergedRefs(forwardedRef, positionedHost);\n\n  const [targetRef, targetWindow] = useTarget(props.target, positionedHost);\n  const getCachedBounds = useBounds(props, targetWindow);\n  const [positions, updateAsyncPosition] = usePositionState(\n    props,\n    positionedHost,\n    contentHost,\n    targetRef,\n    getCachedBounds,\n  );\n  const getCachedMaxHeight = useMaxHeight(props, targetRef, getCachedBounds);\n  const heightOffset = useHeightOffset(props, contentHost);\n\n  useSetInitialFocus(props, contentHost, positions);\n  useAutoDismissEvents(props, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on initial render\n  React.useEffect(() => props.onLayerMounted?.(), []);\n\n  // If there is no target window then we are likely in server side rendering and we should not render anything.\n  if (!targetWindow) {\n    return null;\n  }\n\n  const { className, doNotLayer, positioningContainerWidth, positioningContainerMaxHeight, children } = props;\n\n  const styles = getClassNames();\n\n  const directionalClassName =\n    positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n\n  const getContentMaxHeight: number = getCachedMaxHeight() + heightOffset!;\n  const contentMaxHeight: number =\n    positioningContainerMaxHeight! && positioningContainerMaxHeight! > getContentMaxHeight\n      ? getContentMaxHeight\n      : positioningContainerMaxHeight!;\n  const content = (\n    <div ref={rootRef} className={css('ms-PositioningContainer', styles.container)}>\n      <div\n        className={mergeStyles(\n          'ms-PositioningContainer-layerHost',\n          styles.root,\n          className,\n          directionalClassName,\n          !!positioningContainerWidth && { width: positioningContainerWidth },\n          doNotLayer && { zIndex: ZIndexes.Layer },\n        )}\n        style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n        tabIndex={-1}\n        ref={contentHost}\n      >\n        {children}\n        {\n          // @TODO apply to the content container\n          contentMaxHeight\n        }\n      </div>\n    </div>\n  );\n\n  return doNotLayer ? content : <Layer {...props.layerProps}>{content}</Layer>;\n});\nPositioningContainer.displayName = 'PositioningContainer';\n\nfunction arePositionsEqual(positions: IPositionedData, newPosition: IPositionedData): boolean {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition);\n}\n\nfunction comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n  for (const key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = oldPositions[key];\n      const newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge && newPositionEdge) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}