{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getActiveElement, getEventTarget, elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, focusAsync, getPropsWithDefaults, modalize, on, useHasMergeStylesShadowRootContext } from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useEventCallback, usePrevious, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nimport { useWindowEx } from '../../utilities/dom';\nvar COMPONENT_NAME = 'FocusTrapZone';\nvar DEFAULT_PROPS = {\n  disabled: false,\n  disableFirstFocus: false,\n  forceFocusInsideTrap: true,\n  isClickableOutsideFocusTrap: false,\n  // Hardcoding completely uncontrolled flag for proper interop with FluentUI V9.\n  'data-tabster': '{\"uncontrolled\": {\"completely\": true}}'\n};\nvar useComponentRef = function (componentRef, previouslyFocusedElement, focusFTZ) {\n  React.useImperativeHandle(componentRef, function () {\n    return {\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus: focusFTZ\n    };\n  }, [focusFTZ, previouslyFocusedElement]);\n};\nexport var FocusTrapZone = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var _a;\n  var root = React.useRef(null);\n  var firstBumper = React.useRef(null);\n  var lastBumper = React.useRef(null);\n  var mergedRootRef = useMergedRefs(root, ref);\n  var doc = useDocument();\n  var win = useWindowEx();\n  var inShadow = useHasMergeStylesShadowRootContext();\n  var isFirstRender = (_a = usePrevious(false)) !== null && _a !== void 0 ? _a : true;\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var internalState = useConst({\n    hasFocus: false,\n    focusStackId: useId('ftz-', props.id)\n  });\n  var children = props.children,\n    componentRef = props.componentRef,\n    disabled = props.disabled,\n    disableFirstFocus = props.disableFirstFocus,\n    forceFocusInsideTrap = props.forceFocusInsideTrap,\n    focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector = props.firstFocusableSelector,\n    firstFocusableTarget = props.firstFocusableTarget,\n    // eslint-disable-next-line deprecation/deprecation\n    _b = props.disableRestoreFocus,\n    // eslint-disable-next-line deprecation/deprecation\n    disableRestoreFocus = _b === void 0 ? props.ignoreExternalFocusing : _b,\n    isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n    enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0,\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true\n  };\n  var focusElementAsync = React.useCallback(function (element) {\n    if (element !== firstBumper.current && element !== lastBumper.current) {\n      focusAsync(element);\n    }\n  }, []);\n  /**\n   * Callback to force focus into FTZ (named to avoid overlap with global focus() callback).\n   * useEventCallback always returns the same callback reference but updates the implementation\n   * every render to avoid stale captured values.\n   */\n  var focusFTZ = useEventCallback(function () {\n    if (!root.current) {\n      return; // not done mounting\n    }\n    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;\n    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root.current, previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusElementAsync(previouslyFocusedElementInTrapZone);\n      return;\n    }\n    var firstFocusableChild = null;\n    if (typeof firstFocusableTarget === 'string') {\n      firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n    } else if (firstFocusableTarget) {\n      firstFocusableChild = firstFocusableTarget(root.current);\n    } else if (firstFocusableSelector) {\n      var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector();\n      firstFocusableChild = root.current.querySelector('.' + focusSelector);\n    }\n    // Fall back to first element if query selector did not match any elements.\n    if (!firstFocusableChild) {\n      firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true, undefined, undefined, undefined, inShadow);\n    }\n    if (firstFocusableChild) {\n      focusElementAsync(firstFocusableChild);\n    }\n  });\n  /** Used in root div focus/blur handlers */\n  var focusBumper = function (isFirstBumper) {\n    if (disabled || !root.current) {\n      return;\n    }\n    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, lastBumper.current, true, false, inShadow) : getFirstTabbable(root.current, firstBumper.current, true, false, inShadow);\n    if (nextFocusable) {\n      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n        // This can happen when FTZ contains no tabbable elements.\n        // focusFTZ() will take care of finding a focusable element in FTZ.\n        focusFTZ();\n      } else {\n        nextFocusable.focus();\n      }\n    }\n  };\n  /** Root div blur handler (doesn't need useCallback since it's for a native element) */\n  var onRootBlurCapture = function (ev) {\n    var _a;\n    (_a = props.onBlurCapture) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n    var relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = getActiveElement(doc);\n    }\n    if (!elementContains(root.current, relatedTarget)) {\n      internalState.hasFocus = false;\n    }\n  };\n  /** Root div focus handler (doesn't need useCallback since it's for a native element) */\n  var onRootFocusCapture = function (ev) {\n    var _a;\n    (_a = props.onFocusCapture) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n    if (ev.target === firstBumper.current) {\n      focusBumper(true);\n    } else if (ev.target === lastBumper.current) {\n      focusBumper(false);\n    }\n    internalState.hasFocus = true;\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = getEventTarget(ev.nativeEvent);\n    }\n  };\n  /** Called to restore focus on unmount or props change. (useEventCallback ensures latest prop values are used.) */\n  var returnFocusToInitiator = useEventCallback(function (elementToFocusOnDismiss) {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function (value) {\n      return internalState.focusStackId !== value;\n    });\n    if (!doc) {\n      return;\n    }\n    // Do not use getActiveElement() here.\n    // When the FTZ is in shadow DOM focus returns to the\n    // shadow host rather than body so we need to be\n    // able to inspect that\n    var activeElement = doc.activeElement;\n    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === 'function' && (\n    // only restore focus if the current focused element is within the FTZ, or if nothing is focused\n    elementContains(root.current, activeElement) || activeElement === doc.body || activeElement.shadowRoot)) {\n      focusElementAsync(elementToFocusOnDismiss);\n    }\n  });\n  /** Called in window event handlers. (useEventCallback ensures latest prop values are used.) */\n  var forceFocusOrClickInTrap = useEventCallback(function (ev) {\n    // be sure to use the latest values here\n    if (disabled) {\n      return;\n    }\n    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {\n      var targetElement = getEventTarget(ev);\n      if (targetElement && !elementContains(root.current, targetElement)) {\n        if (doc && getActiveElement(doc) === doc.body) {\n          setTimeout(function () {\n            if (doc && getActiveElement(doc) === doc.body) {\n              focusFTZ();\n              internalState.hasFocus = true; // set focus here since we stop event propagation\n            }\n          }, 0);\n        } else {\n          focusFTZ();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n        }\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  });\n  // Update window event handlers when relevant props change\n  React.useEffect(function () {\n    var disposables = [];\n    if (forceFocusInsideTrap) {\n      disposables.push(on(win, 'focus', forceFocusOrClickInTrap, true));\n    }\n    if (!isClickableOutsideFocusTrap) {\n      disposables.push(on(win, 'click', forceFocusOrClickInTrap, true));\n    }\n    return function () {\n      disposables.forEach(function (dispose) {\n        return dispose();\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap, win]);\n  // On prop change or first render, focus the FTZ and update focusStack if appropriate\n  React.useEffect(function () {\n    // Do nothing if disabled, or if it's a re-render and forceFocusInsideTrap is false\n    // (to match existing behavior, the FTZ handles first focus even if forceFocusInsideTrap\n    // is false, though it's debatable whether it should do this)\n    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root.current) {\n      return;\n    }\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled (or initial mount)\n    FocusTrapZone.focusStack.push(internalState.focusStackId);\n    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || getActiveElement(doc);\n    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {\n      focusFTZ();\n    }\n    // To match existing behavior, always return focus on cleanup (even if we didn't handle\n    // initial focus), but it's debatable whether that's correct\n    return function () {\n      return returnFocusToInitiator(elementToFocusOnDismiss);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, disabled]);\n  // Handle modalization separately from first focus\n  React.useEffect(function () {\n    if (!disabled && enableAriaHiddenSiblings) {\n      var unmodalize = modalize(root.current);\n      return unmodalize;\n    }\n  }, [disabled, enableAriaHiddenSiblings, root]);\n  // Cleanup lifecyle method for internalState.\n  useUnmount(function () {\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n  });\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);\n  return React.createElement(\"div\", __assign({\n    \"aria-labelledby\": props.ariaLabelledBy\n  }, getNativeProps(props, divProperties), {\n    ref: mergedRootRef,\n    onFocusCapture: onRootFocusCapture,\n    onBlurCapture: onRootBlurCapture\n  }), React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: firstBumper\n  })), children, React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: lastBumper\n  })));\n});\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];","map":{"version":3,"names":["React","getActiveElement","getEventTarget","elementContains","getNativeProps","divProperties","getFirstTabbable","getLastTabbable","getNextElement","focusAsync","getPropsWithDefaults","modalize","on","useHasMergeStylesShadowRootContext","useId","useConst","useMergedRefs","useEventCallback","usePrevious","useUnmount","useDocument","useWindowEx","COMPONENT_NAME","DEFAULT_PROPS","disabled","disableFirstFocus","forceFocusInsideTrap","isClickableOutsideFocusTrap","useComponentRef","componentRef","previouslyFocusedElement","focusFTZ","useImperativeHandle","focus","FocusTrapZone","forwardRef","propsWithoutDefaults","ref","root","useRef","firstBumper","lastBumper","mergedRootRef","doc","win","inShadow","isFirstRender","_a","props","internalState","hasFocus","focusStackId","id","children","focusPreviouslyFocusedInnerElement","firstFocusableSelector","firstFocusableTarget","_b","disableRestoreFocus","ignoreExternalFocusing","enableAriaHiddenSiblings","bumperProps","style","pointerEvents","position","tabIndex","focusElementAsync","useCallback","element","current","previouslyFocusedElementInTrapZone","firstFocusableChild","querySelector","focusSelector","firstChild","undefined","focusBumper","isFirstBumper","nextFocusable","onRootBlurCapture","ev","onBlurCapture","call","relatedTarget","onRootFocusCapture","onFocusCapture","target","currentTarget","nativeEvent","returnFocusToInitiator","elementToFocusOnDismiss","focusStack","filter","value","activeElement","body","shadowRoot","forceFocusOrClickInTrap","slice","targetElement","setTimeout","preventDefault","stopPropagation","useEffect","disposables","push","forEach","dispose","unmodalize","createElement","__assign","ariaLabelledBy","displayName"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\FocusTrapZone\\FocusTrapZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  getActiveElement,\n  getEventTarget,\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  focusAsync,\n  getPropsWithDefaults,\n  modalize,\n  on,\n  useHasMergeStylesShadowRootContext,\n} from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useEventCallback, usePrevious, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nimport type { IRefObject } from '../../Utilities';\nimport type { IFocusTrapZoneProps, IFocusTrapZone } from './FocusTrapZone.types';\nimport { useWindowEx } from '../../utilities/dom';\n\ninterface IFocusTrapZoneInternalState {\n  previouslyFocusedElementInTrapZone?: HTMLElement;\n  hasFocus: boolean;\n  /** ID tracked in focusStack. Don't respect prop updates in case the ID changes while the FTZ is active. */\n  focusStackId: string;\n}\n\nconst COMPONENT_NAME = 'FocusTrapZone';\n\nconst DEFAULT_PROPS = {\n  disabled: false,\n  disableFirstFocus: false,\n  forceFocusInsideTrap: true,\n  isClickableOutsideFocusTrap: false,\n  // Hardcoding completely uncontrolled flag for proper interop with FluentUI V9.\n  'data-tabster': '{\"uncontrolled\": {\"completely\": true}}',\n};\n\nconst useComponentRef = (\n  componentRef: IRefObject<IFocusTrapZone> | undefined,\n  previouslyFocusedElement: HTMLElement | undefined,\n  focusFTZ: () => void,\n) => {\n  React.useImperativeHandle(\n    componentRef,\n    () => ({\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus: focusFTZ,\n    }),\n    [focusFTZ, previouslyFocusedElement],\n  );\n};\n\nexport const FocusTrapZone: React.FunctionComponent<IFocusTrapZoneProps> & {\n  /**\n   * Stack of active FocusTrapZone identifiers, exposed for testing purposes only.\n   * (This is always set, just marked as optional to avoid a cast in the component definition.)\n   * @internal\n   */\n  focusStack?: string[];\n} = React.forwardRef<HTMLDivElement, IFocusTrapZoneProps>((propsWithoutDefaults, ref) => {\n  const root = React.useRef<HTMLDivElement>(null);\n  const firstBumper = React.useRef<HTMLDivElement>(null);\n  const lastBumper = React.useRef<HTMLDivElement>(null);\n  const mergedRootRef = useMergedRefs(root, ref) as React.Ref<HTMLDivElement>;\n  const doc = useDocument();\n  const win = useWindowEx()!;\n  const inShadow = useHasMergeStylesShadowRootContext();\n\n  const isFirstRender = usePrevious(false) ?? true;\n\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n  const internalState = useConst<IFocusTrapZoneInternalState>({\n    hasFocus: false,\n    focusStackId: useId('ftz-', props.id),\n  });\n\n  const {\n    children,\n    componentRef,\n    disabled,\n    disableFirstFocus,\n    forceFocusInsideTrap,\n    focusPreviouslyFocusedInnerElement,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector,\n    firstFocusableTarget,\n    // eslint-disable-next-line deprecation/deprecation\n    disableRestoreFocus = props.ignoreExternalFocusing,\n    isClickableOutsideFocusTrap,\n    enableAriaHiddenSiblings,\n  } = props;\n\n  const bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true,\n  } as React.HTMLAttributes<HTMLDivElement>;\n\n  const focusElementAsync = React.useCallback((element: HTMLElement) => {\n    if (element !== firstBumper.current && element !== lastBumper.current) {\n      focusAsync(element);\n    }\n  }, []);\n\n  /**\n   * Callback to force focus into FTZ (named to avoid overlap with global focus() callback).\n   * useEventCallback always returns the same callback reference but updates the implementation\n   * every render to avoid stale captured values.\n   */\n  const focusFTZ = useEventCallback(() => {\n    if (!root.current) {\n      return; // not done mounting\n    }\n\n    const { previouslyFocusedElementInTrapZone } = internalState;\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      previouslyFocusedElementInTrapZone &&\n      elementContains(root.current, previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusElementAsync(previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (typeof firstFocusableTarget === 'string') {\n      firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n    } else if (firstFocusableTarget) {\n      firstFocusableChild = firstFocusableTarget(root.current);\n    } else if (firstFocusableSelector) {\n      const focusSelector =\n        typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector();\n      firstFocusableChild = root.current.querySelector('.' + focusSelector);\n    }\n\n    // Fall back to first element if query selector did not match any elements.\n    if (!firstFocusableChild) {\n      firstFocusableChild = getNextElement(\n        root.current,\n        root.current.firstChild as HTMLElement,\n        false,\n        false,\n        false,\n        true,\n        undefined,\n        undefined,\n        undefined,\n        inShadow,\n      );\n    }\n\n    if (firstFocusableChild) {\n      focusElementAsync(firstFocusableChild);\n    }\n  });\n\n  /** Used in root div focus/blur handlers */\n  const focusBumper = (isFirstBumper: boolean) => {\n    if (disabled || !root.current) {\n      return;\n    }\n\n    const nextFocusable =\n      isFirstBumper === internalState.hasFocus\n        ? getLastTabbable(root.current, lastBumper.current!, true, false, inShadow)\n        : getFirstTabbable(root.current, firstBumper.current!, true, false, inShadow);\n\n    if (nextFocusable) {\n      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n        // This can happen when FTZ contains no tabbable elements.\n        // focusFTZ() will take care of finding a focusable element in FTZ.\n        focusFTZ();\n      } else {\n        nextFocusable.focus();\n      }\n    }\n  };\n\n  /** Root div blur handler (doesn't need useCallback since it's for a native element) */\n  const onRootBlurCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    props.onBlurCapture?.(ev);\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = getActiveElement(doc!) as Element;\n    }\n    if (!elementContains(root.current, relatedTarget as HTMLElement)) {\n      internalState.hasFocus = false;\n    }\n  };\n\n  /** Root div focus handler (doesn't need useCallback since it's for a native element) */\n  const onRootFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    props.onFocusCapture?.(ev);\n\n    if (ev.target === firstBumper.current) {\n      focusBumper(true);\n    } else if (ev.target === lastBumper.current) {\n      focusBumper(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = getEventTarget(ev.nativeEvent) as HTMLElement;\n    }\n  };\n\n  /** Called to restore focus on unmount or props change. (useEventCallback ensures latest prop values are used.) */\n  const returnFocusToInitiator = useEventCallback((elementToFocusOnDismiss: HTMLElement | null) => {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack!.filter(value => internalState.focusStackId !== value);\n\n    if (!doc) {\n      return;\n    }\n\n    // Do not use getActiveElement() here.\n    // When the FTZ is in shadow DOM focus returns to the\n    // shadow host rather than body so we need to be\n    // able to inspect that\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !disableRestoreFocus &&\n      typeof elementToFocusOnDismiss?.focus === 'function' &&\n      // only restore focus if the current focused element is within the FTZ, or if nothing is focused\n      (elementContains(root.current, activeElement) || activeElement === doc.body || activeElement.shadowRoot)\n    ) {\n      focusElementAsync(elementToFocusOnDismiss);\n    }\n  });\n\n  /** Called in window event handlers. (useEventCallback ensures latest prop values are used.) */\n  const forceFocusOrClickInTrap = useEventCallback((ev: FocusEvent | MouseEvent): void => {\n    // be sure to use the latest values here\n    if (disabled) {\n      return;\n    }\n    if (internalState.focusStackId === FocusTrapZone.focusStack!.slice(-1)[0]) {\n      const targetElement = getEventTarget(ev);\n      if (targetElement && !elementContains(root.current, targetElement)) {\n        if (doc && getActiveElement(doc) === doc.body) {\n          setTimeout(() => {\n            if (doc && getActiveElement(doc) === doc.body) {\n              focusFTZ();\n              internalState.hasFocus = true; // set focus here since we stop event propagation\n            }\n          }, 0);\n        } else {\n          focusFTZ();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n        }\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  });\n\n  // Update window event handlers when relevant props change\n  React.useEffect(() => {\n    const disposables: Array<() => void> = [];\n\n    if (forceFocusInsideTrap) {\n      disposables.push(on(win, 'focus', forceFocusOrClickInTrap, true));\n    }\n    if (!isClickableOutsideFocusTrap) {\n      disposables.push(on(win, 'click', forceFocusOrClickInTrap, true));\n    }\n\n    return () => {\n      disposables.forEach(dispose => dispose());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap, win]);\n\n  // On prop change or first render, focus the FTZ and update focusStack if appropriate\n  React.useEffect(() => {\n    // Do nothing if disabled, or if it's a re-render and forceFocusInsideTrap is false\n    // (to match existing behavior, the FTZ handles first focus even if forceFocusInsideTrap\n    // is false, though it's debatable whether it should do this)\n    if (disabled || (!isFirstRender && !forceFocusInsideTrap) || !root.current) {\n      return;\n    }\n\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled (or initial mount)\n    FocusTrapZone.focusStack!.push(internalState.focusStackId);\n\n    const elementToFocusOnDismiss = props.elementToFocusOnDismiss || (getActiveElement(doc!) as HTMLElement | null);\n\n    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {\n      focusFTZ();\n    }\n\n    // To match existing behavior, always return focus on cleanup (even if we didn't handle\n    // initial focus), but it's debatable whether that's correct\n    return () => returnFocusToInitiator(elementToFocusOnDismiss);\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, disabled]);\n\n  // Handle modalization separately from first focus\n  React.useEffect(() => {\n    if (!disabled && enableAriaHiddenSiblings) {\n      const unmodalize = modalize(root.current!);\n      return unmodalize;\n    }\n  }, [disabled, enableAriaHiddenSiblings, root]);\n\n  // Cleanup lifecyle method for internalState.\n  useUnmount(() => {\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n  });\n\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);\n\n  return (\n    <div\n      // this is above the native props spread so props['aria-labelledby'] will override it if provided\n      aria-labelledby={props.ariaLabelledBy}\n      // native props include onFocus, onBlur, className\n      {...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties)}\n      ref={mergedRootRef}\n      onFocusCapture={onRootFocusCapture}\n      onBlurCapture={onRootBlurCapture}\n    >\n      <div {...bumperProps} ref={firstBumper} />\n      {children}\n      <div {...bumperProps} ref={lastBumper} />\n    </div>\n  );\n});\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SACEC,gBAAgB,EAChBC,cAAc,EACdC,eAAe,EACfC,cAAc,EACdC,aAAa,EACbC,gBAAgB,EAChBC,eAAe,EACfC,cAAc,EACdC,UAAU,EACVC,oBAAoB,EACpBC,QAAQ,EACRC,EAAE,EACFC,kCAAkC,QAC7B,iBAAiB;AACxB,SAASC,KAAK,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,gBAAgB,EAAEC,WAAW,EAAEC,UAAU,QAAQ,uBAAuB;AACjH,SAASC,WAAW,QAAQ,sBAAsB;AAGlD,SAASC,WAAW,QAAQ,qBAAqB;AASjD,IAAMC,cAAc,GAAG,eAAe;AAEtC,IAAMC,aAAa,GAAG;EACpBC,QAAQ,EAAE,KAAK;EACfC,iBAAiB,EAAE,KAAK;EACxBC,oBAAoB,EAAE,IAAI;EAC1BC,2BAA2B,EAAE,KAAK;EAClC;EACA,cAAc,EAAE;CACjB;AAED,IAAMC,eAAe,GAAG,SAAAA,CACtBC,YAAoD,EACpDC,wBAAiD,EACjDC,QAAoB;EAEpB/B,KAAK,CAACgC,mBAAmB,CACvBH,YAAY,EACZ;IAAM,OAAC;MACL,IAAIC,wBAAwBA,CAAA;QAC1B,OAAOA,wBAAwB;MACjC,CAAC;MACDG,KAAK,EAAEF;KACR;EALK,CAKJ,EACF,CAACA,QAAQ,EAAED,wBAAwB,CAAC,CACrC;AACH,CAAC;AAED,OAAO,IAAMI,aAAa,GAOtBlC,KAAK,CAACmC,UAAU,CAAsC,UAACC,oBAAoB,EAAEC,GAAG;;EAClF,IAAMC,IAAI,GAAGtC,KAAK,CAACuC,MAAM,CAAiB,IAAI,CAAC;EAC/C,IAAMC,WAAW,GAAGxC,KAAK,CAACuC,MAAM,CAAiB,IAAI,CAAC;EACtD,IAAME,UAAU,GAAGzC,KAAK,CAACuC,MAAM,CAAiB,IAAI,CAAC;EACrD,IAAMG,aAAa,GAAG1B,aAAa,CAACsB,IAAI,EAAED,GAAG,CAA8B;EAC3E,IAAMM,GAAG,GAAGvB,WAAW,EAAE;EACzB,IAAMwB,GAAG,GAAGvB,WAAW,EAAG;EAC1B,IAAMwB,QAAQ,GAAGhC,kCAAkC,EAAE;EAErD,IAAMiC,aAAa,GAAG,CAAAC,EAAA,GAAA7B,WAAW,CAAC,KAAK,CAAC,cAAA6B,EAAA,cAAAA,EAAA,GAAI,IAAI;EAEhD,IAAMC,KAAK,GAAGtC,oBAAoB,CAACa,aAAa,EAAEa,oBAAoB,CAAC;EAEvE,IAAMa,aAAa,GAAGlC,QAAQ,CAA8B;IAC1DmC,QAAQ,EAAE,KAAK;IACfC,YAAY,EAAErC,KAAK,CAAC,MAAM,EAAEkC,KAAK,CAACI,EAAE;GACrC,CAAC;EAGA,IAAAC,QAAQ,GAaNL,KAAK,CAAAK,QAbC;IACRxB,YAAY,GAYVmB,KAAK,CAAAnB,YAZK;IACZL,QAAQ,GAWNwB,KAAK,CAAAxB,QAXC;IACRC,iBAAiB,GAUfuB,KAAK,CAAAvB,iBAVU;IACjBC,oBAAoB,GASlBsB,KAAK,CAAAtB,oBATa;IACpB4B,kCAAkC,GAQhCN,KAAK,CAAAM,kCAR2B;IAClC;IACAC,sBAAsB,GAMpBP,KAAK,CAAAO,sBANe;IACtBC,oBAAoB,GAKlBR,KAAK,CAAAQ,oBALa;IACpB;IACAC,EAAA,GAGET,KAAK,CAAAU,mBAH2C;IADlD;IACAA,mBAAmB,GAAAD,EAAA,cAAGT,KAAK,CAACW,sBAAsB,GAAAF,EAAA;IAClD9B,2BAA2B,GAEzBqB,KAAK,CAAArB,2BAFoB;IAC3BiC,wBAAwB,GACtBZ,KAAK,CAAAY,wBADiB;EAG1B,IAAMC,WAAW,GAAG;IAClB,aAAa,EAAE,IAAI;IACnBC,KAAK,EAAE;MACLC,aAAa,EAAE,MAAM;MACrBC,QAAQ,EAAE,OAAO,CAAE;KACpB;IACDC,QAAQ,EAAEzC,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;IAC3B,iBAAiB,EAAE,IAAI;IACvB,gCAAgC,EAAE;GACK;EAEzC,IAAM0C,iBAAiB,GAAGlE,KAAK,CAACmE,WAAW,CAAC,UAACC,OAAoB;IAC/D,IAAIA,OAAO,KAAK5B,WAAW,CAAC6B,OAAO,IAAID,OAAO,KAAK3B,UAAU,CAAC4B,OAAO,EAAE;MACrE5D,UAAU,CAAC2D,OAAO,CAAC;;EAEvB,CAAC,EAAE,EAAE,CAAC;EAEN;;;;;EAKA,IAAMrC,QAAQ,GAAGd,gBAAgB,CAAC;IAChC,IAAI,CAACqB,IAAI,CAAC+B,OAAO,EAAE;MACjB,OAAO,CAAC;;IAGF,IAAAC,kCAAkC,GAAKrB,aAAa,CAAAqB,kCAAlB;IAC1C,IACEhB,kCAAkC,IAClCgB,kCAAkC,IAClCnE,eAAe,CAACmC,IAAI,CAAC+B,OAAO,EAAEC,kCAAkC,CAAC,EACjE;MACA;MACAJ,iBAAiB,CAACI,kCAAkC,CAAC;MACrD;;IAGF,IAAIC,mBAAmB,GAAuB,IAAI;IAElD,IAAI,OAAOf,oBAAoB,KAAK,QAAQ,EAAE;MAC5Ce,mBAAmB,GAAGjC,IAAI,CAAC+B,OAAO,CAACG,aAAa,CAAChB,oBAAoB,CAAC;KACvE,MAAM,IAAIA,oBAAoB,EAAE;MAC/Be,mBAAmB,GAAGf,oBAAoB,CAAClB,IAAI,CAAC+B,OAAO,CAAC;KACzD,MAAM,IAAId,sBAAsB,EAAE;MACjC,IAAMkB,aAAa,GACjB,OAAOlB,sBAAsB,KAAK,QAAQ,GAAGA,sBAAsB,GAAGA,sBAAsB,EAAE;MAChGgB,mBAAmB,GAAGjC,IAAI,CAAC+B,OAAO,CAACG,aAAa,CAAC,GAAG,GAAGC,aAAa,CAAC;;IAGvE;IACA,IAAI,CAACF,mBAAmB,EAAE;MACxBA,mBAAmB,GAAG/D,cAAc,CAClC8B,IAAI,CAAC+B,OAAO,EACZ/B,IAAI,CAAC+B,OAAO,CAACK,UAAyB,EACtC,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJC,SAAS,EACTA,SAAS,EACTA,SAAS,EACT9B,QAAQ,CACT;;IAGH,IAAI0B,mBAAmB,EAAE;MACvBL,iBAAiB,CAACK,mBAAmB,CAAC;;EAE1C,CAAC,CAAC;EAEF;EACA,IAAMK,WAAW,GAAG,SAAAA,CAACC,aAAsB;IACzC,IAAIrD,QAAQ,IAAI,CAACc,IAAI,CAAC+B,OAAO,EAAE;MAC7B;;IAGF,IAAMS,aAAa,GACjBD,aAAa,KAAK5B,aAAa,CAACC,QAAQ,GACpC3C,eAAe,CAAC+B,IAAI,CAAC+B,OAAO,EAAE5B,UAAU,CAAC4B,OAAQ,EAAE,IAAI,EAAE,KAAK,EAAExB,QAAQ,CAAC,GACzEvC,gBAAgB,CAACgC,IAAI,CAAC+B,OAAO,EAAE7B,WAAW,CAAC6B,OAAQ,EAAE,IAAI,EAAE,KAAK,EAAExB,QAAQ,CAAC;IAEjF,IAAIiC,aAAa,EAAE;MACjB,IAAIA,aAAa,KAAKtC,WAAW,CAAC6B,OAAO,IAAIS,aAAa,KAAKrC,UAAU,CAAC4B,OAAO,EAAE;QACjF;QACA;QACAtC,QAAQ,EAAE;OACX,MAAM;QACL+C,aAAa,CAAC7C,KAAK,EAAE;;;EAG3B,CAAC;EAED;EACA,IAAM8C,iBAAiB,GAAG,SAAAA,CAACC,EAAoC;;IAC7D,CAAAjC,EAAA,GAAAC,KAAK,CAACiC,aAAa,cAAAlC,EAAA,uBAAAA,EAAA,CAAAmC,IAAA,CAAAlC,KAAA,EAAGgC,EAAE,CAAC;IACzB,IAAIG,aAAa,GAAGH,EAAE,CAACG,aAAa;IACpC,IAAIH,EAAE,CAACG,aAAa,KAAK,IAAI,EAAE;MAC7B;MACA;MACA;MACA;MACA;MACAA,aAAa,GAAGlF,gBAAgB,CAAC0C,GAAI,CAAY;;IAEnD,IAAI,CAACxC,eAAe,CAACmC,IAAI,CAAC+B,OAAO,EAAEc,aAA4B,CAAC,EAAE;MAChElC,aAAa,CAACC,QAAQ,GAAG,KAAK;;EAElC,CAAC;EAED;EACA,IAAMkC,kBAAkB,GAAG,SAAAA,CAACJ,EAAoC;;IAC9D,CAAAjC,EAAA,GAAAC,KAAK,CAACqC,cAAc,cAAAtC,EAAA,uBAAAA,EAAA,CAAAmC,IAAA,CAAAlC,KAAA,EAAGgC,EAAE,CAAC;IAE1B,IAAIA,EAAE,CAACM,MAAM,KAAK9C,WAAW,CAAC6B,OAAO,EAAE;MACrCO,WAAW,CAAC,IAAI,CAAC;KAClB,MAAM,IAAII,EAAE,CAACM,MAAM,KAAK7C,UAAU,CAAC4B,OAAO,EAAE;MAC3CO,WAAW,CAAC,KAAK,CAAC;;IAGpB3B,aAAa,CAACC,QAAQ,GAAG,IAAI;IAE7B,IAAI8B,EAAE,CAACM,MAAM,KAAKN,EAAE,CAACO,aAAa,IAAI,EAAEP,EAAE,CAACM,MAAM,KAAK9C,WAAW,CAAC6B,OAAO,IAAIW,EAAE,CAACM,MAAM,KAAK7C,UAAU,CAAC4B,OAAO,CAAC,EAAE;MAC9G;MACA;MACApB,aAAa,CAACqB,kCAAkC,GAAGpE,cAAc,CAAC8E,EAAE,CAACQ,WAAW,CAAgB;;EAEpG,CAAC;EAED;EACA,IAAMC,sBAAsB,GAAGxE,gBAAgB,CAAC,UAACyE,uBAA2C;IAC1FxD,aAAa,CAACyD,UAAU,GAAGzD,aAAa,CAACyD,UAAW,CAACC,MAAM,CAAC,UAAAC,KAAK;MAAI,OAAA5C,aAAa,CAACE,YAAY,KAAK0C,KAAK;IAApC,CAAoC,CAAC;IAE1G,IAAI,CAAClD,GAAG,EAAE;MACR;;IAGF;IACA;IACA;IACA;IACA,IAAMmD,aAAa,GAAGnD,GAAG,CAACmD,aAA4B;IACtD,IACE,CAACpC,mBAAmB,IACpB,QAAOgC,uBAAuB,aAAvBA,uBAAuB,uBAAvBA,uBAAuB,CAAEzD,KAAK,MAAK,UAAU;IACpD;IACC9B,eAAe,CAACmC,IAAI,CAAC+B,OAAO,EAAEyB,aAAa,CAAC,IAAIA,aAAa,KAAKnD,GAAG,CAACoD,IAAI,IAAID,aAAa,CAACE,UAAU,CAAC,EACxG;MACA9B,iBAAiB,CAACwB,uBAAuB,CAAC;;EAE9C,CAAC,CAAC;EAEF;EACA,IAAMO,uBAAuB,GAAGhF,gBAAgB,CAAC,UAAC+D,EAA2B;IAC3E;IACA,IAAIxD,QAAQ,EAAE;MACZ;;IAEF,IAAIyB,aAAa,CAACE,YAAY,KAAKjB,aAAa,CAACyD,UAAW,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MACzE,IAAMC,aAAa,GAAGjG,cAAc,CAAC8E,EAAE,CAAC;MACxC,IAAImB,aAAa,IAAI,CAAChG,eAAe,CAACmC,IAAI,CAAC+B,OAAO,EAAE8B,aAAa,CAAC,EAAE;QAClE,IAAIxD,GAAG,IAAI1C,gBAAgB,CAAC0C,GAAG,CAAC,KAAKA,GAAG,CAACoD,IAAI,EAAE;UAC7CK,UAAU,CAAC;YACT,IAAIzD,GAAG,IAAI1C,gBAAgB,CAAC0C,GAAG,CAAC,KAAKA,GAAG,CAACoD,IAAI,EAAE;cAC7ChE,QAAQ,EAAE;cACVkB,aAAa,CAACC,QAAQ,GAAG,IAAI,CAAC,CAAC;;UAEnC,CAAC,EAAE,CAAC,CAAC;SACN,MAAM;UACLnB,QAAQ,EAAE;UACVkB,aAAa,CAACC,QAAQ,GAAG,IAAI,CAAC,CAAC;;QAEjC8B,EAAE,CAACqB,cAAc,EAAE;QACnBrB,EAAE,CAACsB,eAAe,EAAE;;;EAG1B,CAAC,CAAC;EAEF;EACAtG,KAAK,CAACuG,SAAS,CAAC;IACd,IAAMC,WAAW,GAAsB,EAAE;IAEzC,IAAI9E,oBAAoB,EAAE;MACxB8E,WAAW,CAACC,IAAI,CAAC7F,EAAE,CAACgC,GAAG,EAAE,OAAO,EAAEqD,uBAAuB,EAAE,IAAI,CAAC,CAAC;;IAEnE,IAAI,CAACtE,2BAA2B,EAAE;MAChC6E,WAAW,CAACC,IAAI,CAAC7F,EAAE,CAACgC,GAAG,EAAE,OAAO,EAAEqD,uBAAuB,EAAE,IAAI,CAAC,CAAC;;IAGnE,OAAO;MACLO,WAAW,CAACE,OAAO,CAAC,UAAAC,OAAO;QAAI,OAAAA,OAAO,EAAE;MAAT,CAAS,CAAC;IAC3C,CAAC;IACD;EACF,CAAC,EAAE,CAACjF,oBAAoB,EAAEC,2BAA2B,EAAEiB,GAAG,CAAC,CAAC;EAE5D;EACA5C,KAAK,CAACuG,SAAS,CAAC;IACd;IACA;IACA;IACA,IAAI/E,QAAQ,IAAK,CAACsB,aAAa,IAAI,CAACpB,oBAAqB,IAAI,CAACY,IAAI,CAAC+B,OAAO,EAAE;MAC1E;;IAGF;IACAnC,aAAa,CAACyD,UAAW,CAACc,IAAI,CAACxD,aAAa,CAACE,YAAY,CAAC;IAE1D,IAAMuC,uBAAuB,GAAG1C,KAAK,CAAC0C,uBAAuB,IAAKzF,gBAAgB,CAAC0C,GAAI,CAAwB;IAE/G,IAAI,CAAClB,iBAAiB,IAAI,CAACtB,eAAe,CAACmC,IAAI,CAAC+B,OAAO,EAAEqB,uBAAuB,CAAC,EAAE;MACjF3D,QAAQ,EAAE;;IAGZ;IACA;IACA,OAAO;MAAM,OAAA0D,sBAAsB,CAACC,uBAAuB,CAAC;IAA/C,CAA+C;IAE5D;EACF,CAAC,EAAE,CAAChE,oBAAoB,EAAEF,QAAQ,CAAC,CAAC;EAEpC;EACAxB,KAAK,CAACuG,SAAS,CAAC;IACd,IAAI,CAAC/E,QAAQ,IAAIoC,wBAAwB,EAAE;MACzC,IAAMgD,UAAU,GAAGjG,QAAQ,CAAC2B,IAAI,CAAC+B,OAAQ,CAAC;MAC1C,OAAOuC,UAAU;;EAErB,CAAC,EAAE,CAACpF,QAAQ,EAAEoC,wBAAwB,EAAEtB,IAAI,CAAC,CAAC;EAE9C;EACAnB,UAAU,CAAC;IACT;IACA,OAAO8B,aAAa,CAACqB,kCAAkC;EACzD,CAAC,CAAC;EAEF1C,eAAe,CAACC,YAAY,EAAEoB,aAAa,CAACqB,kCAAkC,EAAEvC,QAAQ,CAAC;EAEzF,OACE/B,KAAA,CAAA6G,aAAA,QAAAC,QAAA;IAAA,mBAEmB9D,KAAK,CAAC+D;EAAc,GAEjC3G,cAAc,CAAuC4C,KAAK,EAAE3C,aAAa,CAAC;IAC9EgC,GAAG,EAAEK,aAAa;IAClB2C,cAAc,EAAED,kBAAkB;IAClCH,aAAa,EAAEF;EAAiB,IAEhC/E,KAAA,CAAA6G,aAAA,QAAAC,QAAA,KAASjD,WAAW;IAAExB,GAAG,EAAEG;EAAW,GAAI,EACzCa,QAAQ,EACTrD,KAAA,CAAA6G,aAAA,QAAAC,QAAA,KAASjD,WAAW;IAAExB,GAAG,EAAEI;EAAU,GAAI,CACrC;AAEV,CAAC,CAAC;AAEFP,aAAa,CAAC8E,WAAW,GAAG1F,cAAc;AAC1CY,aAAa,CAACyD,UAAU,GAAG,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}