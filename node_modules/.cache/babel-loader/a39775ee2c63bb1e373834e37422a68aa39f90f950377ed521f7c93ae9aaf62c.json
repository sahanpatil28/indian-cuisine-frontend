{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, KeyCodes, elementContains, findScrollableParent, getParent, getDocument, getWindow, isElementTabbable, css, initializeComponentRef, FocusRects } from '../../Utilities';\nimport { SelectionMode } from './interfaces';\n// Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\nvar SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nvar SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nvar SELECTION_SPAN_ATTRIBUTE_NAME = 'data-selection-span';\nvar SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nvar SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nvar SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nvar SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nvar SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n/**\n * {@docCategory Selection}\n */\nvar SelectionZone = /** @class */function (_super) {\n  __extends(SelectionZone, _super);\n  function SelectionZone(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    /**\n     * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n     * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n     * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n     * focus event that occurs. This method does that.\n     */\n    _this.ignoreNextFocus = function () {\n      _this._handleNextFocus(false);\n    };\n    _this._onSelectionChange = function () {\n      var selection = _this.props.selection;\n      var isModal = selection.isModal && selection.isModal();\n      _this.setState({\n        isModal: isModal\n      });\n    };\n    _this._onMouseDownCapture = function (ev) {\n      var target = ev.target;\n      var win = getWindow(_this._root.current);\n      var doc = win === null || win === void 0 ? void 0 : win.document;\n      if ((doc === null || doc === void 0 ? void 0 : doc.activeElement) !== target && !elementContains(doc === null || doc === void 0 ? void 0 : doc.activeElement, target)) {\n        _this.ignoreNextFocus();\n        return;\n      }\n      if (!elementContains(target, _this._root.current)) {\n        return;\n      }\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          _this.ignoreNextFocus();\n          break;\n        }\n        target = getParent(target);\n      }\n    };\n    /**\n     * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n     * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n     * specially.\n     */\n    _this._onFocus = function (ev) {\n      var target = ev.target;\n      var selection = _this.props.selection;\n      var isToggleModifierPressed = _this._isCtrlPressed || _this._isMetaPressed;\n      var selectionMode = _this._getSelectionMode();\n      if (_this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n        var isToggle = _this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n        var itemRoot = _this._findItemRoot(target);\n        if (!isToggle && itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n          var span = _this._getItemSpan(itemRoot);\n          if (span === undefined) {\n            if (isToggleModifierPressed) {\n              // set anchor only.\n              selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n              if (_this.props.enterModalOnTouch && _this._isTouch && selection.setModal) {\n                selection.setModal(true);\n                _this._setIsTouch(false);\n              }\n            } else {\n              if (_this.props.isSelectedOnFocus) {\n                _this._onItemSurfaceClick('focus', index);\n              }\n            }\n          }\n        }\n      }\n      _this._handleNextFocus(false);\n    };\n    _this._onMouseDown = function (ev) {\n      _this._updateModifiers(ev);\n      var toggleWithoutModifierPressed = _this.props.toggleWithoutModifierPressed;\n      var target = ev.target;\n      var itemRoot = _this._findItemRoot(target);\n      // No-op if selection is disabled\n      if (_this._isSelectionDisabled(target)) {\n        return;\n      }\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n          break;\n        } else if (itemRoot) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            break;\n          } else if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            break;\n          } else if ((target === itemRoot || _this._shouldAutoSelect(target)) && !_this._isShiftPressed && !_this._isCtrlPressed && !_this._isMetaPressed && !toggleWithoutModifierPressed) {\n            _this._onInvokeMouseDown(ev, _this._getItemIndex(itemRoot), _this._getItemSpan(itemRoot));\n            break;\n          } else if (_this.props.disableAutoSelectOnInputElements && (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')) {\n            return;\n          }\n        }\n        target = getParent(target);\n      }\n    };\n    _this._onTouchStartCapture = function (ev) {\n      _this._setIsTouch(true);\n    };\n    _this._onClick = function (ev) {\n      var _a = _this.props.enableTouchInvocationTarget,\n        enableTouchInvocationTarget = _a === void 0 ? false : _a;\n      _this._updateModifiers(ev);\n      var target = ev.target;\n      var itemRoot = _this._findItemRoot(target);\n      var isSelectionDisabled = _this._isSelectionDisabled(target);\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            _this._onToggleAllClick(ev);\n          }\n          break;\n        } else if (itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n          var span = _this._getItemSpan(itemRoot);\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            if (!isSelectionDisabled) {\n              if (_this._isShiftPressed) {\n                _this._onItemSurfaceClick('click', index, span);\n              } else {\n                _this._onToggleClick(ev, index, span);\n              }\n            }\n            break;\n          } else if (_this._isTouch && enableTouchInvocationTarget && _this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            if (span === undefined) {\n              // Items should be invokable even if selection is disabled.\n              _this._onInvokeClick(ev, index);\n            }\n            break;\n          } else if (target === itemRoot) {\n            if (!isSelectionDisabled) {\n              _this._onItemSurfaceClick('click', index, span);\n            }\n            break;\n          } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n            return;\n          }\n        }\n        target = getParent(target);\n      }\n    };\n    _this._onContextMenu = function (ev) {\n      var target = ev.target;\n      var _a = _this.props,\n        onItemContextMenu = _a.onItemContextMenu,\n        selection = _a.selection;\n      if (onItemContextMenu) {\n        var itemRoot = _this._findItemRoot(target);\n        if (itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n          _this._onInvokeMouseDown(ev, index);\n          var skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);\n          // In order to keep back compat, if the value here is undefined, then we should still\n          // call preventDefault(). Only in the case where true is explicitly returned should\n          // the call be skipped.\n          if (!skipPreventDefault) {\n            ev.preventDefault();\n          }\n        }\n      }\n    };\n    /**\n     * In multi selection, if you double click within an item's root (but not within the invoke element or\n     * input elements), we should execute the invoke handler.\n     */\n    _this._onDoubleClick = function (ev) {\n      var target = ev.target;\n      var onItemInvoked = _this.props.onItemInvoked;\n      var itemRoot = _this._findItemRoot(target);\n      if (itemRoot && onItemInvoked && !_this._isInputElement(target)) {\n        var index = _this._getItemIndex(itemRoot);\n        while (target !== _this._root.current) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            break;\n          } else if (target === itemRoot) {\n            _this._onInvokeClick(ev, index);\n            break;\n          }\n          target = getParent(target);\n        }\n        target = getParent(target);\n      }\n    };\n    _this._onKeyDownCapture = function (ev) {\n      _this._updateModifiers(ev);\n      _this._handleNextFocus(true);\n    };\n    _this._onKeyDown = function (ev) {\n      _this._updateModifiers(ev);\n      var target = ev.target;\n      var isSelectionDisabled = _this._isSelectionDisabled(target);\n      var _a = _this.props,\n        selection = _a.selection,\n        selectionClearedOnEscapePress = _a.selectionClearedOnEscapePress;\n      // eslint-disable-next-line deprecation/deprecation\n      var isSelectAllKey = ev.which === KeyCodes.a && (_this._isCtrlPressed || _this._isMetaPressed);\n      // eslint-disable-next-line deprecation/deprecation\n      var isClearSelectionKey = ev.which === KeyCodes.escape;\n      // Ignore key downs from input elements.\n      if (_this._isInputElement(target)) {\n        // A key was pressed while an item in this zone was focused.\n        return;\n      }\n      var selectionMode = _this._getSelectionMode();\n      // If ctrl-a is pressed, select all (if all are not already selected.)\n      if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n        if (!isSelectionDisabled) {\n          selection.setAllSelected(true);\n        }\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      }\n      // If escape is pressed and the component is configured to clear on escape press,\n      // clear selection (if any are selected.)\n      if (selectionClearedOnEscapePress && isClearSelectionKey && selection.getSelectedCount() > 0) {\n        if (!isSelectionDisabled) {\n          selection.setAllSelected(false);\n        }\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      }\n      var itemRoot = _this._findItemRoot(target);\n      // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n      if (itemRoot) {\n        var index = _this._getItemIndex(itemRoot);\n        var span = _this._getItemSpan(itemRoot);\n        while (target !== _this._root.current) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n            // so we can no-op for any keydowns in this case.\n            break;\n          } else if (_this._shouldAutoSelect(target)) {\n            if (!isSelectionDisabled && span === undefined) {\n              // If the event went to an element which should trigger auto-select, select it and then let\n              // the default behavior kick in.\n              _this._onInvokeMouseDown(ev, index, span);\n            }\n            break;\n          } else if (\n          // eslint-disable-next-line deprecation/deprecation\n          (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) && (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'SUMMARY')) {\n            return false;\n          } else if (target === itemRoot) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (ev.which === KeyCodes.enter) {\n              if (span === undefined) {\n                // Items should be invokable even if selection is disabled.\n                _this._onInvokeClick(ev, index);\n                ev.preventDefault();\n              }\n              return;\n              // eslint-disable-next-line deprecation/deprecation\n            } else if (ev.which === KeyCodes.space) {\n              if (!isSelectionDisabled) {\n                _this._onToggleClick(ev, index, span);\n              }\n              ev.preventDefault();\n              return;\n            }\n            break;\n          }\n          target = getParent(target);\n        }\n      }\n    };\n    _this._events = new EventGroup(_this);\n    _this._async = new Async(_this);\n    initializeComponentRef(_this);\n    var selection = _this.props.selection;\n    // Reflect the initial modal state of selection into the state.\n    var isModal = selection.isModal && selection.isModal();\n    _this.state = {\n      isModal: isModal\n    };\n    return _this;\n  }\n  SelectionZone.getDerivedStateFromProps = function (nextProps, prevState) {\n    var isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n    return __assign(__assign({}, prevState), {\n      isModal: isModal\n    });\n  };\n  SelectionZone.prototype.componentDidMount = function () {\n    var win = getWindow(this._root.current);\n    var doc = win === null || win === void 0 ? void 0 : win.document;\n    // Track the latest modifier keys globally.\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n    this._events.on(doc, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(doc === null || doc === void 0 ? void 0 : doc.body, 'touchstart', this._onTouchStartCapture, true);\n    this._events.on(doc === null || doc === void 0 ? void 0 : doc.body, 'touchend', this._onTouchStartCapture, true);\n    // Subscribe to the selection to keep modal state updated.\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  };\n  SelectionZone.prototype.render = function () {\n    var isModal = this.state.isModal;\n    return React.createElement(\"div\", {\n      className: css('ms-SelectionZone', this.props.className, {\n        'ms-SelectionZone--modal': !!isModal\n      }),\n      ref: this._root,\n      onKeyDown: this._onKeyDown,\n      onMouseDown: this._onMouseDown,\n      onKeyDownCapture: this._onKeyDownCapture,\n      onClick: this._onClick,\n      role: \"presentation\",\n      onDoubleClick: this._onDoubleClick,\n      onContextMenu: this._onContextMenu,\n      onMouseDownCapture: this._onMouseDownCapture,\n      onFocusCapture: this._onFocus,\n      \"data-selection-is-modal\": isModal ? true : undefined\n    }, this.props.children, React.createElement(FocusRects, null));\n  };\n  SelectionZone.prototype.componentDidUpdate = function (previousProps) {\n    var selection = this.props.selection;\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  };\n  SelectionZone.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n    this._async.dispose();\n  };\n  SelectionZone.prototype._isSelectionDisabled = function (target) {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n      target = getParent(target);\n    }\n    return false;\n  };\n  SelectionZone.prototype._onToggleAllClick = function (ev) {\n    var selection = this.props.selection;\n    var selectionMode = this._getSelectionMode();\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  };\n  SelectionZone.prototype._onToggleClick = function (ev, index, span) {\n    var selection = this.props.selection;\n    var selectionMode = this._getSelectionMode();\n    selection.setChangeEvents(false);\n    if (this.props.enterModalOnTouch && this._isTouch && (span !== undefined ? !selection.isRangeSelected(index, span) : !selection.isIndexSelected(index)) && selection.setModal) {\n      selection.setModal(true);\n      this._setIsTouch(false);\n    }\n    if (selectionMode === SelectionMode.multiple) {\n      if (span !== undefined) {\n        selection.toggleRangeSelected(index, span);\n      } else {\n        selection.toggleIndexSelected(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      if (span === undefined || span === 1) {\n        var isSelected = selection.isIndexSelected(index);\n        var isModal = selection.isModal && selection.isModal();\n        selection.setAllSelected(false);\n        selection.setIndexSelected(index, !isSelected, true);\n        if (isModal && selection.setModal) {\n          // Since the above call to setAllSelected(false) clears modal state,\n          // restore it. This occurs because the SelectionMode of the Selection\n          // may differ from the SelectionZone.\n          selection.setModal(true);\n        }\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n    selection.setChangeEvents(true);\n    ev.stopPropagation();\n    // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  };\n  SelectionZone.prototype._onInvokeClick = function (ev, index) {\n    var _a = this.props,\n      selection = _a.selection,\n      onItemInvoked = _a.onItemInvoked;\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n  SelectionZone.prototype._onItemSurfaceClick = function (type, index, span) {\n    var _a;\n    var _b = this.props,\n      selection = _b.selection,\n      toggleWithoutModifierPressed = _b.toggleWithoutModifierPressed;\n    var isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n    var selectionMode = this._getSelectionMode();\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        if (span !== undefined) {\n          (_a = selection.selectToRange) === null || _a === void 0 ? void 0 : _a.call(selection, index, span, !isToggleModifierPressed);\n        } else {\n          selection.selectToIndex(index, !isToggleModifierPressed);\n        }\n      } else if (type === 'click' && (isToggleModifierPressed || toggleWithoutModifierPressed)) {\n        if (span !== undefined) {\n          selection.toggleRangeSelected(index, span);\n        } else {\n          selection.toggleIndexSelected(index);\n        }\n      } else {\n        this._clearAndSelectIndex(index, span);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index, span);\n    }\n  };\n  SelectionZone.prototype._onInvokeMouseDown = function (ev, index, span) {\n    var selection = this.props.selection;\n    if (span !== undefined) {\n      if (selection.isRangeSelected(index, span)) {\n        return;\n      }\n    } else {\n      // Only do work if item is not selected.\n      if (selection.isIndexSelected(index)) {\n        return;\n      }\n    }\n    this._clearAndSelectIndex(index, span);\n  };\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n  SelectionZone.prototype._findScrollParentAndTryClearOnEmptyClick = function (ev) {\n    var win = getWindow(this._root.current);\n    var doc = win === null || win === void 0 ? void 0 : win.document;\n    var scrollParent = findScrollableParent(this._root.current);\n    // unbind this handler and replace binding with a binding on the actual scrollable parent\n    this._events.off(doc, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick);\n    // If we clicked inside the scrollable parent, call through to the handler on this click.\n    if (scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  };\n  SelectionZone.prototype._tryClearOnEmptyClick = function (ev) {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target)) {\n      this.props.selection.setAllSelected(false);\n    }\n  };\n  SelectionZone.prototype._clearAndSelectIndex = function (index, span) {\n    var _a;\n    var _b = this.props,\n      selection = _b.selection,\n      _c = _b.selectionClearedOnSurfaceClick,\n      selectionClearedOnSurfaceClick = _c === void 0 ? true : _c;\n    var isAlreadySingleSelected = (span === undefined || span === 1) && selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n    if (!isAlreadySingleSelected && selectionClearedOnSurfaceClick) {\n      var isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      if (span !== undefined) {\n        (_a = selection.setRangeSelected) === null || _a === void 0 ? void 0 : _a.call(selection, index, span, true, true);\n      } else {\n        selection.setIndexSelected(index, true, true);\n      }\n      if (isModal || this.props.enterModalOnTouch && this._isTouch) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n      selection.setChangeEvents(true);\n    }\n  };\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n  SelectionZone.prototype._updateModifiers = function (ev) {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey;\n    // eslint-disable-next-line deprecation/deprecation\n    var keyCode = ev.keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  };\n  SelectionZone.prototype._findItemRoot = function (target) {\n    var selection = this.props.selection;\n    while (target !== this._root.current) {\n      var indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      var index = Number(indexValue);\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n      target = getParent(target);\n    }\n    if (target === this._root.current) {\n      return undefined;\n    }\n    return target;\n  };\n  SelectionZone.prototype._getItemIndex = function (itemRoot) {\n    var _a;\n    var indexValue = parseInt((_a = itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME)) !== null && _a !== void 0 ? _a : '', 10);\n    return isNaN(indexValue) ? -1 : indexValue;\n  };\n  SelectionZone.prototype._getItemSpan = function (itemRoot) {\n    var _a;\n    var spanValue = parseInt((_a = itemRoot.getAttribute(SELECTION_SPAN_ATTRIBUTE_NAME)) !== null && _a !== void 0 ? _a : '', 10);\n    return isNaN(spanValue) ? undefined : spanValue;\n  };\n  SelectionZone.prototype._shouldAutoSelect = function (element) {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  };\n  SelectionZone.prototype._hasAttribute = function (element, attributeName) {\n    var isToggle = false;\n    while (!isToggle && element !== this._root.current) {\n      var value = element.getAttribute(attributeName);\n      if (value === 'false') {\n        isToggle = false;\n        break;\n      }\n      isToggle = value === 'true';\n      element = getParent(element);\n    }\n    return isToggle;\n  };\n  SelectionZone.prototype._isInputElement = function (element) {\n    return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.getAttribute('contenteditable') === 'true' || element.getAttribute('contenteditable') === '';\n  };\n  SelectionZone.prototype._isNonHandledClick = function (element) {\n    var doc = getDocument();\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element) || element.hasAttribute('data-selection-index')) {\n          return false;\n        }\n        element = getParent(element);\n      }\n    }\n    return true;\n  };\n  SelectionZone.prototype._handleNextFocus = function (handleFocus) {\n    var _this = this;\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n    this._shouldHandleFocus = handleFocus;\n    if (handleFocus) {\n      this._async.setTimeout(function () {\n        _this._shouldHandleFocus = false;\n      }, 100);\n    }\n  };\n  SelectionZone.prototype._setIsTouch = function (isTouch) {\n    var _this = this;\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n      this._isTouchTimeoutId = undefined;\n    }\n    this._isTouch = true;\n    if (isTouch) {\n      this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 300);\n    }\n  };\n  SelectionZone.prototype._getSelectionMode = function () {\n    var selection = this.props.selection;\n    var _a = this.props.selectionMode,\n      selectionMode = _a === void 0 ? selection ? selection.mode : SelectionMode.none : _a;\n    return selectionMode;\n  };\n  SelectionZone.defaultProps = {\n    isSelectedOnFocus: true,\n    toggleWithoutModifierPressed: false,\n    selectionMode: SelectionMode.multiple,\n    selectionClearedOnEscapePress: true\n  };\n  return SelectionZone;\n}(React.Component);\nexport { SelectionZone };","map":{"version":3,"names":["React","Async","EventGroup","KeyCodes","elementContains","findScrollableParent","getParent","getDocument","getWindow","isElementTabbable","css","initializeComponentRef","FocusRects","SelectionMode","SELECTION_DISABLED_ATTRIBUTE_NAME","SELECTION_INDEX_ATTRIBUTE_NAME","SELECTION_SPAN_ATTRIBUTE_NAME","SELECTION_TOGGLE_ATTRIBUTE_NAME","SELECTION_INVOKE_ATTRIBUTE_NAME","SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME","SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME","SELECTION_SELECT_ATTRIBUTE_NAME","SelectionZone","_super","__extends","props","_this","call","_root","createRef","ignoreNextFocus","_handleNextFocus","_onSelectionChange","selection","isModal","setState","_onMouseDownCapture","ev","target","win","current","doc","document","activeElement","_hasAttribute","_onFocus","isToggleModifierPressed","_isCtrlPressed","_isMetaPressed","selectionMode","_getSelectionMode","_shouldHandleFocus","none","isToggle","itemRoot","_findItemRoot","index","_getItemIndex","span","_getItemSpan","undefined","setIndexSelected","isIndexSelected","enterModalOnTouch","_isTouch","setModal","_setIsTouch","isSelectedOnFocus","_onItemSurfaceClick","_onMouseDown","_updateModifiers","toggleWithoutModifierPressed","_isSelectionDisabled","_shouldAutoSelect","_isShiftPressed","_onInvokeMouseDown","disableAutoSelectOnInputElements","tagName","_onTouchStartCapture","_onClick","_a","enableTouchInvocationTarget","isSelectionDisabled","_onToggleAllClick","_onToggleClick","_onInvokeClick","_onContextMenu","onItemContextMenu","skipPreventDefault","getItems","nativeEvent","preventDefault","_onDoubleClick","onItemInvoked","_isInputElement","_onKeyDownCapture","_onKeyDown","selectionClearedOnEscapePress","isSelectAllKey","which","a","isClearSelectionKey","escape","multiple","isAllSelected","setAllSelected","stopPropagation","getSelectedCount","enter","space","_events","_async","state","getDerivedStateFromProps","nextProps","prevState","__assign","prototype","componentDidMount","on","_findScrollParentAndTryClearOnEmptyClick","body","render","createElement","className","ref","onKeyDown","onMouseDown","onKeyDownCapture","onClick","role","onDoubleClick","onContextMenu","onMouseDownCapture","onFocusCapture","children","componentDidUpdate","previousProps","off","componentWillUnmount","dispose","toggleAllSelected","setChangeEvents","isRangeSelected","toggleRangeSelected","toggleIndexSelected","single","isSelected","type","_b","_isTabPressed","selectToRange","selectToIndex","_clearAndSelectIndex","scrollParent","_tryClearOnEmptyClick","Node","contains","selectionPreservedOnEmptyClick","_isNonHandledClick","_c","selectionClearedOnSurfaceClick","isAlreadySingleSelected","setRangeSelected","shiftKey","ctrlKey","metaKey","keyCode","tab","indexValue","getAttribute","Number","length","parseInt","isNaN","spanValue","element","attributeName","value","documentElement","hasAttribute","handleFocus","_shouldHandleFocusTimeoutId","clearTimeout","setTimeout","isTouch","_isTouchTimeoutId","mode","defaultProps","Component"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\utilities\\src\\utilities\\selection\\SelectionZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  KeyCodes,\n  elementContains,\n  findScrollableParent,\n  getParent,\n  getDocument,\n  getWindow,\n  isElementTabbable,\n  css,\n  initializeComponentRef,\n  FocusRects,\n} from '../../Utilities';\nimport { SelectionMode } from './interfaces';\nimport type { ISelection, IObjectWithKey } from './interfaces';\n\n// Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\n\nconst SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nconst SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nconst SELECTION_SPAN_ATTRIBUTE_NAME = 'data-selection-span';\nconst SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nconst SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nconst SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nconst SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nconst SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZone {\n  /**\n   * Method to ignore subsequent focus.\n   */\n  ignoreNextFocus: () => void;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneProps extends React.ClassAttributes<SelectionZone> {\n  children?: React.ReactNode;\n  /**\n   * Reference to the component interface.\n   */\n  componentRef?: () => void;\n  /**\n   * Required {@link ISelection} instance bound to the {@link SelectionZone}.\n   */\n  selection: ISelection;\n  /**\n   * @deprecated No longer in use, focus is now managed by {@link FocusZone}.\n   */\n  layout?: {};\n  /**\n   * The mode of Selection, where the value is one of\n   * 'none', 'single', or 'multiple'.\n   *\n   * @defaultvalue {@link SelectionMode.multiple}\n   */\n  selectionMode?: SelectionMode;\n  /**\n   * If true, selection is preserved on outer click.\n   */\n  selectionPreservedOnEmptyClick?: boolean;\n  /**\n   * If true, disables automatic selection on input elements.\n   */\n  disableAutoSelectOnInputElements?: boolean;\n  /**\n   * If true, modal selection is enabled on touch event.\n   */\n  enterModalOnTouch?: boolean;\n  /**\n   * Determines whether elements with the attribute `data-selection-touch-invoke` should be used as invocation targets\n   * for an item if the user is using touch.\n   *\n   * @defaultvalue false\n   */\n  enableTouchInvocationTarget?: boolean;\n  /**\n   * Determines if an item is selected on focus.\n   *\n   * @defaultvalue true\n   */\n  isSelectedOnFocus?: boolean;\n  /**\n   * Determines if elements within the selection zone that DO NOT have the 'data-selection-toggle' or\n   * 'data-selection-all-toggle' attribute are clickable and can alter the selection.\n   *\n   * @defaultvalue true\n   */\n  selectionClearedOnSurfaceClick?: boolean;\n\n  /**\n   * Determines if pressing the Escape clears the selection.\n   *\n   * @defaultvalue true\n   */\n  selectionClearedOnEscapePress?: boolean;\n\n  /**\n   * Allows the default toggle behavior to be overridden.\n   * When set to `true` users do not have press a modifier key (e.g., ctrl or meta)\n   * to toggle values.\n   *\n   * @default false\n   */\n  toggleWithoutModifierPressed?: boolean;\n\n  /**\n   * Optional callback for when an item is\n   * invoked via ENTER or double-click.\n   */\n  onItemInvoked?: (item?: IObjectWithKey, index?: number, ev?: Event) => void;\n  /**\n   * Optional callback for when an\n   * item's contextual menu action occurs.\n   */\n  onItemContextMenu?: (item?: any, index?: number, ev?: Event) => void | boolean;\n  /**\n   * Additional CSS class(es) to apply to the SelectionZone.\n   */\n  className?: string;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneState {\n  isModal: boolean | undefined;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport class SelectionZone extends React.Component<ISelectionZoneProps, ISelectionZoneState> {\n  public static defaultProps = {\n    isSelectedOnFocus: true,\n    toggleWithoutModifierPressed: false,\n    selectionMode: SelectionMode.multiple,\n    selectionClearedOnEscapePress: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _isCtrlPressed: boolean;\n  private _isShiftPressed: boolean;\n  private _isMetaPressed: boolean;\n  private _isTabPressed: boolean;\n  private _shouldHandleFocus: boolean;\n  private _shouldHandleFocusTimeoutId: number | undefined;\n  private _isTouch: boolean;\n  private _isTouchTimeoutId: number | undefined;\n\n  public static getDerivedStateFromProps(\n    nextProps: ISelectionZoneProps,\n    prevState: ISelectionZoneState,\n  ): ISelectionZoneState {\n    const isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n\n    return {\n      ...prevState,\n      isModal,\n    };\n  }\n\n  constructor(props: ISelectionZoneProps) {\n    super(props);\n\n    this._events = new EventGroup(this);\n    this._async = new Async(this);\n    initializeComponentRef(this);\n\n    const { selection } = this.props;\n\n    // Reflect the initial modal state of selection into the state.\n    const isModal = selection.isModal && selection.isModal();\n\n    this.state = {\n      isModal,\n    };\n  }\n\n  public componentDidMount(): void {\n    const win = getWindow(this._root.current);\n    const doc = win?.document;\n\n    // Track the latest modifier keys globally.\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n    this._events.on(doc, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(doc?.body, 'touchstart', this._onTouchStartCapture, true);\n    this._events.on(doc?.body, 'touchend', this._onTouchStartCapture, true);\n\n    // Subscribe to the selection to keep modal state updated.\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  }\n\n  public render(): JSX.Element {\n    const { isModal } = this.state;\n\n    return (\n      <div\n        className={css('ms-SelectionZone', this.props.className, {\n          'ms-SelectionZone--modal': !!isModal,\n        })}\n        ref={this._root}\n        onKeyDown={this._onKeyDown}\n        onMouseDown={this._onMouseDown}\n        onKeyDownCapture={this._onKeyDownCapture}\n        onClick={this._onClick}\n        role=\"presentation\"\n        onDoubleClick={this._onDoubleClick}\n        onContextMenu={this._onContextMenu}\n        onMouseDownCapture={this._onMouseDownCapture}\n        onFocusCapture={this._onFocus}\n        data-selection-is-modal={isModal ? true : undefined}\n      >\n        {this.props.children}\n        <FocusRects />\n      </div>\n    );\n  }\n\n  public componentDidUpdate(previousProps: ISelectionZoneProps): void {\n    const { selection } = this.props;\n\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  /**\n   * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n   * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n   * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n   * focus event that occurs. This method does that.\n   */\n  public ignoreNextFocus = (): void => {\n    this._handleNextFocus(false);\n  };\n\n  private _onSelectionChange = (): void => {\n    const { selection } = this.props;\n\n    const isModal = selection.isModal && selection.isModal();\n\n    this.setState({\n      isModal,\n    });\n  };\n\n  private _onMouseDownCapture = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n    const win = getWindow(this._root.current);\n    const doc = win?.document;\n\n    if (doc?.activeElement !== target && !elementContains(doc?.activeElement as HTMLElement, target)) {\n      this.ignoreNextFocus();\n      return;\n    }\n\n    if (!elementContains(target, this._root.current)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n        this.ignoreNextFocus();\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  /**\n   * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n   * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n   * specially.\n   */\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n    const { selection } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n      const isToggle = this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n      const itemRoot = this._findItemRoot(target);\n\n      if (!isToggle && itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n        const span = this._getItemSpan(itemRoot);\n\n        if (span === undefined) {\n          if (isToggleModifierPressed) {\n            // set anchor only.\n            selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n            if (this.props.enterModalOnTouch && this._isTouch && selection.setModal) {\n              selection.setModal(true);\n              this._setIsTouch(false);\n            }\n          } else {\n            if (this.props.isSelectedOnFocus) {\n              this._onItemSurfaceClick('focus', index);\n            }\n          }\n        }\n      }\n    }\n\n    this._handleNextFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    const { toggleWithoutModifierPressed } = this.props;\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    // No-op if selection is disabled\n    if (this._isSelectionDisabled(target)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        break;\n      } else if (itemRoot) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (\n          (target === itemRoot || this._shouldAutoSelect(target)) &&\n          !this._isShiftPressed &&\n          !this._isCtrlPressed &&\n          !this._isMetaPressed &&\n          !toggleWithoutModifierPressed\n        ) {\n          this._onInvokeMouseDown(ev, this._getItemIndex(itemRoot), this._getItemSpan(itemRoot));\n\n          break;\n        } else if (\n          this.props.disableAutoSelectOnInputElements &&\n          (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')\n        ) {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onTouchStartCapture = (ev: React.TouchEvent<HTMLElement>): void => {\n    this._setIsTouch(true);\n  };\n\n  private _onClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { enableTouchInvocationTarget = false } = this.props;\n\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        if (!isSelectionDisabled) {\n          this._onToggleAllClick(ev);\n        }\n        break;\n      } else if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n        const span = this._getItemSpan(itemRoot);\n\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            if (this._isShiftPressed) {\n              this._onItemSurfaceClick('click', index, span);\n            } else {\n              this._onToggleClick(ev, index, span);\n            }\n          }\n          break;\n        } else if (\n          (this._isTouch &&\n            enableTouchInvocationTarget &&\n            this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME)) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          if (span === undefined) {\n            // Items should be invokable even if selection is disabled.\n            this._onInvokeClick(ev, index);\n          }\n          break;\n        } else if (target === itemRoot) {\n          if (!isSelectionDisabled) {\n            this._onItemSurfaceClick('click', index, span);\n          }\n          break;\n        } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onContextMenu = (ev: React.MouseEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n\n    const { onItemContextMenu, selection } = this.props;\n    if (onItemContextMenu) {\n      const itemRoot = this._findItemRoot(target);\n\n      if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n\n        this._onInvokeMouseDown(ev, index);\n\n        const skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);\n\n        // In order to keep back compat, if the value here is undefined, then we should still\n        // call preventDefault(). Only in the case where true is explicitly returned should\n        // the call be skipped.\n        if (!skipPreventDefault) {\n          ev.preventDefault();\n        }\n      }\n    }\n  };\n\n  private _isSelectionDisabled(target: HTMLElement): boolean {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n      target = getParent(target) as HTMLElement;\n    }\n\n    return false;\n  }\n\n  /**\n   * In multi selection, if you double click within an item's root (but not within the invoke element or\n   * input elements), we should execute the invoke handler.\n   */\n  private _onDoubleClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    const { onItemInvoked } = this.props;\n    const itemRoot = this._findItemRoot(target);\n\n    if (itemRoot && onItemInvoked && !this._isInputElement(target)) {\n      const index = this._getItemIndex(itemRoot);\n\n      while (target !== this._root.current) {\n        if (\n          this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          break;\n        } else if (target === itemRoot) {\n          this._onInvokeClick(ev, index);\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onKeyDownCapture = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    this._handleNextFocus(true);\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    const { selection, selectionClearedOnEscapePress } = this.props;\n    // eslint-disable-next-line deprecation/deprecation\n    const isSelectAllKey = ev.which === KeyCodes.a && (this._isCtrlPressed || this._isMetaPressed);\n    // eslint-disable-next-line deprecation/deprecation\n    const isClearSelectionKey = ev.which === KeyCodes.escape;\n\n    // Ignore key downs from input elements.\n    if (this._isInputElement(target)) {\n      // A key was pressed while an item in this zone was focused.\n      return;\n    }\n\n    const selectionMode = this._getSelectionMode();\n\n    // If ctrl-a is pressed, select all (if all are not already selected.)\n    if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(true);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    // If escape is pressed and the component is configured to clear on escape press,\n    // clear selection (if any are selected.)\n    if (selectionClearedOnEscapePress && isClearSelectionKey && selection.getSelectedCount() > 0) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(false);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    const itemRoot = this._findItemRoot(target);\n\n    // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n    if (itemRoot) {\n      const index = this._getItemIndex(itemRoot);\n      const span = this._getItemSpan(itemRoot);\n\n      while (target !== this._root.current) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n          // so we can no-op for any keydowns in this case.\n          break;\n        } else if (this._shouldAutoSelect(target)) {\n          if (!isSelectionDisabled && span === undefined) {\n            // If the event went to an element which should trigger auto-select, select it and then let\n            // the default behavior kick in.\n            this._onInvokeMouseDown(ev, index, span);\n          }\n          break;\n        } else if (\n          // eslint-disable-next-line deprecation/deprecation\n          (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) &&\n          (target.tagName === 'BUTTON' ||\n            target.tagName === 'A' ||\n            target.tagName === 'INPUT' ||\n            target.tagName === 'SUMMARY')\n        ) {\n          return false;\n        } else if (target === itemRoot) {\n          // eslint-disable-next-line deprecation/deprecation\n          if (ev.which === KeyCodes.enter) {\n            if (span === undefined) {\n              // Items should be invokable even if selection is disabled.\n              this._onInvokeClick(ev, index);\n              ev.preventDefault();\n            }\n            return;\n            // eslint-disable-next-line deprecation/deprecation\n          } else if (ev.which === KeyCodes.space) {\n            if (!isSelectionDisabled) {\n              this._onToggleClick(ev, index, span);\n            }\n            ev.preventDefault();\n            return;\n          }\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n    }\n  };\n\n  private _onToggleAllClick(ev: React.MouseEvent<HTMLElement>): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  }\n\n  private _onToggleClick(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n    span?: number,\n  ): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    selection.setChangeEvents(false);\n\n    if (\n      this.props.enterModalOnTouch &&\n      this._isTouch &&\n      (span !== undefined ? !selection.isRangeSelected(index, span) : !selection.isIndexSelected(index)) &&\n      selection.setModal\n    ) {\n      selection.setModal(true);\n      this._setIsTouch(false);\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (span !== undefined) {\n        selection.toggleRangeSelected(index, span);\n      } else {\n        selection.toggleIndexSelected(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      if (span === undefined || span === 1) {\n        const isSelected = selection.isIndexSelected(index);\n        const isModal = selection.isModal && selection.isModal();\n        selection.setAllSelected(false);\n        selection.setIndexSelected(index, !isSelected, true);\n        if (isModal && selection.setModal) {\n          // Since the above call to setAllSelected(false) clears modal state,\n          // restore it. This occurs because the SelectionMode of the Selection\n          // may differ from the SelectionZone.\n          selection.setModal(true);\n        }\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n\n    selection.setChangeEvents(true);\n\n    ev.stopPropagation();\n\n    // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  }\n\n  private _onInvokeClick(ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, index: number): void {\n    const { selection, onItemInvoked } = this.props;\n\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _onItemSurfaceClick(type: 'focus' | 'click', index: number, span?: number): void {\n    const { selection, toggleWithoutModifierPressed } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        if (span !== undefined) {\n          selection.selectToRange?.(index, span, !isToggleModifierPressed);\n        } else {\n          selection.selectToIndex(index, !isToggleModifierPressed);\n        }\n      } else if (type === 'click' && (isToggleModifierPressed || toggleWithoutModifierPressed)) {\n        if (span !== undefined) {\n          selection.toggleRangeSelected(index, span);\n        } else {\n          selection.toggleIndexSelected(index);\n        }\n      } else {\n        this._clearAndSelectIndex(index, span);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index, span);\n    }\n  }\n\n  private _onInvokeMouseDown(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n    span?: number,\n  ): void {\n    const { selection } = this.props;\n\n    if (span !== undefined) {\n      if (selection.isRangeSelected(index, span)) {\n        return;\n      }\n    } else {\n      // Only do work if item is not selected.\n      if (selection.isIndexSelected(index)) {\n        return;\n      }\n    }\n\n    this._clearAndSelectIndex(index, span);\n  }\n\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n  private _findScrollParentAndTryClearOnEmptyClick(ev: MouseEvent) {\n    const win = getWindow(this._root.current);\n    const doc = win?.document;\n    const scrollParent = findScrollableParent(this._root.current) as HTMLElement;\n    // unbind this handler and replace binding with a binding on the actual scrollable parent\n    this._events.off(doc, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick);\n\n    // If we clicked inside the scrollable parent, call through to the handler on this click.\n    if ((scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target)) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  }\n\n  private _tryClearOnEmptyClick(ev: MouseEvent): void {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target as HTMLElement)) {\n      this.props.selection.setAllSelected(false);\n    }\n  }\n\n  private _clearAndSelectIndex(index: number, span?: number): void {\n    const { selection, selectionClearedOnSurfaceClick = true } = this.props;\n    const isAlreadySingleSelected =\n      (span === undefined || span === 1) && selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n\n    if (!isAlreadySingleSelected && selectionClearedOnSurfaceClick) {\n      const isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      if (span !== undefined) {\n        selection.setRangeSelected?.(index, span, true, true);\n      } else {\n        selection.setIndexSelected(index, true, true);\n      }\n      if (isModal || (this.props.enterModalOnTouch && this._isTouch)) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n      selection.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n  private _updateModifiers(ev: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey;\n\n    // eslint-disable-next-line deprecation/deprecation\n    const keyCode = (ev as React.KeyboardEvent<HTMLElement>).keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  }\n\n  private _findItemRoot(target: HTMLElement): HTMLElement | undefined {\n    const { selection } = this.props;\n\n    while (target !== this._root.current) {\n      const indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      const index = Number(indexValue);\n\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n\n    if (target === this._root.current) {\n      return undefined;\n    }\n\n    return target;\n  }\n\n  private _getItemIndex(itemRoot: HTMLElement): number {\n    const indexValue = parseInt(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME) ?? '', 10);\n\n    return isNaN(indexValue) ? -1 : indexValue;\n  }\n\n  private _getItemSpan(itemRoot: HTMLElement): number | undefined {\n    const spanValue = parseInt(itemRoot.getAttribute(SELECTION_SPAN_ATTRIBUTE_NAME) ?? '', 10);\n\n    return isNaN(spanValue) ? undefined : spanValue;\n  }\n\n  private _shouldAutoSelect(element: HTMLElement): boolean {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  }\n\n  private _hasAttribute(element: HTMLElement, attributeName: string): boolean {\n    let isToggle = false;\n\n    while (!isToggle && element !== this._root.current) {\n      const value = element.getAttribute(attributeName);\n      if (value === 'false') {\n        isToggle = false;\n        break;\n      }\n      isToggle = value === 'true';\n      element = getParent(element) as HTMLElement;\n    }\n\n    return isToggle;\n  }\n\n  private _isInputElement(element: HTMLElement): boolean {\n    return (\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.getAttribute('contenteditable') === 'true' ||\n      element.getAttribute('contenteditable') === ''\n    );\n  }\n\n  private _isNonHandledClick(element: HTMLElement): boolean {\n    const doc = getDocument();\n\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element) || element.hasAttribute('data-selection-index')) {\n          return false;\n        }\n\n        element = getParent(element) as HTMLElement;\n      }\n    }\n\n    return true;\n  }\n\n  private _handleNextFocus(handleFocus: boolean): void {\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n\n    this._shouldHandleFocus = handleFocus;\n\n    if (handleFocus) {\n      this._async.setTimeout(() => {\n        this._shouldHandleFocus = false;\n      }, 100);\n    }\n  }\n\n  private _setIsTouch(isTouch: boolean): void {\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n      this._isTouchTimeoutId = undefined;\n    }\n\n    this._isTouch = true;\n\n    if (isTouch) {\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 300);\n    }\n  }\n\n  private _getSelectionMode(): SelectionMode {\n    const { selection } = this.props;\n\n    const { selectionMode = selection ? selection.mode : SelectionMode.none } = this.props;\n\n    return selectionMode;\n  }\n}\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SACEC,KAAK,EACLC,UAAU,EACVC,QAAQ,EACRC,eAAe,EACfC,oBAAoB,EACpBC,SAAS,EACTC,WAAW,EACXC,SAAS,EACTC,iBAAiB,EACjBC,GAAG,EACHC,sBAAsB,EACtBC,UAAU,QACL,iBAAiB;AACxB,SAASC,aAAa,QAAQ,cAAc;AAG5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMC,iCAAiC,GAAG,yBAAyB;AACnE,IAAMC,8BAA8B,GAAG,sBAAsB;AAC7D,IAAMC,6BAA6B,GAAG,qBAAqB;AAC3D,IAAMC,+BAA+B,GAAG,uBAAuB;AAC/D,IAAMC,+BAA+B,GAAG,uBAAuB;AAC/D,IAAMC,qCAAqC,GAAG,6BAA6B;AAC3E,IAAMC,mCAAmC,GAAG,2BAA2B;AACvE,IAAMC,+BAA+B,GAAG,uBAAuB;AA4G/D;;;AAGA,IAAAC,aAAA,0BAAAC,MAAA;EAAmCC,SAAA,CAAAF,aAAA,EAAAC,MAAA;EAgCjC,SAAAD,cAAYG,KAA0B;IAAtC,IAAAC,KAAA,GACEH,MAAA,CAAAI,IAAA,OAAMF,KAAK,CAAC;IAvBNC,KAAA,CAAAE,KAAK,GAAG5B,KAAK,CAAC6B,SAAS,EAAkB;IA8FjD;;;;;;IAMOH,KAAA,CAAAI,eAAe,GAAG;MACvBJ,KAAI,CAACK,gBAAgB,CAAC,KAAK,CAAC;IAC9B,CAAC;IAEOL,KAAA,CAAAM,kBAAkB,GAAG;MACnB,IAAAC,SAAS,GAAKP,KAAI,CAACD,KAAK,CAAAQ,SAAf;MAEjB,IAAMC,OAAO,GAAGD,SAAS,CAACC,OAAO,IAAID,SAAS,CAACC,OAAO,EAAE;MAExDR,KAAI,CAACS,QAAQ,CAAC;QACZD,OAAO,EAAAA;OACR,CAAC;IACJ,CAAC;IAEOR,KAAA,CAAAU,mBAAmB,GAAG,UAACC,EAAiC;MAC9D,IAAIC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MACrC,IAAMC,GAAG,GAAG/B,SAAS,CAACkB,KAAI,CAACE,KAAK,CAACY,OAAO,CAAC;MACzC,IAAMC,GAAG,GAAGF,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEG,QAAQ;MAEzB,IAAI,CAAAD,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEE,aAAa,MAAKL,MAAM,IAAI,CAAClC,eAAe,CAACqC,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEE,aAA4B,EAAEL,MAAM,CAAC,EAAE;QAChGZ,KAAI,CAACI,eAAe,EAAE;QACtB;;MAGF,IAAI,CAAC1B,eAAe,CAACkC,MAAM,EAAEZ,KAAI,CAACE,KAAK,CAACY,OAAO,CAAC,EAAE;QAChD;;MAGF,OAAOF,MAAM,KAAKZ,KAAI,CAACE,KAAK,CAACY,OAAO,EAAE;QACpC,IAAId,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAEpB,+BAA+B,CAAC,EAAE;UAC/DQ,KAAI,CAACI,eAAe,EAAE;UACtB;;QAGFQ,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;IAE7C,CAAC;IAED;;;;;IAKQZ,KAAA,CAAAmB,QAAQ,GAAG,UAACR,EAAiC;MACnD,IAAMC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MAC/B,IAAAL,SAAS,GAAKP,KAAI,CAACD,KAAK,CAAAQ,SAAf;MACjB,IAAMa,uBAAuB,GAAGpB,KAAI,CAACqB,cAAc,IAAIrB,KAAI,CAACsB,cAAc;MAE1E,IAAMC,aAAa,GAAGvB,KAAI,CAACwB,iBAAiB,EAAE;MAE9C,IAAIxB,KAAI,CAACyB,kBAAkB,IAAIF,aAAa,KAAKpC,aAAa,CAACuC,IAAI,EAAE;QACnE,IAAMC,QAAQ,GAAG3B,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAErB,+BAA+B,CAAC;QAC5E,IAAMqC,QAAQ,GAAG5B,KAAI,CAAC6B,aAAa,CAACjB,MAAM,CAAC;QAE3C,IAAI,CAACe,QAAQ,IAAIC,QAAQ,EAAE;UACzB,IAAME,KAAK,GAAG9B,KAAI,CAAC+B,aAAa,CAACH,QAAQ,CAAC;UAC1C,IAAMI,IAAI,GAAGhC,KAAI,CAACiC,YAAY,CAACL,QAAQ,CAAC;UAExC,IAAII,IAAI,KAAKE,SAAS,EAAE;YACtB,IAAId,uBAAuB,EAAE;cAC3B;cACAb,SAAS,CAAC4B,gBAAgB,CAACL,KAAK,EAAEvB,SAAS,CAAC6B,eAAe,CAACN,KAAK,CAAC,EAAE,IAAI,CAAC;cACzE,IAAI9B,KAAI,CAACD,KAAK,CAACsC,iBAAiB,IAAIrC,KAAI,CAACsC,QAAQ,IAAI/B,SAAS,CAACgC,QAAQ,EAAE;gBACvEhC,SAAS,CAACgC,QAAQ,CAAC,IAAI,CAAC;gBACxBvC,KAAI,CAACwC,WAAW,CAAC,KAAK,CAAC;;aAE1B,MAAM;cACL,IAAIxC,KAAI,CAACD,KAAK,CAAC0C,iBAAiB,EAAE;gBAChCzC,KAAI,CAAC0C,mBAAmB,CAAC,OAAO,EAAEZ,KAAK,CAAC;;;;;;MAOlD9B,KAAI,CAACK,gBAAgB,CAAC,KAAK,CAAC;IAC9B,CAAC;IAEOL,KAAA,CAAA2C,YAAY,GAAG,UAAChC,EAAiC;MACvDX,KAAI,CAAC4C,gBAAgB,CAACjC,EAAE,CAAC;MAEjB,IAAAkC,4BAA4B,GAAK7C,KAAI,CAACD,KAAK,CAAA8C,4BAAf;MAEpC,IAAIjC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MACrC,IAAMgB,QAAQ,GAAG5B,KAAI,CAAC6B,aAAa,CAACjB,MAAM,CAAC;MAE3C;MACA,IAAIZ,KAAI,CAAC8C,oBAAoB,CAAClC,MAAM,CAAC,EAAE;QACrC;;MAGF,OAAOA,MAAM,KAAKZ,KAAI,CAACE,KAAK,CAACY,OAAO,EAAE;QACpC,IAAId,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAElB,mCAAmC,CAAC,EAAE;UACnE;SACD,MAAM,IAAIkC,QAAQ,EAAE;UACnB,IAAI5B,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAErB,+BAA+B,CAAC,EAAE;YAC/D;WACD,MAAM,IAAIS,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAEpB,+BAA+B,CAAC,EAAE;YACtE;WACD,MAAM,IACL,CAACoB,MAAM,KAAKgB,QAAQ,IAAI5B,KAAI,CAAC+C,iBAAiB,CAACnC,MAAM,CAAC,KACtD,CAACZ,KAAI,CAACgD,eAAe,IACrB,CAAChD,KAAI,CAACqB,cAAc,IACpB,CAACrB,KAAI,CAACsB,cAAc,IACpB,CAACuB,4BAA4B,EAC7B;YACA7C,KAAI,CAACiD,kBAAkB,CAACtC,EAAE,EAAEX,KAAI,CAAC+B,aAAa,CAACH,QAAQ,CAAC,EAAE5B,KAAI,CAACiC,YAAY,CAACL,QAAQ,CAAC,CAAC;YAEtF;WACD,MAAM,IACL5B,KAAI,CAACD,KAAK,CAACmD,gCAAgC,KAC1CtC,MAAM,CAACuC,OAAO,KAAK,GAAG,IAAIvC,MAAM,CAACuC,OAAO,KAAK,QAAQ,IAAIvC,MAAM,CAACuC,OAAO,KAAK,OAAO,CAAC,EACrF;YACA;;;QAIJvC,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;IAE7C,CAAC;IAEOZ,KAAA,CAAAoD,oBAAoB,GAAG,UAACzC,EAAiC;MAC/DX,KAAI,CAACwC,WAAW,CAAC,IAAI,CAAC;IACxB,CAAC;IAEOxC,KAAA,CAAAqD,QAAQ,GAAG,UAAC1C,EAAiC;MAC3C,IAAA2C,EAAA,GAAwCtD,KAAI,CAACD,KAAK,CAAAwD,2BAAf;QAAnCA,2BAA2B,GAAAD,EAAA,cAAG,KAAK,GAAAA,EAAA;MAE3CtD,KAAI,CAAC4C,gBAAgB,CAACjC,EAAE,CAAC;MAEzB,IAAIC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MACrC,IAAMgB,QAAQ,GAAG5B,KAAI,CAAC6B,aAAa,CAACjB,MAAM,CAAC;MAE3C,IAAM4C,mBAAmB,GAAGxD,KAAI,CAAC8C,oBAAoB,CAAClC,MAAM,CAAC;MAE7D,OAAOA,MAAM,KAAKZ,KAAI,CAACE,KAAK,CAACY,OAAO,EAAE;QACpC,IAAId,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAElB,mCAAmC,CAAC,EAAE;UACnE,IAAI,CAAC8D,mBAAmB,EAAE;YACxBxD,KAAI,CAACyD,iBAAiB,CAAC9C,EAAE,CAAC;;UAE5B;SACD,MAAM,IAAIiB,QAAQ,EAAE;UACnB,IAAME,KAAK,GAAG9B,KAAI,CAAC+B,aAAa,CAACH,QAAQ,CAAC;UAC1C,IAAMI,IAAI,GAAGhC,KAAI,CAACiC,YAAY,CAACL,QAAQ,CAAC;UAExC,IAAI5B,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAErB,+BAA+B,CAAC,EAAE;YAC/D,IAAI,CAACiE,mBAAmB,EAAE;cACxB,IAAIxD,KAAI,CAACgD,eAAe,EAAE;gBACxBhD,KAAI,CAAC0C,mBAAmB,CAAC,OAAO,EAAEZ,KAAK,EAAEE,IAAI,CAAC;eAC/C,MAAM;gBACLhC,KAAI,CAAC0D,cAAc,CAAC/C,EAAE,EAAEmB,KAAK,EAAEE,IAAI,CAAC;;;YAGxC;WACD,MAAM,IACJhC,KAAI,CAACsC,QAAQ,IACZiB,2BAA2B,IAC3BvD,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAEnB,qCAAqC,CAAC,IACnEO,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAEpB,+BAA+B,CAAC,EAC3D;YACA,IAAIwC,IAAI,KAAKE,SAAS,EAAE;cACtB;cACAlC,KAAI,CAAC2D,cAAc,CAAChD,EAAE,EAAEmB,KAAK,CAAC;;YAEhC;WACD,MAAM,IAAIlB,MAAM,KAAKgB,QAAQ,EAAE;YAC9B,IAAI,CAAC4B,mBAAmB,EAAE;cACxBxD,KAAI,CAAC0C,mBAAmB,CAAC,OAAO,EAAEZ,KAAK,EAAEE,IAAI,CAAC;;YAEhD;WACD,MAAM,IAAIpB,MAAM,CAACuC,OAAO,KAAK,GAAG,IAAIvC,MAAM,CAACuC,OAAO,KAAK,QAAQ,IAAIvC,MAAM,CAACuC,OAAO,KAAK,OAAO,EAAE;YAC9F;;;QAIJvC,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;IAE7C,CAAC;IAEOZ,KAAA,CAAA4D,cAAc,GAAG,UAACjD,EAAiC;MACzD,IAAMC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MAEjC,IAAA0C,EAAA,GAAmCtD,KAAI,CAACD,KAAK;QAA3C8D,iBAAiB,GAAAP,EAAA,CAAAO,iBAAA;QAAEtD,SAAS,GAAA+C,EAAA,CAAA/C,SAAe;MACnD,IAAIsD,iBAAiB,EAAE;QACrB,IAAMjC,QAAQ,GAAG5B,KAAI,CAAC6B,aAAa,CAACjB,MAAM,CAAC;QAE3C,IAAIgB,QAAQ,EAAE;UACZ,IAAME,KAAK,GAAG9B,KAAI,CAAC+B,aAAa,CAACH,QAAQ,CAAC;UAE1C5B,KAAI,CAACiD,kBAAkB,CAACtC,EAAE,EAAEmB,KAAK,CAAC;UAElC,IAAMgC,kBAAkB,GAAGD,iBAAiB,CAACtD,SAAS,CAACwD,QAAQ,EAAE,CAACjC,KAAK,CAAC,EAAEA,KAAK,EAAEnB,EAAE,CAACqD,WAAW,CAAC;UAEhG;UACA;UACA;UACA,IAAI,CAACF,kBAAkB,EAAE;YACvBnD,EAAE,CAACsD,cAAc,EAAE;;;;IAI3B,CAAC;IAiBD;;;;IAIQjE,KAAA,CAAAkE,cAAc,GAAG,UAACvD,EAAiC;MACzD,IAAIC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MAE7B,IAAAuD,aAAa,GAAKnE,KAAI,CAACD,KAAK,CAAAoE,aAAf;MACrB,IAAMvC,QAAQ,GAAG5B,KAAI,CAAC6B,aAAa,CAACjB,MAAM,CAAC;MAE3C,IAAIgB,QAAQ,IAAIuC,aAAa,IAAI,CAACnE,KAAI,CAACoE,eAAe,CAACxD,MAAM,CAAC,EAAE;QAC9D,IAAMkB,KAAK,GAAG9B,KAAI,CAAC+B,aAAa,CAACH,QAAQ,CAAC;QAE1C,OAAOhB,MAAM,KAAKZ,KAAI,CAACE,KAAK,CAACY,OAAO,EAAE;UACpC,IACEd,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAErB,+BAA+B,CAAC,IAC3DS,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAEpB,+BAA+B,CAAC,EAC3D;YACA;WACD,MAAM,IAAIoB,MAAM,KAAKgB,QAAQ,EAAE;YAC9B5B,KAAI,CAAC2D,cAAc,CAAChD,EAAE,EAAEmB,KAAK,CAAC;YAC9B;;UAGFlB,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;QAG3CA,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;IAE7C,CAAC;IAEOZ,KAAA,CAAAqE,iBAAiB,GAAG,UAAC1D,EAAoC;MAC/DX,KAAI,CAAC4C,gBAAgB,CAACjC,EAAE,CAAC;MAEzBX,KAAI,CAACK,gBAAgB,CAAC,IAAI,CAAC;IAC7B,CAAC;IAEOL,KAAA,CAAAsE,UAAU,GAAG,UAAC3D,EAAoC;MACxDX,KAAI,CAAC4C,gBAAgB,CAACjC,EAAE,CAAC;MAEzB,IAAIC,MAAM,GAAGD,EAAE,CAACC,MAAqB;MAErC,IAAM4C,mBAAmB,GAAGxD,KAAI,CAAC8C,oBAAoB,CAAClC,MAAM,CAAC;MAEvD,IAAA0C,EAAA,GAA+CtD,KAAI,CAACD,KAAK;QAAvDQ,SAAS,GAAA+C,EAAA,CAAA/C,SAAA;QAAEgE,6BAA6B,GAAAjB,EAAA,CAAAiB,6BAAe;MAC/D;MACA,IAAMC,cAAc,GAAG7D,EAAE,CAAC8D,KAAK,KAAKhG,QAAQ,CAACiG,CAAC,KAAK1E,KAAI,CAACqB,cAAc,IAAIrB,KAAI,CAACsB,cAAc,CAAC;MAC9F;MACA,IAAMqD,mBAAmB,GAAGhE,EAAE,CAAC8D,KAAK,KAAKhG,QAAQ,CAACmG,MAAM;MAExD;MACA,IAAI5E,KAAI,CAACoE,eAAe,CAACxD,MAAM,CAAC,EAAE;QAChC;QACA;;MAGF,IAAMW,aAAa,GAAGvB,KAAI,CAACwB,iBAAiB,EAAE;MAE9C;MACA,IAAIgD,cAAc,IAAIjD,aAAa,KAAKpC,aAAa,CAAC0F,QAAQ,IAAI,CAACtE,SAAS,CAACuE,aAAa,EAAE,EAAE;QAC5F,IAAI,CAACtB,mBAAmB,EAAE;UACxBjD,SAAS,CAACwE,cAAc,CAAC,IAAI,CAAC;;QAEhCpE,EAAE,CAACqE,eAAe,EAAE;QACpBrE,EAAE,CAACsD,cAAc,EAAE;QACnB;;MAGF;MACA;MACA,IAAIM,6BAA6B,IAAII,mBAAmB,IAAIpE,SAAS,CAAC0E,gBAAgB,EAAE,GAAG,CAAC,EAAE;QAC5F,IAAI,CAACzB,mBAAmB,EAAE;UACxBjD,SAAS,CAACwE,cAAc,CAAC,KAAK,CAAC;;QAEjCpE,EAAE,CAACqE,eAAe,EAAE;QACpBrE,EAAE,CAACsD,cAAc,EAAE;QACnB;;MAGF,IAAMrC,QAAQ,GAAG5B,KAAI,CAAC6B,aAAa,CAACjB,MAAM,CAAC;MAE3C;MACA,IAAIgB,QAAQ,EAAE;QACZ,IAAME,KAAK,GAAG9B,KAAI,CAAC+B,aAAa,CAACH,QAAQ,CAAC;QAC1C,IAAMI,IAAI,GAAGhC,KAAI,CAACiC,YAAY,CAACL,QAAQ,CAAC;QAExC,OAAOhB,MAAM,KAAKZ,KAAI,CAACE,KAAK,CAACY,OAAO,EAAE;UACpC,IAAId,KAAI,CAACkB,aAAa,CAACN,MAAM,EAAErB,+BAA+B,CAAC,EAAE;YAC/D;YACA;YACA;WACD,MAAM,IAAIS,KAAI,CAAC+C,iBAAiB,CAACnC,MAAM,CAAC,EAAE;YACzC,IAAI,CAAC4C,mBAAmB,IAAIxB,IAAI,KAAKE,SAAS,EAAE;cAC9C;cACA;cACAlC,KAAI,CAACiD,kBAAkB,CAACtC,EAAE,EAAEmB,KAAK,EAAEE,IAAI,CAAC;;YAE1C;WACD,MAAM;UACL;UACA,CAACrB,EAAE,CAAC8D,KAAK,KAAKhG,QAAQ,CAACyG,KAAK,IAAIvE,EAAE,CAAC8D,KAAK,KAAKhG,QAAQ,CAAC0G,KAAK,MAC1DvE,MAAM,CAACuC,OAAO,KAAK,QAAQ,IAC1BvC,MAAM,CAACuC,OAAO,KAAK,GAAG,IACtBvC,MAAM,CAACuC,OAAO,KAAK,OAAO,IAC1BvC,MAAM,CAACuC,OAAO,KAAK,SAAS,CAAC,EAC/B;YACA,OAAO,KAAK;WACb,MAAM,IAAIvC,MAAM,KAAKgB,QAAQ,EAAE;YAC9B;YACA,IAAIjB,EAAE,CAAC8D,KAAK,KAAKhG,QAAQ,CAACyG,KAAK,EAAE;cAC/B,IAAIlD,IAAI,KAAKE,SAAS,EAAE;gBACtB;gBACAlC,KAAI,CAAC2D,cAAc,CAAChD,EAAE,EAAEmB,KAAK,CAAC;gBAC9BnB,EAAE,CAACsD,cAAc,EAAE;;cAErB;cACA;aACD,MAAM,IAAItD,EAAE,CAAC8D,KAAK,KAAKhG,QAAQ,CAAC0G,KAAK,EAAE;cACtC,IAAI,CAAC3B,mBAAmB,EAAE;gBACxBxD,KAAI,CAAC0D,cAAc,CAAC/C,EAAE,EAAEmB,KAAK,EAAEE,IAAI,CAAC;;cAEtCrB,EAAE,CAACsD,cAAc,EAAE;cACnB;;YAEF;;UAGFrD,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;;IAG/C,CAAC;IAvaCZ,KAAI,CAACoF,OAAO,GAAG,IAAI5G,UAAU,CAACwB,KAAI,CAAC;IACnCA,KAAI,CAACqF,MAAM,GAAG,IAAI9G,KAAK,CAACyB,KAAI,CAAC;IAC7Bf,sBAAsB,CAACe,KAAI,CAAC;IAEpB,IAAAO,SAAS,GAAKP,KAAI,CAACD,KAAK,CAAAQ,SAAf;IAEjB;IACA,IAAMC,OAAO,GAAGD,SAAS,CAACC,OAAO,IAAID,SAAS,CAACC,OAAO,EAAE;IAExDR,KAAI,CAACsF,KAAK,GAAG;MACX9E,OAAO,EAAAA;KACR;;EACH;EA3BcZ,aAAA,CAAA2F,wBAAwB,GAAtC,UACEC,SAA8B,EAC9BC,SAA8B;IAE9B,IAAMjF,OAAO,GAAGgF,SAAS,CAACjF,SAAS,CAACC,OAAO,IAAIgF,SAAS,CAACjF,SAAS,CAACC,OAAO,EAAE;IAE5E,OAAAkF,QAAA,CAAAA,QAAA,KACKD,SAAS;MACZjF,OAAO,EAAAA;IAAA;EAEX,CAAC;EAmBMZ,aAAA,CAAA+F,SAAA,CAAAC,iBAAiB,GAAxB;IACE,IAAM/E,GAAG,GAAG/B,SAAS,CAAC,IAAI,CAACoB,KAAK,CAACY,OAAO,CAAC;IACzC,IAAMC,GAAG,GAAGF,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEG,QAAQ;IAEzB;IACA,IAAI,CAACoE,OAAO,CAACS,EAAE,CAAChF,GAAG,EAAE,gBAAgB,EAAE,IAAI,CAAC+B,gBAAgB,EAAE,IAAI,CAAC;IACnE,IAAI,CAACwC,OAAO,CAACS,EAAE,CAAC9E,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC+E,wCAAwC,CAAC;IAC5E,IAAI,CAACV,OAAO,CAACS,EAAE,CAAC9E,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEgF,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC3C,oBAAoB,EAAE,IAAI,CAAC;IACzE,IAAI,CAACgC,OAAO,CAACS,EAAE,CAAC9E,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEgF,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC3C,oBAAoB,EAAE,IAAI,CAAC;IAEvE;IACA,IAAI,CAACgC,OAAO,CAACS,EAAE,CAAC,IAAI,CAAC9F,KAAK,CAACQ,SAAS,EAAE,QAAQ,EAAE,IAAI,CAACD,kBAAkB,CAAC;EAC1E,CAAC;EAEMV,aAAA,CAAA+F,SAAA,CAAAK,MAAM,GAAb;IACU,IAAAxF,OAAO,GAAK,IAAI,CAAC8E,KAAK,CAAA9E,OAAf;IAEf,OACElC,KAAA,CAAA2H,aAAA;MACEC,SAAS,EAAElH,GAAG,CAAC,kBAAkB,EAAE,IAAI,CAACe,KAAK,CAACmG,SAAS,EAAE;QACvD,yBAAyB,EAAE,CAAC,CAAC1F;OAC9B,CAAC;MACF2F,GAAG,EAAE,IAAI,CAACjG,KAAK;MACfkG,SAAS,EAAE,IAAI,CAAC9B,UAAU;MAC1B+B,WAAW,EAAE,IAAI,CAAC1D,YAAY;MAC9B2D,gBAAgB,EAAE,IAAI,CAACjC,iBAAiB;MACxCkC,OAAO,EAAE,IAAI,CAAClD,QAAQ;MACtBmD,IAAI,EAAC,cAAc;MACnBC,aAAa,EAAE,IAAI,CAACvC,cAAc;MAClCwC,aAAa,EAAE,IAAI,CAAC9C,cAAc;MAClC+C,kBAAkB,EAAE,IAAI,CAACjG,mBAAmB;MAC5CkG,cAAc,EAAE,IAAI,CAACzF,QAAQ;MAAA,2BACJX,OAAO,GAAG,IAAI,GAAG0B;IAAS,GAElD,IAAI,CAACnC,KAAK,CAAC8G,QAAQ,EACpBvI,KAAA,CAAA2H,aAAA,CAAC/G,UAAU,OAAG,CACV;EAEV,CAAC;EAEMU,aAAA,CAAA+F,SAAA,CAAAmB,kBAAkB,GAAzB,UAA0BC,aAAkC;IAClD,IAAAxG,SAAS,GAAK,IAAI,CAACR,KAAK,CAAAQ,SAAf;IAEjB,IAAIA,SAAS,KAAKwG,aAAa,CAACxG,SAAS,EAAE;MACzC;MACA,IAAI,CAAC6E,OAAO,CAAC4B,GAAG,CAACD,aAAa,CAACxG,SAAS,CAAC;MACzC,IAAI,CAAC6E,OAAO,CAACS,EAAE,CAACtF,SAAS,EAAE,QAAQ,EAAE,IAAI,CAACD,kBAAkB,CAAC;;EAEjE,CAAC;EAEMV,aAAA,CAAA+F,SAAA,CAAAsB,oBAAoB,GAA3B;IACE,IAAI,CAAC7B,OAAO,CAAC8B,OAAO,EAAE;IACtB,IAAI,CAAC7B,MAAM,CAAC6B,OAAO,EAAE;EACvB,CAAC;EAmNOtH,aAAA,CAAA+F,SAAA,CAAA7C,oBAAoB,GAA5B,UAA6BlC,MAAmB;IAC9C,IAAI,IAAI,CAACY,iBAAiB,EAAE,KAAKrC,aAAa,CAACuC,IAAI,EAAE;MACnD,OAAO,IAAI;;IAGb,OAAOd,MAAM,KAAK,IAAI,CAACV,KAAK,CAACY,OAAO,EAAE;MACpC,IAAI,IAAI,CAACI,aAAa,CAACN,MAAM,EAAExB,iCAAiC,CAAC,EAAE;QACjE,OAAO,IAAI;;MAEbwB,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;IAG3C,OAAO,KAAK;EACd,CAAC;EAsIOhB,aAAA,CAAA+F,SAAA,CAAAlC,iBAAiB,GAAzB,UAA0B9C,EAAiC;IACjD,IAAAJ,SAAS,GAAK,IAAI,CAACR,KAAK,CAAAQ,SAAf;IAEjB,IAAMgB,aAAa,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAE9C,IAAID,aAAa,KAAKpC,aAAa,CAAC0F,QAAQ,EAAE;MAC5CtE,SAAS,CAAC4G,iBAAiB,EAAE;MAC7BxG,EAAE,CAACqE,eAAe,EAAE;MACpBrE,EAAE,CAACsD,cAAc,EAAE;;EAEvB,CAAC;EAEOrE,aAAA,CAAA+F,SAAA,CAAAjC,cAAc,GAAtB,UACE/C,EAAoE,EACpEmB,KAAa,EACbE,IAAa;IAEL,IAAAzB,SAAS,GAAK,IAAI,CAACR,KAAK,CAAAQ,SAAf;IAEjB,IAAMgB,aAAa,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAE9CjB,SAAS,CAAC6G,eAAe,CAAC,KAAK,CAAC;IAEhC,IACE,IAAI,CAACrH,KAAK,CAACsC,iBAAiB,IAC5B,IAAI,CAACC,QAAQ,KACZN,IAAI,KAAKE,SAAS,GAAG,CAAC3B,SAAS,CAAC8G,eAAe,CAACvF,KAAK,EAAEE,IAAI,CAAC,GAAG,CAACzB,SAAS,CAAC6B,eAAe,CAACN,KAAK,CAAC,CAAC,IAClGvB,SAAS,CAACgC,QAAQ,EAClB;MACAhC,SAAS,CAACgC,QAAQ,CAAC,IAAI,CAAC;MACxB,IAAI,CAACC,WAAW,CAAC,KAAK,CAAC;;IAGzB,IAAIjB,aAAa,KAAKpC,aAAa,CAAC0F,QAAQ,EAAE;MAC5C,IAAI7C,IAAI,KAAKE,SAAS,EAAE;QACtB3B,SAAS,CAAC+G,mBAAmB,CAACxF,KAAK,EAAEE,IAAI,CAAC;OAC3C,MAAM;QACLzB,SAAS,CAACgH,mBAAmB,CAACzF,KAAK,CAAC;;KAEvC,MAAM,IAAIP,aAAa,KAAKpC,aAAa,CAACqI,MAAM,EAAE;MACjD,IAAIxF,IAAI,KAAKE,SAAS,IAAIF,IAAI,KAAK,CAAC,EAAE;QACpC,IAAMyF,UAAU,GAAGlH,SAAS,CAAC6B,eAAe,CAACN,KAAK,CAAC;QACnD,IAAMtB,OAAO,GAAGD,SAAS,CAACC,OAAO,IAAID,SAAS,CAACC,OAAO,EAAE;QACxDD,SAAS,CAACwE,cAAc,CAAC,KAAK,CAAC;QAC/BxE,SAAS,CAAC4B,gBAAgB,CAACL,KAAK,EAAE,CAAC2F,UAAU,EAAE,IAAI,CAAC;QACpD,IAAIjH,OAAO,IAAID,SAAS,CAACgC,QAAQ,EAAE;UACjC;UACA;UACA;UACAhC,SAAS,CAACgC,QAAQ,CAAC,IAAI,CAAC;;;KAG7B,MAAM;MACLhC,SAAS,CAAC6G,eAAe,CAAC,IAAI,CAAC;MAC/B;;IAGF7G,SAAS,CAAC6G,eAAe,CAAC,IAAI,CAAC;IAE/BzG,EAAE,CAACqE,eAAe,EAAE;IAEpB;IACA;EACF,CAAC;EAEOpF,aAAA,CAAA+F,SAAA,CAAAhC,cAAc,GAAtB,UAAuBhD,EAAoE,EAAEmB,KAAa;IAClG,IAAAwB,EAAA,GAA+B,IAAI,CAACvD,KAAK;MAAvCQ,SAAS,GAAA+C,EAAA,CAAA/C,SAAA;MAAE4D,aAAa,GAAAb,EAAA,CAAAa,aAAe;IAE/C,IAAIA,aAAa,EAAE;MACjBA,aAAa,CAAC5D,SAAS,CAACwD,QAAQ,EAAE,CAACjC,KAAK,CAAC,EAAEA,KAAK,EAAEnB,EAAE,CAACqD,WAAW,CAAC;MACjErD,EAAE,CAACsD,cAAc,EAAE;MACnBtD,EAAE,CAACqE,eAAe,EAAE;;EAExB,CAAC;EAEOpF,aAAA,CAAA+F,SAAA,CAAAjD,mBAAmB,GAA3B,UAA4BgF,IAAuB,EAAE5F,KAAa,EAAEE,IAAa;;IACzE,IAAA2F,EAAA,GAA8C,IAAI,CAAC5H,KAAK;MAAtDQ,SAAS,GAAAoH,EAAA,CAAApH,SAAA;MAAEsC,4BAA4B,GAAA8E,EAAA,CAAA9E,4BAAe;IAC9D,IAAMzB,uBAAuB,GAAG,IAAI,CAACC,cAAc,IAAI,IAAI,CAACC,cAAc;IAE1E,IAAMC,aAAa,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAE9C,IAAID,aAAa,KAAKpC,aAAa,CAAC0F,QAAQ,EAAE;MAC5C,IAAI,IAAI,CAAC7B,eAAe,IAAI,CAAC,IAAI,CAAC4E,aAAa,EAAE;QAC/C,IAAI5F,IAAI,KAAKE,SAAS,EAAE;UACtB,CAAAoB,EAAA,GAAA/C,SAAS,CAACsH,aAAa,cAAAvE,EAAA,uBAAAA,EAAA,CAAArD,IAAA,CAAAM,SAAA,EAAGuB,KAAK,EAAEE,IAAI,EAAE,CAACZ,uBAAuB,CAAC;SACjE,MAAM;UACLb,SAAS,CAACuH,aAAa,CAAChG,KAAK,EAAE,CAACV,uBAAuB,CAAC;;OAE3D,MAAM,IAAIsG,IAAI,KAAK,OAAO,KAAKtG,uBAAuB,IAAIyB,4BAA4B,CAAC,EAAE;QACxF,IAAIb,IAAI,KAAKE,SAAS,EAAE;UACtB3B,SAAS,CAAC+G,mBAAmB,CAACxF,KAAK,EAAEE,IAAI,CAAC;SAC3C,MAAM;UACLzB,SAAS,CAACgH,mBAAmB,CAACzF,KAAK,CAAC;;OAEvC,MAAM;QACL,IAAI,CAACiG,oBAAoB,CAACjG,KAAK,EAAEE,IAAI,CAAC;;KAEzC,MAAM,IAAIT,aAAa,KAAKpC,aAAa,CAACqI,MAAM,EAAE;MACjD,IAAI,CAACO,oBAAoB,CAACjG,KAAK,EAAEE,IAAI,CAAC;;EAE1C,CAAC;EAEOpC,aAAA,CAAA+F,SAAA,CAAA1C,kBAAkB,GAA1B,UACEtC,EAAoE,EACpEmB,KAAa,EACbE,IAAa;IAEL,IAAAzB,SAAS,GAAK,IAAI,CAACR,KAAK,CAAAQ,SAAf;IAEjB,IAAIyB,IAAI,KAAKE,SAAS,EAAE;MACtB,IAAI3B,SAAS,CAAC8G,eAAe,CAACvF,KAAK,EAAEE,IAAI,CAAC,EAAE;QAC1C;;KAEH,MAAM;MACL;MACA,IAAIzB,SAAS,CAAC6B,eAAe,CAACN,KAAK,CAAC,EAAE;QACpC;;;IAIJ,IAAI,CAACiG,oBAAoB,CAACjG,KAAK,EAAEE,IAAI,CAAC;EACxC,CAAC;EAED;;;;;;;EAOQpC,aAAA,CAAA+F,SAAA,CAAAG,wCAAwC,GAAhD,UAAiDnF,EAAc;IAC7D,IAAME,GAAG,GAAG/B,SAAS,CAAC,IAAI,CAACoB,KAAK,CAACY,OAAO,CAAC;IACzC,IAAMC,GAAG,GAAGF,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEG,QAAQ;IACzB,IAAMgH,YAAY,GAAGrJ,oBAAoB,CAAC,IAAI,CAACuB,KAAK,CAACY,OAAO,CAAgB;IAC5E;IACA,IAAI,CAACsE,OAAO,CAAC4B,GAAG,CAACjG,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC+E,wCAAwC,CAAC;IAC7E,IAAI,CAACV,OAAO,CAACS,EAAE,CAACmC,YAAY,EAAE,OAAO,EAAE,IAAI,CAACC,qBAAqB,CAAC;IAElE;IACA,IAAKD,YAAY,IAAIrH,EAAE,CAACC,MAAM,YAAYsH,IAAI,IAAIF,YAAY,CAACG,QAAQ,CAACxH,EAAE,CAACC,MAAM,CAAC,IAAKoH,YAAY,KAAKrH,EAAE,CAACC,MAAM,EAAE;MACjH,IAAI,CAACqH,qBAAqB,CAACtH,EAAE,CAAC;;EAElC,CAAC;EAEOf,aAAA,CAAA+F,SAAA,CAAAsC,qBAAqB,GAA7B,UAA8BtH,EAAc;IAC1C,IAAI,CAAC,IAAI,CAACZ,KAAK,CAACqI,8BAA8B,IAAI,IAAI,CAACC,kBAAkB,CAAC1H,EAAE,CAACC,MAAqB,CAAC,EAAE;MACnG,IAAI,CAACb,KAAK,CAACQ,SAAS,CAACwE,cAAc,CAAC,KAAK,CAAC;;EAE9C,CAAC;EAEOnF,aAAA,CAAA+F,SAAA,CAAAoC,oBAAoB,GAA5B,UAA6BjG,KAAa,EAAEE,IAAa;;IACjD,IAAA2F,EAAA,GAAuD,IAAI,CAAC5H,KAAK;MAA/DQ,SAAS,GAAAoH,EAAA,CAAApH,SAAA;MAAE+H,EAAA,GAAAX,EAAA,CAAAY,8BAAqC;MAArCA,8BAA8B,GAAAD,EAAA,cAAG,IAAI,GAAAA,EAAe;IACvE,IAAME,uBAAuB,GAC3B,CAACxG,IAAI,KAAKE,SAAS,IAAIF,IAAI,KAAK,CAAC,KAAKzB,SAAS,CAAC0E,gBAAgB,EAAE,KAAK,CAAC,IAAI1E,SAAS,CAAC6B,eAAe,CAACN,KAAK,CAAC;IAE9G,IAAI,CAAC0G,uBAAuB,IAAID,8BAA8B,EAAE;MAC9D,IAAM/H,OAAO,GAAGD,SAAS,CAACC,OAAO,IAAID,SAAS,CAACC,OAAO,EAAE;MACxDD,SAAS,CAAC6G,eAAe,CAAC,KAAK,CAAC;MAChC7G,SAAS,CAACwE,cAAc,CAAC,KAAK,CAAC;MAC/B,IAAI/C,IAAI,KAAKE,SAAS,EAAE;QACtB,CAAAoB,EAAA,GAAA/C,SAAS,CAACkI,gBAAgB,cAAAnF,EAAA,uBAAAA,EAAA,CAAArD,IAAA,CAAAM,SAAA,EAAGuB,KAAK,EAAEE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;OACtD,MAAM;QACLzB,SAAS,CAAC4B,gBAAgB,CAACL,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;;MAE/C,IAAItB,OAAO,IAAK,IAAI,CAACT,KAAK,CAACsC,iBAAiB,IAAI,IAAI,CAACC,QAAS,EAAE;QAC9D,IAAI/B,SAAS,CAACgC,QAAQ,EAAE;UACtBhC,SAAS,CAACgC,QAAQ,CAAC,IAAI,CAAC;;QAE1B,IAAI,IAAI,CAACD,QAAQ,EAAE;UACjB,IAAI,CAACE,WAAW,CAAC,KAAK,CAAC;;;MAG3BjC,SAAS,CAAC6G,eAAe,CAAC,IAAI,CAAC;;EAEnC,CAAC;EAED;;;;EAIQxH,aAAA,CAAA+F,SAAA,CAAA/C,gBAAgB,GAAxB,UAAyBjC,EAAoE;IAC3F,IAAI,CAACqC,eAAe,GAAGrC,EAAE,CAAC+H,QAAQ;IAClC,IAAI,CAACrH,cAAc,GAAGV,EAAE,CAACgI,OAAO;IAChC,IAAI,CAACrH,cAAc,GAAGX,EAAE,CAACiI,OAAO;IAEhC;IACA,IAAMC,OAAO,GAAIlI,EAAuC,CAACkI,OAAO;IAChE,IAAI,CAACjB,aAAa,GAAGiB,OAAO,GAAGA,OAAO,KAAKpK,QAAQ,CAACqK,GAAG,GAAG,KAAK;EACjE,CAAC;EAEOlJ,aAAA,CAAA+F,SAAA,CAAA9D,aAAa,GAArB,UAAsBjB,MAAmB;IAC/B,IAAAL,SAAS,GAAK,IAAI,CAACR,KAAK,CAAAQ,SAAf;IAEjB,OAAOK,MAAM,KAAK,IAAI,CAACV,KAAK,CAACY,OAAO,EAAE;MACpC,IAAMiI,UAAU,GAAGnI,MAAM,CAACoI,YAAY,CAAC3J,8BAA8B,CAAC;MACtE,IAAMyC,KAAK,GAAGmH,MAAM,CAACF,UAAU,CAAC;MAEhC,IAAIA,UAAU,KAAK,IAAI,IAAIjH,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGvB,SAAS,CAACwD,QAAQ,EAAE,CAACmF,MAAM,EAAE;QAC5E;;MAGFtI,MAAM,GAAGhC,SAAS,CAACgC,MAAM,CAAgB;;IAG3C,IAAIA,MAAM,KAAK,IAAI,CAACV,KAAK,CAACY,OAAO,EAAE;MACjC,OAAOoB,SAAS;;IAGlB,OAAOtB,MAAM;EACf,CAAC;EAEOhB,aAAA,CAAA+F,SAAA,CAAA5D,aAAa,GAArB,UAAsBH,QAAqB;;IACzC,IAAMmH,UAAU,GAAGI,QAAQ,CAAC,CAAA7F,EAAA,GAAA1B,QAAQ,CAACoH,YAAY,CAAC3J,8BAA8B,CAAC,cAAAiE,EAAA,cAAAA,EAAA,GAAI,EAAE,EAAE,EAAE,CAAC;IAE5F,OAAO8F,KAAK,CAACL,UAAU,CAAC,GAAG,CAAC,CAAC,GAAGA,UAAU;EAC5C,CAAC;EAEOnJ,aAAA,CAAA+F,SAAA,CAAA1D,YAAY,GAApB,UAAqBL,QAAqB;;IACxC,IAAMyH,SAAS,GAAGF,QAAQ,CAAC,CAAA7F,EAAA,GAAA1B,QAAQ,CAACoH,YAAY,CAAC1J,6BAA6B,CAAC,cAAAgE,EAAA,cAAAA,EAAA,GAAI,EAAE,EAAE,EAAE,CAAC;IAE1F,OAAO8F,KAAK,CAACC,SAAS,CAAC,GAAGnH,SAAS,GAAGmH,SAAS;EACjD,CAAC;EAEOzJ,aAAA,CAAA+F,SAAA,CAAA5C,iBAAiB,GAAzB,UAA0BuG,OAAoB;IAC5C,OAAO,IAAI,CAACpI,aAAa,CAACoI,OAAO,EAAE3J,+BAA+B,CAAC;EACrE,CAAC;EAEOC,aAAA,CAAA+F,SAAA,CAAAzE,aAAa,GAArB,UAAsBoI,OAAoB,EAAEC,aAAqB;IAC/D,IAAI5H,QAAQ,GAAG,KAAK;IAEpB,OAAO,CAACA,QAAQ,IAAI2H,OAAO,KAAK,IAAI,CAACpJ,KAAK,CAACY,OAAO,EAAE;MAClD,IAAM0I,KAAK,GAAGF,OAAO,CAACN,YAAY,CAACO,aAAa,CAAC;MACjD,IAAIC,KAAK,KAAK,OAAO,EAAE;QACrB7H,QAAQ,GAAG,KAAK;QAChB;;MAEFA,QAAQ,GAAG6H,KAAK,KAAK,MAAM;MAC3BF,OAAO,GAAG1K,SAAS,CAAC0K,OAAO,CAAgB;;IAG7C,OAAO3H,QAAQ;EACjB,CAAC;EAEO/B,aAAA,CAAA+F,SAAA,CAAAvB,eAAe,GAAvB,UAAwBkF,OAAoB;IAC1C,OACEA,OAAO,CAACnG,OAAO,KAAK,OAAO,IAC3BmG,OAAO,CAACnG,OAAO,KAAK,UAAU,IAC9BmG,OAAO,CAACN,YAAY,CAAC,iBAAiB,CAAC,KAAK,MAAM,IAClDM,OAAO,CAACN,YAAY,CAAC,iBAAiB,CAAC,KAAK,EAAE;EAElD,CAAC;EAEOpJ,aAAA,CAAA+F,SAAA,CAAA0C,kBAAkB,GAA1B,UAA2BiB,OAAoB;IAC7C,IAAMvI,GAAG,GAAGlC,WAAW,EAAE;IAEzB,IAAIkC,GAAG,IAAIuI,OAAO,EAAE;MAClB,OAAOA,OAAO,IAAIA,OAAO,KAAKvI,GAAG,CAAC0I,eAAe,EAAE;QACjD,IAAI1K,iBAAiB,CAACuK,OAAO,CAAC,IAAIA,OAAO,CAACI,YAAY,CAAC,sBAAsB,CAAC,EAAE;UAC9E,OAAO,KAAK;;QAGdJ,OAAO,GAAG1K,SAAS,CAAC0K,OAAO,CAAgB;;;IAI/C,OAAO,IAAI;EACb,CAAC;EAEO1J,aAAA,CAAA+F,SAAA,CAAAtF,gBAAgB,GAAxB,UAAyBsJ,WAAoB;IAA7C,IAAA3J,KAAA;IACE,IAAI,IAAI,CAAC4J,2BAA2B,EAAE;MACpC,IAAI,CAACvE,MAAM,CAACwE,YAAY,CAAC,IAAI,CAACD,2BAA2B,CAAC;MAC1D,IAAI,CAACA,2BAA2B,GAAG1H,SAAS;;IAG9C,IAAI,CAACT,kBAAkB,GAAGkI,WAAW;IAErC,IAAIA,WAAW,EAAE;MACf,IAAI,CAACtE,MAAM,CAACyE,UAAU,CAAC;QACrB9J,KAAI,CAACyB,kBAAkB,GAAG,KAAK;MACjC,CAAC,EAAE,GAAG,CAAC;;EAEX,CAAC;EAEO7B,aAAA,CAAA+F,SAAA,CAAAnD,WAAW,GAAnB,UAAoBuH,OAAgB;IAApC,IAAA/J,KAAA;IACE,IAAI,IAAI,CAACgK,iBAAiB,EAAE;MAC1B,IAAI,CAAC3E,MAAM,CAACwE,YAAY,CAAC,IAAI,CAACG,iBAAiB,CAAC;MAChD,IAAI,CAACA,iBAAiB,GAAG9H,SAAS;;IAGpC,IAAI,CAACI,QAAQ,GAAG,IAAI;IAEpB,IAAIyH,OAAO,EAAE;MACX,IAAI,CAAC1E,MAAM,CAACyE,UAAU,CAAC;QACrB9J,KAAI,CAACsC,QAAQ,GAAG,KAAK;MACvB,CAAC,EAAE,GAAG,CAAC;;EAEX,CAAC;EAEO1C,aAAA,CAAA+F,SAAA,CAAAnE,iBAAiB,GAAzB;IACU,IAAAjB,SAAS,GAAK,IAAI,CAACR,KAAK,CAAAQ,SAAf;IAET,IAAA+C,EAAA,GAAoE,IAAI,CAACvD,KAAK,CAAAwB,aAAf;MAA/DA,aAAa,GAAA+B,EAAA,cAAG/C,SAAS,GAAGA,SAAS,CAAC0J,IAAI,GAAG9K,aAAa,CAACuC,IAAI,GAAA4B,EAAA;IAEvE,OAAO/B,aAAa;EACtB,CAAC;EA3vBa3B,aAAA,CAAAsK,YAAY,GAAG;IAC3BzH,iBAAiB,EAAE,IAAI;IACvBI,4BAA4B,EAAE,KAAK;IACnCtB,aAAa,EAAEpC,aAAa,CAAC0F,QAAQ;IACrCN,6BAA6B,EAAE;GAChC;EAuvBH,OAAA3E,aAAC;CAAA,CA7vBkCtB,KAAK,CAAC6L,SAAS;SAArCvK,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}