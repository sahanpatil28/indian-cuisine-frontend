{"ast":null,"code":"import { __assign, __extends, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { getLayerStyles } from './KeytipLayer.styles';\nimport { Keytip } from '../../Keytip';\nimport { Layer } from '../../Layer';\nimport { classNamesFunction, getDocument, arraysEqual, warn, isMac, EventGroup, Async, initializeComponentRef, KeyCodes, isElementVisibleAndNotHidden } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { KeytipTree } from './KeytipTree';\nimport { ktpTargetFromId, ktpTargetFromSequences, sequencesToID, mergeOverflows } from '../../utilities/keytips/KeytipUtils';\nimport { transitionKeysContain } from '../../utilities/keytips/IKeytipTransitionKey';\nimport { KeytipEvents, KTP_LAYER_ID, KTP_ARIA_SEPARATOR } from '../../utilities/keytips/KeytipConstants';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getDocumentEx, getWindowEx } from '../../utilities/dom';\n// Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\nvar defaultStartSequence = {\n  key: isMac() ? 'Control' : 'Meta',\n  modifierKeys: [KeyCodes.alt]\n};\n// Default exit sequence is the same as the start sequence\nvar defaultExitSequence = defaultStartSequence;\n// Default return sequence is Escape\nvar defaultReturnSequence = {\n  key: 'Escape'\n};\nvar getClassNames = classNamesFunction();\n/**\n * A layer that holds all keytip items\n * {@docCategory Keytips}\n */\nvar KeytipLayerBase = /** @class */function (_super) {\n  __extends(KeytipLayerBase, _super);\n  function KeytipLayerBase(props, context) {\n    var _this = _super.call(this, props, context) || this;\n    _this._keytipManager = KeytipManager.getInstance();\n    _this._delayedKeytipQueue = [];\n    _this._keyHandled = false;\n    _this._isKeytipInstanceTargetVisible = function (keySequences, instanceCount) {\n      var _a;\n      var doc = getDocumentEx(_this.context);\n      var win = getWindowEx(_this.context);\n      var targetSelector = ktpTargetFromSequences(keySequences);\n      var matchingElements = (_a = doc === null || doc === void 0 ? void 0 : doc.querySelectorAll(targetSelector)) !== null && _a !== void 0 ? _a : [];\n      // If there are multiple elements for the keytip sequence, return true if the element instance\n      // that corresponds to the keytip instance is visible, otherwise return if there is only one instance\n      return matchingElements.length > 1 && instanceCount <= matchingElements.length ? isElementVisibleAndNotHidden(matchingElements[instanceCount - 1], win !== null && win !== void 0 ? win : undefined) : instanceCount === 1;\n    };\n    _this._onDismiss = function (ev) {\n      // if we are in keytip mode, then exit keytip mode\n      if (_this.state.inKeytipMode) {\n        _this._exitKeytipMode(ev);\n      }\n    };\n    _this._onKeyDown = function (ev) {\n      _this._keyHandled = false;\n      // using key since which has been deprecated and key is now widely suporrted.\n      // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n      var key = ev.key;\n      switch (key) {\n        case 'Tab':\n        case 'Enter':\n        case 'Spacebar':\n        case ' ':\n        case 'ArrowUp':\n        case 'Up':\n        case 'ArrowDown':\n        case 'Down':\n        case 'ArrowLeft':\n        case 'Left':\n        case 'ArrowRight':\n        case 'Right':\n          if (_this.state.inKeytipMode) {\n            _this._keyHandled = true;\n            _this._exitKeytipMode(ev);\n          }\n          break;\n        default:\n          // Special cases for browser-specific keys that are not at standard\n          // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n          if (key === 'Esc') {\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n            key = 'Escape';\n          } else if (key === 'OS' || key === 'Win') {\n            // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n            // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n            key = 'Meta';\n          }\n          var transitionKey = {\n            key: key\n          };\n          transitionKey.modifierKeys = _this._getModifierKey(key, ev);\n          _this.processTransitionInput(transitionKey, ev);\n          break;\n      }\n    };\n    _this._onKeyPress = function (ev) {\n      if (_this.state.inKeytipMode && !_this._keyHandled) {\n        // Call processInput\n        _this.processInput(ev.key.toLocaleLowerCase(), ev);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n    _this._onKeytipAdded = function (eventArgs) {\n      var _a;\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n      _this._keytipTree.addNode(keytipProps, uniqueID);\n      _this._setKeytips();\n      // Add the keytip to the queue to show later\n      if (_this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n        // Ensure existing children are still shown.\n        _this._delayedKeytipQueue = _this._delayedKeytipQueue.concat(((_a = _this._keytipTree.currentKeytip) === null || _a === void 0 ? void 0 : _a.children) || []);\n        _this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n        // Ensure the child of currentKeytip is successfully added to currentKeytip's children and update it if not.\n        // Note: Added this condition because KeytipTree.addNode was not always reflecting updates made to a parent node\n        // in currentKeytip when that parent is the currentKeytip.\n        if (_this._keytipTree.currentKeytip && _this._keytipTree.currentKeytip.hasDynamicChildren && _this._keytipTree.currentKeytip.children.indexOf(keytipProps.id) < 0) {\n          var currNode = _this._keytipTree.getNode(_this._keytipTree.currentKeytip.id);\n          if (currNode) {\n            _this._keytipTree.currentKeytip = currNode;\n          }\n        }\n      }\n      _this._persistedKeytipChecks(keytipProps);\n    };\n    _this._onKeytipUpdated = function (eventArgs) {\n      var _a;\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n      _this._keytipTree.updateNode(keytipProps, uniqueID);\n      _this._setKeytips();\n      if (_this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n        // Ensure existing children are still shown.\n        _this._delayedKeytipQueue = _this._delayedKeytipQueue.concat(((_a = _this._keytipTree.currentKeytip) === null || _a === void 0 ? void 0 : _a.children) || []);\n        _this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n      }\n      _this._persistedKeytipChecks(keytipProps);\n    };\n    /**\n     * Helper function to do checks related to persisted/overflow keytips\n     * Done on keytip added and keytip updated\n     *\n     * @param keytipProps - Keytip props\n     */\n    _this._persistedKeytipChecks = function (keytipProps) {\n      if (_this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, _this._newCurrentKeytipSequences)) {\n        _this._triggerKeytipImmediately(keytipProps);\n      }\n      if (_this._isCurrentKeytipAnAlias(keytipProps)) {\n        var keytipSequence = keytipProps.keySequences;\n        if (keytipProps.overflowSetSequence) {\n          keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n        }\n        _this._keytipTree.currentKeytip = _this._keytipTree.getNode(sequencesToID(keytipSequence));\n      }\n    };\n    _this._onKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n      // Remove keytip from the delayed queue\n      _this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences));\n      // Remove the node from the Tree\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n      _this._setKeytips();\n    };\n    _this._onPersistedKeytipAdded = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n      _this._keytipTree.addNode(keytipProps, uniqueID, true);\n    };\n    _this._onPersistedKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n    };\n    _this._onPersistedKeytipExecute = function (eventArgs) {\n      _this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n    };\n    /**\n     * Sets if we are in keytip mode.\n     * Note, this sets both the state for the layer as well as\n     * the value that the manager will expose externally.\n     * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\n     */\n    _this._setInKeytipMode = function (inKeytipMode) {\n      _this.setState({\n        inKeytipMode: inKeytipMode\n      });\n      _this._keytipManager.inKeytipMode = inKeytipMode;\n    };\n    /**\n     * Emits a warning if duplicate keytips are found for the children of the current keytip\n     */\n    _this._warnIfDuplicateKeytips = function () {\n      var duplicateKeytips = _this._getDuplicateIds(_this._keytipTree.getChildren());\n      if (duplicateKeytips.length) {\n        warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n      }\n    };\n    /**\n     * Returns duplicates among keytip IDs.\n     * If the returned array is empty, no duplicates were found.\n     *\n     * @param keytipIds - Array of keytip IDs to find duplicates for\n     * @returns - Array of duplicates that were found. Each duplicate will only be added once to this array.\n     */\n    _this._getDuplicateIds = function (keytipIds) {\n      var seenIds = {};\n      return keytipIds.filter(function (keytipId) {\n        seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n        // Only add the first duplicate keytip seen\n        return seenIds[keytipId] === 2;\n      });\n    };\n    initializeComponentRef(_this);\n    _this._events = new EventGroup(_this);\n    _this._async = new Async(_this);\n    var keytips = _this._keytipManager.getKeytips();\n    _this.state = {\n      inKeytipMode: false,\n      keytips: keytips,\n      visibleKeytips: _this._getVisibleKeytips(keytips)\n    };\n    _this._buildTree();\n    _this._currentSequence = '';\n    // Add keytip listeners\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_ADDED, _this._onKeytipAdded);\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_UPDATED, _this._onKeytipUpdated);\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_REMOVED, _this._onKeytipRemoved);\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, _this._onPersistedKeytipAdded);\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, _this._onPersistedKeytipRemoved);\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, _this._onPersistedKeytipExecute);\n    return _this;\n  }\n  KeytipLayerBase.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      content = _a.content,\n      styles = _a.styles;\n    var _b = this.state,\n      keytips = _b.keytips,\n      visibleKeytips = _b.visibleKeytips;\n    this._classNames = getClassNames(styles, {});\n    return React.createElement(Layer, {\n      styles: getLayerStyles\n    }, React.createElement(\"span\", {\n      id: KTP_LAYER_ID,\n      className: this._classNames.innerContent\n    }, \"\".concat(content).concat(KTP_ARIA_SEPARATOR)), keytips && keytips.map(function (keytipProps, index) {\n      return React.createElement(\"span\", {\n        key: index,\n        id: sequencesToID(keytipProps.keySequences),\n        className: _this._classNames.innerContent\n      }, keytipProps.keySequences.join(KTP_ARIA_SEPARATOR));\n    }), visibleKeytips && visibleKeytips.map(function (visibleKeytipProps) {\n      return React.createElement(Keytip, __assign({\n        key: sequencesToID(visibleKeytipProps.keySequences)\n      }, visibleKeytipProps));\n    }));\n  };\n  KeytipLayerBase.prototype.componentDidMount = function () {\n    var win = getWindowEx(this.context);\n    // Add window listeners\n    this._events.on(win, 'mouseup', this._onDismiss, true /* useCapture */);\n    this._events.on(win, 'pointerup', this._onDismiss, true /* useCapture */);\n    this._events.on(win, 'resize', this._onDismiss);\n    this._events.on(win, 'keydown', this._onKeyDown, true /* useCapture */);\n    this._events.on(win, 'keypress', this._onKeyPress, true /* useCapture */);\n    this._events.on(win, 'scroll', this._onDismiss, true /* useCapture */);\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n    this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  };\n  KeytipLayerBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n    this._events.dispose();\n  };\n  // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n  KeytipLayerBase.prototype.getCurrentSequence = function () {\n    return this._currentSequence;\n  };\n  KeytipLayerBase.prototype.getKeytipTree = function () {\n    return this._keytipTree;\n  };\n  /**\n   * Processes an IKeytipTransitionKey entered by the user\n   *\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\n   */\n  KeytipLayerBase.prototype.processTransitionInput = function (transitionKey, ev) {\n    var currKtp = this._keytipTree.currentKeytip;\n    if (transitionKeysContain(this.props.keytipExitSequences, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n      this._exitKeytipMode(ev);\n    } else if (transitionKeysContain(this.props.keytipReturnSequences, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          }\n          // Reset currentSequence\n          this._currentSequence = '';\n          // Return pointer to its parent\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent);\n          // Show children keytips of the new currentKeytip\n          this.showKeytips(this._keytipTree.getChildren());\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (transitionKeysContain(this.props.keytipStartSequences, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n      this._enterKeytipMode(transitionKey);\n      this._warnIfDuplicateKeytips();\n    }\n  };\n  /**\n   * Processes inputs from the document listener and traverse the keytip tree\n   *\n   * @param key - Key pressed by the user\n   */\n  KeytipLayerBase.prototype.processInput = function (key, ev) {\n    // Concat the input key with the current sequence\n    var currSequence = this._currentSequence + key;\n    var currKtp = this._keytipTree.currentKeytip;\n    // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n    if (currKtp) {\n      var node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n        var currKtpChildren = this._keytipTree.getChildren();\n        // Execute this node's onExecute if defined\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          // Reset currKtp, this might have changed from the onExecute\n          currKtp = this._keytipTree.currentKeytip;\n        }\n        // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n          this._warnIfDuplicateKeytips();\n        }\n        // Clear currentSequence\n        this._currentSequence = '';\n        return;\n      }\n      var partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        var ids = partialNodes.filter(function (partialNode) {\n          return !partialNode.persisted;\n        }).map(function (partialNode) {\n          return partialNode.id;\n        });\n        this.showKeytips(ids);\n        // Save currentSequence\n        this._currentSequence = currSequence;\n      }\n    }\n  };\n  /**\n   * Show the given keytips and hide all others\n   *\n   * @param ids - Keytip IDs to show\n   */\n  KeytipLayerBase.prototype.showKeytips = function (ids) {\n    // Update the visible prop in the manager\n    for (var _i = 0, _a = this._keytipManager.getKeytips(); _i < _a.length; _i++) {\n      var keytip = _a[_i];\n      var keytipId = sequencesToID(keytip.keySequences);\n      if (keytip.overflowSetSequence) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytipId = sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence));\n      }\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    }\n    // Apply the manager changes to the Layer state\n    this._setKeytips();\n  };\n  /**\n   * Enters keytip mode for this layer\n   */\n  KeytipLayerBase.prototype._enterKeytipMode = function (transitionKey) {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      if (this._keytipManager.delayUpdatingKeytipChange) {\n        this._buildTree();\n        this._setKeytips();\n      }\n      this._keytipTree.currentKeytip = this._keytipTree.root;\n      // Show children of root\n      this.showKeytips(this._keytipTree.getChildren());\n      this._setInKeytipMode(true /* inKeytipMode */);\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode(transitionKey);\n      }\n    }\n  };\n  KeytipLayerBase.prototype._buildTree = function () {\n    this._keytipTree = new KeytipTree();\n    // Add regular and persisted keytips to the tree\n    for (var _i = 0, _a = Object.keys(this._keytipManager.keytips); _i < _a.length; _i++) {\n      var id = _a[_i];\n      var uniqueKeytip = this._keytipManager.keytips[id];\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n    for (var _b = 0, _c = Object.keys(this._keytipManager.persistedKeytips); _b < _c.length; _b++) {\n      var id = _c[_b];\n      var uniqueKeytip = this._keytipManager.persistedKeytips[id];\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n  };\n  /**\n   * Exits keytip mode for this layer\n   */\n  KeytipLayerBase.prototype._exitKeytipMode = function (ev) {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = '';\n    // Hide all keytips\n    this.showKeytips([]);\n    // Reset the delayed keytips if any\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n    this._setInKeytipMode(false /* inKeytipMode */);\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  };\n  /**\n   * Sets the keytips state property\n   *\n   * @param keytipProps - Keytips to set in this layer\n   */\n  KeytipLayerBase.prototype._setKeytips = function (keytipProps) {\n    if (keytipProps === void 0) {\n      keytipProps = this._keytipManager.getKeytips();\n    }\n    this.setState({\n      keytips: keytipProps,\n      visibleKeytips: this._getVisibleKeytips(keytipProps)\n    });\n  };\n  /**\n   * Callback function to use for persisted keytips\n   *\n   * @param overflowButtonSequences - The overflow button sequence to execute\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\n   */\n  KeytipLayerBase.prototype._persistedKeytipExecute = function (overflowButtonSequences, keytipSequences) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences;\n    // Execute the overflow button's onExecute\n    var overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(this._getKtpExecuteTarget(overflowKeytipNode), this._getKtpTarget(overflowKeytipNode));\n    }\n  };\n  KeytipLayerBase.prototype._getVisibleKeytips = function (keytips) {\n    var _this = this;\n    // Filter out non-visible keytips and duplicates\n    var seenIds = {};\n    return keytips.filter(function (keytip) {\n      var keytipId = sequencesToID(keytip.keySequences);\n      if (keytip.overflowSetSequence) {\n        // Account for overflow set sequences when checking for duplicates\n        keytipId = sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence));\n      }\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      // Return true only if the keytip is visible and the corresponding target is also visible\n      return keytip.visible && _this._isKeytipInstanceTargetVisible(keytip.keySequences, seenIds[keytipId]);\n    });\n  };\n  /**\n   * Gets the ModifierKeyCodes based on the keyboard event\n   *\n   * @param ev - React.KeyboardEvent\n   * @returns List of ModifierKeyCodes that were pressed\n   */\n  KeytipLayerBase.prototype._getModifierKey = function (key, ev) {\n    var modifierKeys = [];\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(KeyCodes.alt);\n    }\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(KeyCodes.ctrl);\n    }\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(KeyCodes.shift);\n    }\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(KeyCodes.leftWindow);\n    }\n    return modifierKeys.length ? modifierKeys : undefined;\n  };\n  /**\n   * Trigger a keytip immediately and set it as the current keytip\n   *\n   * @param keytipProps - Keytip to trigger immediately\n   */\n  KeytipLayerBase.prototype._triggerKeytipImmediately = function (keytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    var keytipSequence = __spreadArray([], keytipProps.keySequences, true);\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    }\n    // Set currentKeytip\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      var children = this._keytipTree.getChildren();\n      if (children.length) {\n        this.showKeytips(children);\n      }\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(this._getKtpExecuteTarget(this._keytipTree.currentKeytip), this._getKtpTarget(this._keytipTree.currentKeytip));\n      }\n    }\n    // Unset _newCurrKtpSequences\n    this._newCurrentKeytipSequences = undefined;\n  };\n  KeytipLayerBase.prototype._addKeytipToQueue = function (keytipID) {\n    var _this = this;\n    // Add keytip\n    this._delayedKeytipQueue.push(keytipID);\n    // Clear timeout\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    // Reset timeout\n    this._delayedQueueTimeout = this._async.setTimeout(function () {\n      if (_this._delayedKeytipQueue.length) {\n        _this.showKeytips(_this._delayedKeytipQueue);\n        _this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  };\n  KeytipLayerBase.prototype._removeKeytipFromQueue = function (keytipID) {\n    var _this = this;\n    var index = this._delayedKeytipQueue.indexOf(keytipID);\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1);\n      // Clear timeout\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n      // Reset timeout\n      this._delayedQueueTimeout = this._async.setTimeout(function () {\n        if (_this._delayedKeytipQueue.length) {\n          _this.showKeytips(_this._delayedKeytipQueue);\n          _this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  };\n  KeytipLayerBase.prototype._getKtpExecuteTarget = function (currKtp) {\n    return getDocument().querySelector(ktpTargetFromId(currKtp.id));\n  };\n  KeytipLayerBase.prototype._getKtpTarget = function (currKtp) {\n    return getDocument().querySelector(ktpTargetFromSequences(currKtp.keySequences));\n  };\n  /**\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\n   * This will make 'keytipProps' the new currentKeytip\n   *\n   * @param keytipProps - Keytip props to check\n   * @returns - T/F if this keytip should become the currentKeytip\n   */\n  KeytipLayerBase.prototype._isCurrentKeytipAnAlias = function (keytipProps) {\n    var currKtp = this._keytipTree.currentKeytip;\n    if (currKtp && (currKtp.overflowSetSequence || currKtp.persisted) && arraysEqual(keytipProps.keySequences, currKtp.keySequences)) {\n      return true;\n    }\n    return false;\n  };\n  KeytipLayerBase.defaultProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: ''\n  };\n  KeytipLayerBase.contextType = WindowContext;\n  return KeytipLayerBase;\n}(React.Component);\nexport { KeytipLayerBase };","map":{"version":3,"names":["React","getLayerStyles","Keytip","Layer","classNamesFunction","getDocument","arraysEqual","warn","isMac","EventGroup","Async","initializeComponentRef","KeyCodes","isElementVisibleAndNotHidden","KeytipManager","KeytipTree","ktpTargetFromId","ktpTargetFromSequences","sequencesToID","mergeOverflows","transitionKeysContain","KeytipEvents","KTP_LAYER_ID","KTP_ARIA_SEPARATOR","WindowContext","getDocumentEx","getWindowEx","defaultStartSequence","key","modifierKeys","alt","defaultExitSequence","defaultReturnSequence","getClassNames","KeytipLayerBase","_super","__extends","props","context","_this","call","_keytipManager","getInstance","_delayedKeytipQueue","_keyHandled","_isKeytipInstanceTargetVisible","keySequences","instanceCount","doc","win","targetSelector","matchingElements","_a","querySelectorAll","length","undefined","_onDismiss","ev","state","inKeytipMode","_exitKeytipMode","_onKeyDown","transitionKey","_getModifierKey","processTransitionInput","_onKeyPress","processInput","toLocaleLowerCase","preventDefault","stopPropagation","_onKeytipAdded","eventArgs","keytipProps","keytip","uniqueID","_keytipTree","addNode","_setKeytips","isCurrentKeytipParent","concat","currentKeytip","children","_addKeytipToQueue","hasDynamicChildren","indexOf","id","currNode","getNode","_persistedKeytipChecks","_onKeytipUpdated","updateNode","_newCurrentKeytipSequences","_triggerKeytipImmediately","_isCurrentKeytipAnAlias","keytipSequence","overflowSetSequence","_onKeytipRemoved","_removeKeytipFromQueue","removeNode","_onPersistedKeytipAdded","_onPersistedKeytipRemoved","_onPersistedKeytipExecute","_persistedKeytipExecute","overflowButtonSequences","keytipSequences","_setInKeytipMode","setState","_warnIfDuplicateKeytips","duplicateKeytips","_getDuplicateIds","getChildren","join","keytipIds","seenIds","filter","keytipId","_events","_async","keytips","getKeytips","visibleKeytips","_getVisibleKeytips","_buildTree","_currentSequence","on","KEYTIP_ADDED","KEYTIP_UPDATED","KEYTIP_REMOVED","PERSISTED_KEYTIP_ADDED","PERSISTED_KEYTIP_REMOVED","PERSISTED_KEYTIP_EXECUTE","prototype","render","content","styles","_b","_classNames","createElement","className","innerContent","map","index","visibleKeytipProps","__assign","componentDidMount","ENTER_KEYTIP_MODE","_enterKeytipMode","EXIT_KEYTIP_MODE","componentWillUnmount","dispose","getCurrentSequence","getKeytipTree","currKtp","keytipExitSequences","keytipReturnSequences","root","onReturn","_getKtpExecuteTarget","_getKtpTarget","parent","showKeytips","keytipStartSequences","currSequence","node","getExactMatchedNode","currKtpChildren","onExecute","hasMenu","partialNodes","getPartiallyMatchedNodes","ids","partialNode","persisted","_i","visible","shouldEnterKeytipMode","delayUpdatingKeytipChange","onEnterKeytipMode","Object","keys","uniqueKeytip","_c","persistedKeytips","_delayedQueueTimeout","clearTimeout","onExitKeytipMode","overflowKeytipNode","altKey","push","ctrlKey","ctrl","shiftKey","shift","metaKey","leftWindow","__spreadArray","keytipID","setTimeout","splice","querySelector","defaultProps","contextType","Component"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\KeytipLayer\\KeytipLayer.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { getLayerStyles } from './KeytipLayer.styles';\nimport { Keytip } from '../../Keytip';\nimport { Layer } from '../../Layer';\nimport {\n  classNamesFunction,\n  getDocument,\n  arraysEqual,\n  warn,\n  isMac,\n  EventGroup,\n  Async,\n  initializeComponentRef,\n  KeyCodes,\n  isElementVisibleAndNotHidden,\n} from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { KeytipTree } from './KeytipTree';\nimport {\n  ktpTargetFromId,\n  ktpTargetFromSequences,\n  sequencesToID,\n  mergeOverflows,\n} from '../../utilities/keytips/KeytipUtils';\nimport { transitionKeysContain } from '../../utilities/keytips/IKeytipTransitionKey';\nimport { KeytipEvents, KTP_LAYER_ID, KTP_ARIA_SEPARATOR } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipLayerProps, IKeytipLayerStyles, IKeytipLayerStyleProps } from './KeytipLayer.types';\nimport type { IKeytipProps } from '../../Keytip';\nimport type { IKeytipTreeNode } from './IKeytipTreeNode';\nimport type { KeytipTransitionModifier, IKeytipTransitionKey } from '../../utilities/keytips/IKeytipTransitionKey';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getDocumentEx, getWindowEx } from '../../utilities/dom';\n\nexport interface IKeytipLayerState {\n  inKeytipMode: boolean;\n  keytips: IKeytipProps[];\n  visibleKeytips: IKeytipProps[];\n}\n\n// Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\nconst defaultStartSequence: IKeytipTransitionKey = {\n  key: isMac() ? 'Control' : 'Meta',\n  modifierKeys: [KeyCodes.alt],\n};\n\n// Default exit sequence is the same as the start sequence\nconst defaultExitSequence: IKeytipTransitionKey = defaultStartSequence;\n\n// Default return sequence is Escape\nconst defaultReturnSequence: IKeytipTransitionKey = {\n  key: 'Escape',\n};\n\nconst getClassNames = classNamesFunction<IKeytipLayerStyleProps, IKeytipLayerStyles>();\n\n/**\n * A layer that holds all keytip items\n * {@docCategory Keytips}\n */\nexport class KeytipLayerBase extends React.Component<IKeytipLayerProps, IKeytipLayerState> {\n  public static defaultProps: IKeytipLayerProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: '',\n  };\n\n  public static contextType = WindowContext;\n\n  private _events: EventGroup;\n  private _async: Async;\n\n  private _keytipTree: KeytipTree;\n\n  private _keytipManager: KeytipManager = KeytipManager.getInstance();\n  private _classNames: { [key in keyof IKeytipLayerStyles]: string };\n  private _currentSequence: string;\n  private _newCurrentKeytipSequences?: string[];\n\n  private _delayedKeytipQueue: string[] = [];\n  private _delayedQueueTimeout: number;\n\n  private _keyHandled = false;\n\n  constructor(props: IKeytipLayerProps, context: any) {\n    super(props, context);\n\n    initializeComponentRef(this);\n    this._events = new EventGroup(this);\n    this._async = new Async(this);\n\n    const keytips = this._keytipManager.getKeytips();\n\n    this.state = {\n      inKeytipMode: false,\n      keytips,\n      visibleKeytips: this._getVisibleKeytips(keytips),\n    };\n\n    this._buildTree();\n\n    this._currentSequence = '';\n\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);\n  }\n\n  public render(): JSX.Element {\n    const { content, styles } = this.props;\n\n    const { keytips, visibleKeytips } = this.state;\n\n    this._classNames = getClassNames(styles, {});\n\n    return (\n      <Layer styles={getLayerStyles}>\n        <span id={KTP_LAYER_ID} className={this._classNames.innerContent}>{`${content}${KTP_ARIA_SEPARATOR}`}</span>\n        {keytips &&\n          keytips.map((keytipProps: IKeytipProps, index: number) => {\n            return (\n              <span key={index} id={sequencesToID(keytipProps.keySequences)} className={this._classNames.innerContent}>\n                {keytipProps.keySequences.join(KTP_ARIA_SEPARATOR)}\n              </span>\n            );\n          })}\n        {visibleKeytips &&\n          visibleKeytips.map((visibleKeytipProps: IKeytipProps) => {\n            return <Keytip key={sequencesToID(visibleKeytipProps.keySequences)} {...visibleKeytipProps} />;\n          })}\n      </Layer>\n    );\n  }\n\n  public componentDidMount(): void {\n    const win = getWindowEx(this.context);\n    // Add window listeners\n    this._events.on(win, 'mouseup', this._onDismiss, true /* useCapture */);\n    this._events.on(win, 'pointerup', this._onDismiss, true /* useCapture */);\n    this._events.on(win, 'resize', this._onDismiss);\n    this._events.on(win, 'keydown', this._onKeyDown, true /* useCapture */);\n    this._events.on(win, 'keypress', this._onKeyPress, true /* useCapture */);\n    this._events.on(win, 'scroll', this._onDismiss, true /* useCapture */);\n\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n    this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n\n  public getCurrentSequence(): string {\n    return this._currentSequence;\n  }\n\n  public getKeytipTree(): KeytipTree {\n    return this._keytipTree;\n  }\n\n  /**\n   * Processes an IKeytipTransitionKey entered by the user\n   *\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\n   */\n  public processTransitionInput(transitionKey: IKeytipTransitionKey, ev?: React.KeyboardEvent<HTMLElement>): void {\n    const currKtp = this._keytipTree.currentKeytip;\n    if (transitionKeysContain(this.props.keytipExitSequences!, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n      this._exitKeytipMode(ev);\n    } else if (transitionKeysContain(this.props.keytipReturnSequences!, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          }\n\n          // Reset currentSequence\n          this._currentSequence = '';\n          // Return pointer to its parent\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent);\n          // Show children keytips of the new currentKeytip\n          this.showKeytips(this._keytipTree.getChildren());\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (transitionKeysContain(this.props.keytipStartSequences!, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n      this._enterKeytipMode(transitionKey);\n      this._warnIfDuplicateKeytips();\n    }\n  }\n\n  /**\n   * Processes inputs from the document listener and traverse the keytip tree\n   *\n   * @param key - Key pressed by the user\n   */\n  public processInput(key: string, ev?: React.KeyboardEvent<HTMLElement>): void {\n    // Concat the input key with the current sequence\n    const currSequence: string = this._currentSequence + key;\n    let currKtp = this._keytipTree.currentKeytip;\n\n    // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n    if (currKtp) {\n      const node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n        const currKtpChildren = this._keytipTree.getChildren();\n\n        // Execute this node's onExecute if defined\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          // Reset currKtp, this might have changed from the onExecute\n          currKtp = this._keytipTree.currentKeytip;\n        }\n\n        // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n          this._warnIfDuplicateKeytips();\n        }\n\n        // Clear currentSequence\n        this._currentSequence = '';\n        return;\n      }\n\n      const partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        const ids = partialNodes\n          .filter((partialNode: IKeytipTreeNode) => {\n            return !partialNode.persisted;\n          })\n          .map((partialNode: IKeytipTreeNode) => {\n            return partialNode.id;\n          });\n        this.showKeytips(ids);\n\n        // Save currentSequence\n        this._currentSequence = currSequence;\n      }\n    }\n  }\n\n  /**\n   * Show the given keytips and hide all others\n   *\n   * @param ids - Keytip IDs to show\n   */\n  public showKeytips(ids: string[]): void {\n    // Update the visible prop in the manager\n    for (const keytip of this._keytipManager.getKeytips()) {\n      let keytipId = sequencesToID(keytip.keySequences);\n      if (keytip.overflowSetSequence) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytipId = sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence));\n      }\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    }\n    // Apply the manager changes to the Layer state\n    this._setKeytips();\n  }\n\n  /**\n   * Enters keytip mode for this layer\n   */\n  private _enterKeytipMode(transitionKey?: IKeytipTransitionKey): void {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      if (this._keytipManager.delayUpdatingKeytipChange) {\n        this._buildTree();\n        this._setKeytips();\n      }\n      this._keytipTree.currentKeytip = this._keytipTree.root;\n      // Show children of root\n      this.showKeytips(this._keytipTree.getChildren());\n\n      this._setInKeytipMode(true /* inKeytipMode */);\n\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode(transitionKey);\n      }\n    }\n  }\n\n  private _buildTree(): void {\n    this._keytipTree = new KeytipTree();\n    // Add regular and persisted keytips to the tree\n    for (const id of Object.keys(this._keytipManager.keytips)) {\n      const uniqueKeytip = this._keytipManager.keytips[id];\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n\n    for (const id of Object.keys(this._keytipManager.persistedKeytips)) {\n      const uniqueKeytip = this._keytipManager.persistedKeytips[id];\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n  }\n\n  /**\n   * Exits keytip mode for this layer\n   */\n  private _exitKeytipMode(ev?: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = '';\n    // Hide all keytips\n    this.showKeytips([]);\n\n    // Reset the delayed keytips if any\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n\n    this._setInKeytipMode(false /* inKeytipMode */);\n\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  }\n\n  /**\n   * Sets the keytips state property\n   *\n   * @param keytipProps - Keytips to set in this layer\n   */\n  private _setKeytips(keytipProps: IKeytipProps[] = this._keytipManager.getKeytips()) {\n    this.setState({ keytips: keytipProps, visibleKeytips: this._getVisibleKeytips(keytipProps) });\n  }\n\n  /**\n   * Callback function to use for persisted keytips\n   *\n   * @param overflowButtonSequences - The overflow button sequence to execute\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\n   */\n  private _persistedKeytipExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences;\n\n    // Execute the overflow button's onExecute\n    const overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(\n        this._getKtpExecuteTarget(overflowKeytipNode),\n        this._getKtpTarget(overflowKeytipNode),\n      );\n    }\n  }\n\n  private _getVisibleKeytips(keytips: IKeytipProps[]): IKeytipProps[] {\n    // Filter out non-visible keytips and duplicates\n    const seenIds: { [childSequence: string]: number } = {};\n    return keytips.filter(keytip => {\n      let keytipId = sequencesToID(keytip.keySequences);\n      if (keytip.overflowSetSequence) {\n        // Account for overflow set sequences when checking for duplicates\n        keytipId = sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence));\n      }\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n\n      // Return true only if the keytip is visible and the corresponding target is also visible\n      return keytip.visible && this._isKeytipInstanceTargetVisible(keytip.keySequences, seenIds[keytipId]);\n    });\n  }\n\n  private _isKeytipInstanceTargetVisible = (keySequences: string[], instanceCount: number): boolean => {\n    const doc = getDocumentEx(this.context);\n    const win = getWindowEx(this.context);\n    const targetSelector = ktpTargetFromSequences(keySequences);\n    const matchingElements = doc?.querySelectorAll(targetSelector) ?? [];\n\n    // If there are multiple elements for the keytip sequence, return true if the element instance\n    // that corresponds to the keytip instance is visible, otherwise return if there is only one instance\n    return matchingElements.length > 1 && instanceCount <= matchingElements.length\n      ? isElementVisibleAndNotHidden(matchingElements[instanceCount - 1] as HTMLElement, win ?? undefined)\n      : instanceCount === 1;\n  };\n\n  private _onDismiss = (ev?: React.MouseEvent<HTMLElement>): void => {\n    // if we are in keytip mode, then exit keytip mode\n    if (this.state.inKeytipMode) {\n      this._exitKeytipMode(ev);\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._keyHandled = false;\n    // using key since which has been deprecated and key is now widely suporrted.\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n    let key = ev.key;\n    switch (key) {\n      case 'Tab':\n      case 'Enter':\n      case 'Spacebar':\n      case ' ':\n      case 'ArrowUp':\n      case 'Up':\n      case 'ArrowDown':\n      case 'Down':\n      case 'ArrowLeft':\n      case 'Left':\n      case 'ArrowRight':\n      case 'Right':\n        if (this.state.inKeytipMode) {\n          this._keyHandled = true;\n          this._exitKeytipMode(ev);\n        }\n        break;\n      default:\n        // Special cases for browser-specific keys that are not at standard\n        // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n        if (key === 'Esc') {\n          // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n          key = 'Escape';\n        } else if (key === 'OS' || key === 'Win') {\n          // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n          // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n          // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n          key = 'Meta';\n        }\n        const transitionKey: IKeytipTransitionKey = { key };\n        transitionKey.modifierKeys = this._getModifierKey(key, ev);\n        this.processTransitionInput(transitionKey, ev);\n        break;\n    }\n  };\n\n  /**\n   * Gets the ModifierKeyCodes based on the keyboard event\n   *\n   * @param ev - React.KeyboardEvent\n   * @returns List of ModifierKeyCodes that were pressed\n   */\n  private _getModifierKey(key: string, ev: React.KeyboardEvent<HTMLElement>): KeytipTransitionModifier[] | undefined {\n    const modifierKeys: KeytipTransitionModifier[] = [];\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(KeyCodes.alt);\n    }\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(KeyCodes.ctrl);\n    }\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(KeyCodes.shift);\n    }\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(KeyCodes.leftWindow);\n    }\n    return modifierKeys.length ? modifierKeys : undefined;\n  }\n\n  private _onKeyPress = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.state.inKeytipMode && !this._keyHandled) {\n      // Call processInput\n      this.processInput(ev.key.toLocaleLowerCase(), ev);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  private _onKeytipAdded = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n\n    this._keytipTree.addNode(keytipProps, uniqueID);\n    this._setKeytips();\n\n    // Add the keytip to the queue to show later\n    if (this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n      // Ensure existing children are still shown.\n      this._delayedKeytipQueue = this._delayedKeytipQueue.concat(this._keytipTree.currentKeytip?.children || []);\n\n      this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n\n      // Ensure the child of currentKeytip is successfully added to currentKeytip's children and update it if not.\n      // Note: Added this condition because KeytipTree.addNode was not always reflecting updates made to a parent node\n      // in currentKeytip when that parent is the currentKeytip.\n      if (\n        this._keytipTree.currentKeytip &&\n        this._keytipTree.currentKeytip.hasDynamicChildren &&\n        this._keytipTree.currentKeytip.children.indexOf(keytipProps.id) < 0\n      ) {\n        const currNode = this._keytipTree.getNode(this._keytipTree.currentKeytip.id);\n        if (currNode) {\n          this._keytipTree.currentKeytip = currNode;\n        }\n      }\n    }\n\n    this._persistedKeytipChecks(keytipProps);\n  };\n\n  private _onKeytipUpdated = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.updateNode(keytipProps, uniqueID);\n    this._setKeytips();\n    if (this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n      // Ensure existing children are still shown.\n      this._delayedKeytipQueue = this._delayedKeytipQueue.concat(this._keytipTree.currentKeytip?.children || []);\n      this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n    }\n\n    this._persistedKeytipChecks(keytipProps);\n  };\n\n  /**\n   * Helper function to do checks related to persisted/overflow keytips\n   * Done on keytip added and keytip updated\n   *\n   * @param keytipProps - Keytip props\n   */\n  private _persistedKeytipChecks = (keytipProps: IKeytipProps) => {\n    if (this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, this._newCurrentKeytipSequences)) {\n      this._triggerKeytipImmediately(keytipProps);\n    }\n\n    if (this._isCurrentKeytipAnAlias(keytipProps)) {\n      let keytipSequence = keytipProps.keySequences;\n      if (keytipProps.overflowSetSequence) {\n        keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n      }\n      this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    }\n  };\n\n  private _onKeytipRemoved = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n\n    // Remove keytip from the delayed queue\n    this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences));\n\n    // Remove the node from the Tree\n    this._keytipTree.removeNode(keytipProps, uniqueID);\n    this._setKeytips();\n  };\n\n  private _onPersistedKeytipAdded = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.addNode(keytipProps, uniqueID, true);\n  };\n\n  private _onPersistedKeytipRemoved = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.removeNode(keytipProps, uniqueID);\n  };\n\n  private _onPersistedKeytipExecute = (eventArgs: any) => {\n    this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n  };\n\n  /**\n   * Trigger a keytip immediately and set it as the current keytip\n   *\n   * @param keytipProps - Keytip to trigger immediately\n   */\n  private _triggerKeytipImmediately(keytipProps: IKeytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    let keytipSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    }\n\n    // Set currentKeytip\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      const children = this._keytipTree.getChildren();\n      if (children.length) {\n        this.showKeytips(children);\n      }\n\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(\n          this._getKtpExecuteTarget(this._keytipTree.currentKeytip),\n          this._getKtpTarget(this._keytipTree.currentKeytip),\n        );\n      }\n    }\n\n    // Unset _newCurrKtpSequences\n    this._newCurrentKeytipSequences = undefined;\n  }\n\n  private _addKeytipToQueue(keytipID: string) {\n    // Add keytip\n    this._delayedKeytipQueue.push(keytipID);\n    // Clear timeout\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    // Reset timeout\n    this._delayedQueueTimeout = this._async.setTimeout(() => {\n      if (this._delayedKeytipQueue.length) {\n        this.showKeytips(this._delayedKeytipQueue);\n        this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  }\n\n  private _removeKeytipFromQueue(keytipID: string) {\n    const index = this._delayedKeytipQueue.indexOf(keytipID);\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1);\n      // Clear timeout\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n      // Reset timeout\n      this._delayedQueueTimeout = this._async.setTimeout(() => {\n        if (this._delayedKeytipQueue.length) {\n          this.showKeytips(this._delayedKeytipQueue);\n          this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  }\n\n  private _getKtpExecuteTarget(currKtp: IKeytipTreeNode): HTMLElement | null {\n    return getDocument()!.querySelector(ktpTargetFromId(currKtp.id));\n  }\n\n  private _getKtpTarget(currKtp: IKeytipTreeNode): HTMLElement | null {\n    return getDocument()!.querySelector(ktpTargetFromSequences(currKtp.keySequences));\n  }\n\n  /**\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\n   * This will make 'keytipProps' the new currentKeytip\n   *\n   * @param keytipProps - Keytip props to check\n   * @returns - T/F if this keytip should become the currentKeytip\n   */\n  private _isCurrentKeytipAnAlias(keytipProps: IKeytipProps): boolean {\n    const currKtp = this._keytipTree.currentKeytip;\n    if (\n      currKtp &&\n      (currKtp.overflowSetSequence || currKtp.persisted) &&\n      arraysEqual(keytipProps.keySequences, currKtp.keySequences)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Sets if we are in keytip mode.\n   * Note, this sets both the state for the layer as well as\n   * the value that the manager will expose externally.\n   * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\n   */\n  private _setInKeytipMode = (inKeytipMode: boolean): void => {\n    this.setState({ inKeytipMode });\n    this._keytipManager.inKeytipMode = inKeytipMode;\n  };\n\n  /**\n   * Emits a warning if duplicate keytips are found for the children of the current keytip\n   */\n  private _warnIfDuplicateKeytips = (): void => {\n    const duplicateKeytips = this._getDuplicateIds(this._keytipTree.getChildren());\n    if (duplicateKeytips.length) {\n      warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n    }\n  };\n\n  /**\n   * Returns duplicates among keytip IDs.\n   * If the returned array is empty, no duplicates were found.\n   *\n   * @param keytipIds - Array of keytip IDs to find duplicates for\n   * @returns - Array of duplicates that were found. Each duplicate will only be added once to this array.\n   */\n  private _getDuplicateIds = (keytipIds: string[]): string[] => {\n    const seenIds: { [id: string]: number } = {};\n    return keytipIds.filter(keytipId => {\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      // Only add the first duplicate keytip seen\n      return seenIds[keytipId] === 2;\n    });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}