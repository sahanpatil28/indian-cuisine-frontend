{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport { KeyCodes, css, elementContains, getDocument, getElementIndexPath, getFocusableByIndexPath, getId, getNativeProps, getNextElement, getParent, getPreviousElement, getRTL, htmlElementProperties, initializeComponentRef, isElementFocusSubZone, isElementFocusZone, isElementTabbable, shouldWrapFocus, warnDeprecations, portalContainsElement, findScrollableParent, createMergedRef, isElementVisibleAndNotHidden, MergeStylesShadowRootContext } from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar TABINDEX = 'tabindex';\nvar NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nvar NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nvar LARGE_DISTANCE_FROM_CENTER = 999999999;\nvar LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\nvar focusZoneStyles;\nvar focusZoneClass = 'ms-FocusZone';\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target, ev) {\n  var event;\n  if (typeof MouseEvent === 'function') {\n    event = new MouseEvent('click', {\n      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,\n      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,\n      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,\n      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,\n      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,\n      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable\n    });\n  } else {\n    // eslint-disable-next-line no-restricted-globals\n    event = document.createEvent('MouseEvents');\n    // eslint-disable-next-line deprecation/deprecation\n    event.initMouseEvent('click', ev ? ev.bubbles : false, ev ? ev.cancelable : false,\n    // eslint-disable-next-line no-restricted-globals\n    window,\n    // not using getWindow() since this can only be run client side\n    0,\n    // detail\n    0,\n    // screen x\n    0,\n    // screen y\n    0,\n    // client x\n    0,\n    // client y\n    ev ? ev.ctrlKey : false, ev ? ev.altKey : false, ev ? ev.shiftKey : false, ev ? ev.metaKey : false, 0,\n    // button\n    null);\n  }\n  target.dispatchEvent(event);\n}\n// Helper function that will return a class for when the root is focused\nfunction getRootClass() {\n  if (!focusZoneStyles) {\n    focusZoneStyles = mergeStyles({\n      selectors: {\n        ':focus': {\n          outline: 'none'\n        }\n      }\n    }, focusZoneClass);\n  }\n  return focusZoneStyles;\n}\nvar _allInstances = {};\nvar _outerZones = new Set();\nvar ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];\nvar ALLOW_VIRTUAL_ELEMENTS = false;\nvar FocusZone = /** @class */function (_super) {\n  __extends(FocusZone, _super);\n  function FocusZone(props) {\n    var _a, _b, _c, _d;\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._mergedRef = createMergedRef();\n    _this._onFocus = function (ev) {\n      if (_this._portalContainsElement(ev.target)) {\n        // If the event target is inside a portal do not process the event.\n        return;\n      }\n      var _a = _this.props,\n        onActiveElementChanged = _a.onActiveElementChanged,\n        // eslint-disable-next-line deprecation/deprecation\n        doNotAllowFocusEventToPropagate = _a.doNotAllowFocusEventToPropagate,\n        stopFocusPropagation = _a.stopFocusPropagation,\n        // eslint-disable-next-line deprecation/deprecation\n        onFocusNotification = _a.onFocusNotification,\n        onFocus = _a.onFocus,\n        shouldFocusInnerElementWhenReceivedFocus = _a.shouldFocusInnerElementWhenReceivedFocus,\n        defaultTabbableElement = _a.defaultTabbableElement;\n      var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);\n      var newActiveElement;\n      if (isImmediateDescendant) {\n        newActiveElement = ev.target;\n      } else {\n        var parentElement = ev.target;\n        while (parentElement && parentElement !== _this._root.current) {\n          if (isElementTabbable(parentElement, undefined, _this._inShadowRoot) && _this._isImmediateDescendantOfZone(parentElement)) {\n            newActiveElement = parentElement;\n            break;\n          }\n          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n        }\n      }\n      // If an inner focusable element should be focused when FocusZone container receives focus\n      if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {\n        var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === 'function' && _this._root.current && defaultTabbableElement(_this._root.current);\n        // try to focus defaultTabbable element\n        if (maybeElementToFocus && isElementTabbable(maybeElementToFocus, undefined, _this._inShadowRoot)) {\n          newActiveElement = maybeElementToFocus;\n          maybeElementToFocus.focus();\n        } else {\n          // force focus on first focusable element\n          _this.focus(true);\n          if (_this._activeElement) {\n            // set to null as new active element was handled in method above\n            newActiveElement = null;\n          }\n        }\n      }\n      var initialElementFocused = !_this._activeElement;\n      // If the new active element is a child of this zone and received focus,\n      // update alignment an immediate descendant\n      if (newActiveElement && newActiveElement !== _this._activeElement) {\n        if (isImmediateDescendant || initialElementFocused) {\n          _this._setFocusAlignment(newActiveElement, true, true);\n        }\n        _this._activeElement = newActiveElement;\n        if (initialElementFocused) {\n          _this._updateTabIndexes();\n        }\n      }\n      if (onActiveElementChanged) {\n        onActiveElementChanged(_this._activeElement, ev);\n      }\n      if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n        ev.stopPropagation();\n      }\n      if (onFocus) {\n        onFocus(ev);\n      } else if (onFocusNotification) {\n        onFocusNotification();\n      }\n    };\n    _this._onBlur = function () {\n      _this._setParkedFocus(false);\n    };\n    _this._onMouseDown = function (ev) {\n      if (_this._portalContainsElement(ev.target)) {\n        // If the event target is inside a portal do not process the event.\n        return;\n      }\n      var disabled = _this.props.disabled;\n      if (disabled) {\n        return;\n      }\n      var target = ev.target;\n      var path = [];\n      while (target && target !== _this._root.current) {\n        path.push(target);\n        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n      }\n      while (path.length) {\n        target = path.pop();\n        if (target && isElementTabbable(target, undefined, _this._inShadowRoot)) {\n          _this._setActiveElement(target, true);\n        }\n        if (isElementFocusZone(target)) {\n          // Stop here since the focus zone will take care of its own children.\n          break;\n        }\n      }\n    };\n    /**\n     * Handle the keystrokes.\n     */\n    _this._onKeyDown = function (ev, theme) {\n      if (_this._portalContainsElement(ev.target)) {\n        // If the event target is inside a portal do not process the event.\n        return;\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        direction = _a.direction,\n        disabled = _a.disabled,\n        isInnerZoneKeystroke = _a.isInnerZoneKeystroke,\n        pagingSupportDisabled = _a.pagingSupportDisabled,\n        shouldEnterInnerZone = _a.shouldEnterInnerZone;\n      if (disabled) {\n        return;\n      }\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n      // If the default has been prevented, do not process keyboard events.\n      if (ev.isDefaultPrevented()) {\n        return;\n      }\n      if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {\n        // If this element has focus, it is being controlled by a parent.\n        // Ignore the keystroke.\n        return;\n      }\n      if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {\n        // Try to focus\n        var innerZone = _this._getFirstInnerZone();\n        if (innerZone) {\n          if (!innerZone.focus(true)) {\n            return;\n          }\n        } else if (isElementFocusSubZone(ev.target)) {\n          if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {\n            return;\n          }\n        } else {\n          return;\n        }\n      } else if (ev.altKey) {\n        return;\n      } else {\n        // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.space:\n            if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n              break;\n            }\n            return;\n          case KeyCodes.left:\n            if (direction !== FocusZoneDirection.vertical) {\n              _this._preventDefaultWhenHandled(ev);\n              if (_this._moveFocusLeft(theme)) {\n                break;\n              }\n            }\n            return;\n          case KeyCodes.right:\n            if (direction !== FocusZoneDirection.vertical) {\n              _this._preventDefaultWhenHandled(ev);\n              if (_this._moveFocusRight(theme)) {\n                break;\n              }\n            }\n            return;\n          case KeyCodes.up:\n            if (direction !== FocusZoneDirection.horizontal) {\n              _this._preventDefaultWhenHandled(ev);\n              if (_this._moveFocusUp()) {\n                break;\n              }\n            }\n            return;\n          case KeyCodes.down:\n            if (direction !== FocusZoneDirection.horizontal) {\n              _this._preventDefaultWhenHandled(ev);\n              if (_this._moveFocusDown()) {\n                break;\n              }\n            }\n            return;\n          case KeyCodes.pageDown:\n            if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {\n              break;\n            }\n            return;\n          case KeyCodes.pageUp:\n            if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {\n              break;\n            }\n            return;\n          case KeyCodes.tab:\n            if (\n            // eslint-disable-next-line deprecation/deprecation\n            _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)) {\n              var focusChanged = false;\n              _this._processingTabKey = true;\n              if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {\n                focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();\n              } else {\n                var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n                focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);\n              }\n              _this._processingTabKey = false;\n              if (focusChanged) {\n                break;\n              } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {\n                _this._activeElement = null;\n              }\n            }\n            return;\n          case KeyCodes.home:\n            if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {\n              return false;\n            }\n            var firstChild = _this._root.current && _this._root.current.firstChild;\n            if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {\n              break;\n            }\n            return;\n          case KeyCodes.end:\n            if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {\n              return false;\n            }\n            var lastChild = _this._root.current && _this._root.current.lastChild;\n            if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {\n              break;\n            }\n            return;\n          case KeyCodes.enter:\n            if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n              break;\n            }\n            return;\n          default:\n            return;\n        }\n      }\n      ev.preventDefault();\n      ev.stopPropagation();\n    };\n    _this._getHorizontalDistanceFromCenter = function (isForward,\n    // eslint-disable-next-line deprecation/deprecation\n    activeRect,\n    // eslint-disable-next-line deprecation/deprecation\n    targetRect) {\n      // eslint-disable-next-line deprecation/deprecation\n      var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;\n      // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectBottom = Math.floor(activeRect.bottom);\n      var targetRectBottom = Math.floor(targetRect.bottom);\n      var activeRectTop = Math.floor(activeRect.top);\n      var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n      var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n      if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          return 0;\n        }\n        return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n      }\n      if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n      return LARGE_DISTANCE_FROM_CENTER;\n    };\n    // Manage componentRef resolution.\n    initializeComponentRef(_this);\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('FocusZone', props, {\n        rootProps: undefined,\n        allowTabKey: 'handleTabKey',\n        elementType: 'as',\n        ariaDescribedBy: 'aria-describedby',\n        ariaLabelledBy: 'aria-labelledby'\n      });\n    }\n    _this._id = getId('FocusZone');\n    _this._focusAlignment = {\n      left: 0,\n      top: 0\n    };\n    _this._processingTabKey = false;\n    var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;\n    _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;\n    _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;\n    return _this;\n  }\n  /** Used for testing purposes only. */\n  FocusZone.getOuterZones = function () {\n    return _outerZones.size;\n  };\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n   * for ref counting to work correctly!\n   */\n  FocusZone._onKeyDownCapture = function (ev) {\n    // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n    if (ev.which === KeyCodes.tab) {\n      _outerZones.forEach(function (zone) {\n        return zone._updateTabIndexes();\n      });\n    }\n  };\n  FocusZone.prototype.componentDidMount = function () {\n    var _a;\n    var root = this._root.current;\n    this._inShadowRoot = !!((_a = this.context) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n    _allInstances[this._id] = this;\n    if (root) {\n      var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n        if (isElementFocusZone(parentElement)) {\n          this._isInnerZone = true;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n      }\n      if (!this._isInnerZone) {\n        _outerZones.add(this);\n        this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n      }\n      this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n      // Assign initial tab indexes so that we can set initial focus as appropriate.\n      this._updateTabIndexes();\n      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);\n        // eslint-disable-next-line deprecation/deprecation\n      } else if (this.props.defaultActiveElement) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);\n      }\n      if (this.props.shouldFocusOnMount) {\n        this.focus();\n      }\n    }\n  };\n  FocusZone.prototype.componentDidUpdate = function () {\n    var _a;\n    var root = this._root.current;\n    var doc = this._getDocument();\n    this._inShadowRoot = !!((_a = this.context) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n    // If either _activeElement or _defaultFocusElement are no longer contained by _root,\n    // reset those variables (and update tab indexes) to avoid memory leaks\n    if (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) || this._defaultFocusElement && !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS)) {\n      this._activeElement = null;\n      this._defaultFocusElement = null;\n      this._updateTabIndexes();\n    }\n    if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {\n      // The element has been removed after the render, attempt to restore focus.\n      var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);\n      if (elementToFocus) {\n        this._setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this._setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this._setParkedFocus(true);\n      }\n    }\n  };\n  FocusZone.prototype.componentWillUnmount = function () {\n    delete _allInstances[this._id];\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n      this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n    }\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  };\n  FocusZone.prototype.render = function () {\n    var _this = this;\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n      tag = _a.as,\n      elementType = _a.elementType,\n      rootProps = _a.rootProps,\n      ariaDescribedBy = _a.ariaDescribedBy,\n      ariaLabelledBy = _a.ariaLabelledBy,\n      className = _a.className;\n    var divProps = getNativeProps(this.props, htmlElementProperties);\n    var Tag = tag || elementType || 'div';\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this._evaluateFocusBeforeRender();\n    // Only support RTL defined in global theme, not contextual theme/RTL.\n    var theme = getTheme();\n    return React.createElement(Tag, __assign({\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy\n    }, divProps, rootProps, {\n      // Once the getClassName correctly memoizes inputs this should\n      // be replaced so that className is passed to getRootClass and is included there so\n      // the class names will always be in the same order.\n      className: css(getRootClass(), className),\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._root),\n      \"data-focuszone-id\": this._id,\n      // eslint-disable-next-line react/jsx-no-bind\n      onKeyDown: function (ev) {\n        return _this._onKeyDown(ev, theme);\n      },\n      onFocus: this._onFocus,\n      onMouseDownCapture: this._onMouseDown\n    }), this.props.children);\n  };\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  FocusZone.prototype.focus = function (forceIntoFirstElement, bypassHiddenElements) {\n    if (forceIntoFirstElement === void 0) {\n      forceIntoFirstElement = false;\n    }\n    if (bypassHiddenElements === void 0) {\n      bypassHiddenElements = false;\n    }\n    if (this._root.current) {\n      if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {\n        var ownerZoneElement = this._getOwnerZone(this._root.current);\n        if (ownerZoneElement !== this._root.current) {\n          var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n        return false;\n      } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement, undefined, this._inShadowRoot) && (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {\n        this._activeElement.focus();\n        return true;\n      } else {\n        var firstChild = this._root.current.firstChild;\n        return this.focusElement(getNextElement(this._root.current, firstChild, true, undefined, undefined, undefined, undefined, undefined, bypassHiddenElements));\n      }\n    }\n    return false;\n  };\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  FocusZone.prototype.focusLast = function () {\n    if (this._root.current) {\n      var lastChild = this._root.current && this._root.current.lastChild;\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));\n    }\n    return false;\n  };\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  FocusZone.prototype.focusElement = function (element, forceAlignment) {\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n      onBeforeFocus = _a.onBeforeFocus,\n      shouldReceiveFocus = _a.shouldReceiveFocus;\n    if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {\n      return false;\n    }\n    if (element) {\n      // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n      this._setActiveElement(element, forceAlignment);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n   * rather than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  FocusZone.prototype.setFocusAlignment = function (point) {\n    this._focusAlignment = point;\n  };\n  Object.defineProperty(FocusZone.prototype, \"defaultFocusElement\", {\n    get: function () {\n      return this._defaultFocusElement;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FocusZone.prototype, \"activeElement\", {\n    get: function () {\n      return this._activeElement;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FocusZone.prototype._evaluateFocusBeforeRender = function () {\n    var root = this._root.current;\n    var doc = this._getDocument();\n    if (doc) {\n      var focusedElement = doc.activeElement;\n      // Only update the index path if we are not parked on the root.\n      if (focusedElement !== root) {\n        var shouldRestoreFocus = elementContains(root, focusedElement, false);\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : undefined;\n      }\n    }\n  };\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  FocusZone.prototype._setParkedFocus = function (isParked) {\n    var root = this._root.current;\n    if (root && this._isParked !== isParked) {\n      this._isParked = isParked;\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = root.getAttribute('tabindex');\n          root.setAttribute('tabindex', '-1');\n        }\n        root.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          root.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          root.removeAttribute('tabindex');\n        }\n      }\n    }\n  };\n  FocusZone.prototype._setActiveElement = function (element, forceAlignment) {\n    var previousActiveElement = this._activeElement;\n    this._activeElement = element;\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this._updateTabIndexes(previousActiveElement);\n      }\n      previousActiveElement.tabIndex = -1;\n    }\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this._setFocusAlignment(element, true, true);\n      }\n      this._activeElement.tabIndex = 0;\n    }\n  };\n  FocusZone.prototype._preventDefaultWhenHandled = function (ev) {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  };\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  FocusZone.prototype._tryInvokeClickForFocusable = function (targetElement, ev) {\n    var target = targetElement;\n    if (target === this._root.current) {\n      return false;\n    }\n    do {\n      if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SUMMARY') {\n        return false;\n      }\n      if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {\n        raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n    } while (target !== this._root.current);\n    return false;\n  };\n  /**\n   * Traverse to find first child zone.\n   */\n  FocusZone.prototype._getFirstInnerZone = function (rootElement) {\n    rootElement = rootElement || this._activeElement || this._root.current;\n    if (!rootElement) {\n      return null;\n    }\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n    }\n    var child = rootElement.firstElementChild;\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n      }\n      var match = this._getFirstInnerZone(child);\n      if (match) {\n        return match;\n      }\n      child = child.nextElementSibling;\n    }\n    return null;\n  };\n  FocusZone.prototype._moveFocus = function (isForward,\n  // eslint-disable-next-line deprecation/deprecation\n  getDistanceFromCenter, ev, useDefaultWrap) {\n    if (useDefaultWrap === void 0) {\n      useDefaultWrap = true;\n    }\n    var element = this._activeElement;\n    var candidateDistance = -1;\n    var candidateElement = undefined;\n    var changedFocus = false;\n    var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element, isForward)) {\n        return false;\n      }\n    }\n    var activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n    do {\n      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);\n      if (isBidirectional) {\n        if (element) {\n          var targetRect = element.getBoundingClientRect();\n          // eslint-disable-next-line deprecation/deprecation\n          var elementDistance = getDistanceFromCenter(activeRect, targetRect);\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n      } else {\n        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n      }\n    }\n    return changedFocus;\n  };\n  FocusZone.prototype._moveFocusDown = function () {\n    var _this = this;\n    var targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n    if (\n    // eslint-disable-next-line deprecation/deprecation\n    this._moveFocus(true, function (activeRect, targetRect) {\n      var distance = -1;\n      // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectBottom = Math.floor(activeRect.bottom);\n      if (targetRectTop < activeRectBottom) {\n        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n        }\n        return LARGE_DISTANCE_FROM_CENTER;\n      }\n      if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {\n        targetTop = targetRectTop;\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          distance = 0;\n        } else {\n          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n        }\n      }\n      return distance;\n    })) {\n      this._setFocusAlignment(this._activeElement, false, true);\n      return true;\n    }\n    return false;\n  };\n  FocusZone.prototype._moveFocusUp = function () {\n    var _this = this;\n    var targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n    if (\n    // eslint-disable-next-line deprecation/deprecation\n    this._moveFocus(false, function (activeRect, targetRect) {\n      var distance = -1;\n      // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n      var targetRectBottom = Math.floor(targetRect.bottom);\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectTop = Math.floor(activeRect.top);\n      if (targetRectBottom > activeRectTop) {\n        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n        }\n        return LARGE_DISTANCE_FROM_CENTER;\n      }\n      if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {\n        targetTop = targetRectTop;\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          distance = 0;\n        } else {\n          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n        }\n      }\n      return distance;\n    })) {\n      this._setFocusAlignment(this._activeElement, false, true);\n      return true;\n    }\n    return false;\n  };\n  FocusZone.prototype._moveFocusLeft = function (theme) {\n    var _this = this;\n    var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n    if (this._moveFocus(getRTL(theme),\n    // eslint-disable-next-line deprecation/deprecation\n    function (activeRect, targetRect) {\n      var distance = -1;\n      var topBottomComparison;\n      if (getRTL(theme)) {\n        // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n        // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n        // This is important, because we want to be comparing the top of the target rect\n        // with the bottom of the active rect.\n        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n      } else {\n        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n      }\n      if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {\n        distance = activeRect.right - targetRect.right;\n      } else if (!shouldWrap) {\n        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n      return distance;\n    }, undefined /*ev*/, shouldWrap)) {\n      this._setFocusAlignment(this._activeElement, true, false);\n      return true;\n    }\n    return false;\n  };\n  FocusZone.prototype._moveFocusRight = function (theme) {\n    var _this = this;\n    var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n    if (this._moveFocus(!getRTL(theme),\n    // eslint-disable-next-line deprecation/deprecation\n    function (activeRect, targetRect) {\n      var distance = -1;\n      var topBottomComparison;\n      if (getRTL(theme)) {\n        // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n        // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n        // This is important, because we want to be comparing the bottom of the target rect\n        // with the top of the active rect.\n        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n      } else {\n        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n      }\n      if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {\n        distance = targetRect.left - activeRect.left;\n      } else if (!shouldWrap) {\n        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n      return distance;\n    }, undefined /*ev*/, shouldWrap)) {\n      this._setFocusAlignment(this._activeElement, true, false);\n      return true;\n    }\n    return false;\n  };\n  FocusZone.prototype._moveFocusPaging = function (isForward, useDefaultWrap) {\n    if (useDefaultWrap === void 0) {\n      useDefaultWrap = true;\n    }\n    var element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element, isForward)) {\n        return false;\n      }\n    }\n    var scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    var candidateDistance = -1;\n    var candidateElement = undefined;\n    var targetTop = -1;\n    var targetBottom = -1;\n    var pagesize = scrollableParent.clientHeight;\n    var activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);\n      if (element) {\n        var targetRect = element.getBoundingClientRect();\n        var targetRectTop = Math.floor(targetRect.top);\n        var activeRectBottom = Math.floor(activeRect.bottom);\n        var targetRectBottom = Math.floor(targetRect.bottom);\n        var activeRectTop = Math.floor(activeRect.top);\n        var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n    var changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this._setFocusAlignment(candidateElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n      }\n      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n    }\n    return changedFocus;\n  };\n  FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {\n    if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {\n      var rect = element.getBoundingClientRect();\n      var left = rect.left + rect.width / 2;\n      var top_1 = rect.top + rect.height / 2;\n      if (!this._focusAlignment) {\n        this._focusAlignment = {\n          left: left,\n          top: top_1\n        };\n      }\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n      if (isVertical) {\n        this._focusAlignment.top = top_1;\n      }\n    }\n  };\n  FocusZone.prototype._isImmediateDescendantOfZone = function (element) {\n    return this._getOwnerZone(element) === this._root.current;\n  };\n  FocusZone.prototype._getOwnerZone = function (element) {\n    var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);\n    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n    return parentElement;\n  };\n  FocusZone.prototype._updateTabIndexes = function (element) {\n    if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'function') {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current);\n    }\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\n        this._activeElement = null;\n      }\n    }\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement, undefined, this._inShadowRoot)) {\n      this._activeElement = null;\n    }\n    var childNodes = element && element.children;\n    for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      var child = childNodes[childIndex];\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n        if (isElementTabbable(child, undefined, this._inShadowRoot)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n      this._updateTabIndexes(child);\n    }\n  };\n  FocusZone.prototype._isContentEditableElement = function (element) {\n    return element && element.getAttribute('contenteditable') === 'true';\n  };\n  FocusZone.prototype._isElementInput = function (element) {\n    if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {\n      return true;\n    }\n    return false;\n  };\n  FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {\n    // If a tab was used, we want to focus on the next element.\n    if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {\n      var selectionStart = element.selectionStart;\n      var selectionEnd = element.selectionEnd;\n      var isRangeSelected = selectionStart !== selectionEnd;\n      var inputValue = element.value;\n      var isReadonly = element.readOnly;\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length, it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n      // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n      // determined by calling the callback shouldInputLoseFocusOnArrowKey\n      if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  FocusZone.prototype._shouldWrapFocus = function (element, noWrapDataAttribute) {\n    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  };\n  /**\n   * Returns true if the element is a descendant of the FocusZone through a React portal.\n   */\n  FocusZone.prototype._portalContainsElement = function (element) {\n    return element && !!this._root.current && portalContainsElement(element, this._root.current);\n  };\n  FocusZone.prototype._getDocument = function () {\n    return getDocument(this._root.current);\n  };\n  FocusZone.contextType = MergeStylesShadowRootContext;\n  FocusZone.defaultProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    shouldRaiseClicks: true,\n    // Hardcoding uncontrolled flag for proper interop with FluentUI V9.\n    'data-tabster': '{\"uncontrolled\": {}}'\n  };\n  return FocusZone;\n}(React.Component);\nexport { FocusZone };","map":{"version":3,"names":["React","FocusZoneDirection","FocusZoneTabbableElements","KeyCodes","css","elementContains","getDocument","getElementIndexPath","getFocusableByIndexPath","getId","getNativeProps","getNextElement","getParent","getPreviousElement","getRTL","htmlElementProperties","initializeComponentRef","isElementFocusSubZone","isElementFocusZone","isElementTabbable","shouldWrapFocus","warnDeprecations","portalContainsElement","findScrollableParent","createMergedRef","isElementVisibleAndNotHidden","MergeStylesShadowRootContext","mergeStyles","getTheme","IS_FOCUSABLE_ATTRIBUTE","IS_ENTER_DISABLED_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","TABINDEX","NO_VERTICAL_WRAP","NO_HORIZONTAL_WRAP","LARGE_DISTANCE_FROM_CENTER","LARGE_NEGATIVE_DISTANCE_FROM_CENTER","focusZoneStyles","focusZoneClass","raiseClickFromKeyboardEvent","target","ev","event","MouseEvent","ctrlKey","metaKey","shiftKey","altKey","bubbles","cancelable","document","createEvent","initMouseEvent","window","dispatchEvent","getRootClass","selectors","outline","_allInstances","_outerZones","Set","ALLOWED_INPUT_TYPES","ALLOW_VIRTUAL_ELEMENTS","FocusZone","_super","__extends","props","_this","call","_root","createRef","_mergedRef","_onFocus","_portalContainsElement","_a","onActiveElementChanged","doNotAllowFocusEventToPropagate","stopFocusPropagation","onFocusNotification","onFocus","shouldFocusInnerElementWhenReceivedFocus","defaultTabbableElement","isImmediateDescendant","_isImmediateDescendantOfZone","newActiveElement","parentElement","current","undefined","_inShadowRoot","maybeElementToFocus","focus","_activeElement","initialElementFocused","_setFocusAlignment","_updateTabIndexes","stopPropagation","_onBlur","_setParkedFocus","_onMouseDown","disabled","path","push","length","pop","_setActiveElement","_onKeyDown","theme","direction","isInnerZoneKeystroke","pagingSupportDisabled","shouldEnterInnerZone","onKeyDown","isDefaultPrevented","_getDocument","activeElement","_isInnerZone","innerZone","_getFirstInnerZone","focusElement","firstChild","which","space","_shouldRaiseClicksOnSpace","_tryInvokeClickForFocusable","left","vertical","_preventDefaultWhenHandled","_moveFocusLeft","right","_moveFocusRight","up","horizontal","_moveFocusUp","down","_moveFocusDown","pageDown","_moveFocusPaging","pageUp","tab","allowTabKey","handleTabKey","all","inputOnly","_isElementInput","focusChanged","_processingTabKey","_shouldWrapFocus","tabWithDirection","shouldResetActiveElementWhenTabFromZone","home","_isContentEditableElement","_shouldInputLoseFocus","end","lastChild","enter","_shouldRaiseClicksOnEnter","preventDefault","_getHorizontalDistanceFromCenter","isForward","activeRect","targetRect","leftAlignment","_focusAlignment","x","targetRectTop","Math","floor","top","activeRectBottom","bottom","targetRectBottom","activeRectTop","isValidCandidateOnpagingDown","isValidCandidateOnpagingUp","width","abs","process","env","NODE_ENV","rootProps","elementType","ariaDescribedBy","ariaLabelledBy","_id","shouldRaiseClicksFallback","_b","shouldRaiseClicks","defaultProps","_c","shouldRaiseClicksOnEnter","_d","shouldRaiseClicksOnSpace","getOuterZones","size","_onKeyDownCapture","forEach","zone","prototype","componentDidMount","root","context","shadowRoot","body","nodeType","add","addEventListener","querySelector","defaultActiveElement","shouldFocusOnMount","componentDidUpdate","doc","_defaultFocusElement","preventFocusRestoration","_lastIndexPath","elementToFocus","componentWillUnmount","delete","removeEventListener","render","tag","as","className","divProps","Tag","_evaluateFocusBeforeRender","createElement","__assign","ref","elementRef","onMouseDownCapture","children","forceIntoFirstElement","bypassHiddenElements","getAttribute","ownerZoneElement","_getOwnerZone","ownerZone","focusLast","element","forceAlignment","onBeforeFocus","shouldReceiveFocus","setFocusAlignment","point","Object","defineProperty","get","focusedElement","shouldRestoreFocus","isParked","_isParked","allowFocusRoot","_parkedTabIndex","setAttribute","removeAttribute","previousActiveElement","tabIndex","preventDefaultWhenHandled","targetElement","tagName","rootElement","child","firstElementChild","match","nextElementSibling","_moveFocus","getDistanceFromCenter","useDefaultWrap","candidateDistance","candidateElement","changedFocus","isBidirectional","bidirectional","getBoundingClientRect","elementDistance","isCircularNavigation","lastElementChild","targetTop","distance","shouldWrap","topBottomComparison","parseFloat","toFixed","scrollableParent","targetBottom","pagesize","clientHeight","isElementPassedPageSizeOnPagingDown","isElementPassedPageSizeOnPagingUp","isHorizontal","isVertical","rect","top_1","height","childNodes","childIndex","toLowerCase","type","indexOf","selectionStart","selectionEnd","isRangeSelected","inputValue","value","isReadonly","readOnly","shouldInputLoseFocusOnArrowKey","noWrapDataAttribute","checkForNoWrap","contextType","Component"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react-focus\\lib\\components\\src\\components\\FocusZone\\FocusZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport {\n  KeyCodes,\n  css,\n  elementContains,\n  getDocument,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  getId,\n  getNativeProps,\n  getNextElement,\n  getParent,\n  getPreviousElement,\n  getRTL,\n  htmlElementProperties,\n  initializeComponentRef,\n  isElementFocusSubZone,\n  isElementFocusZone,\n  isElementTabbable,\n  shouldWrapFocus,\n  warnDeprecations,\n  portalContainsElement,\n  findScrollableParent,\n  createMergedRef,\n  isElementVisibleAndNotHidden,\n  MergeStylesShadowRootContext,\n} from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nimport type { IFocusZone, IFocusZoneProps } from './FocusZone.types';\nimport type { Point } from '@fluentui/utilities';\nimport type { ITheme } from '@fluentui/style-utilities';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst TABINDEX = 'tabindex';\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\n\nlet focusZoneStyles: string;\n\nconst focusZoneClass: string = 'ms-FocusZone';\n\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target: Element, ev?: React.KeyboardEvent<HTMLElement>): void {\n  let event;\n  if (typeof MouseEvent === 'function') {\n    event = new MouseEvent('click', {\n      ctrlKey: ev?.ctrlKey,\n      metaKey: ev?.metaKey,\n      shiftKey: ev?.shiftKey,\n      altKey: ev?.altKey,\n      bubbles: ev?.bubbles,\n      cancelable: ev?.cancelable,\n    });\n  } else {\n    // eslint-disable-next-line no-restricted-globals\n    event = document.createEvent('MouseEvents');\n    // eslint-disable-next-line deprecation/deprecation\n    event.initMouseEvent(\n      'click',\n      ev ? ev.bubbles : false,\n      ev ? ev.cancelable : false,\n      // eslint-disable-next-line no-restricted-globals\n      window, // not using getWindow() since this can only be run client side\n      0, // detail\n      0, // screen x\n      0, // screen y\n      0, // client x\n      0, // client y\n      ev ? ev.ctrlKey : false,\n      ev ? ev.altKey : false,\n      ev ? ev.shiftKey : false,\n      ev ? ev.metaKey : false,\n      0, // button\n      null, // relatedTarget\n    );\n  }\n\n  target.dispatchEvent(event);\n}\n\n// Helper function that will return a class for when the root is focused\nfunction getRootClass(): string {\n  if (!focusZoneStyles) {\n    focusZoneStyles = mergeStyles(\n      {\n        selectors: {\n          ':focus': {\n            outline: 'none',\n          },\n        },\n      },\n      focusZoneClass,\n    );\n  }\n  return focusZoneStyles;\n}\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\nconst _outerZones: Set<FocusZone> = new Set();\n\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\ninterface IFocusZonePropsWithTabster extends IFocusZoneProps {\n  'data-tabster': string;\n}\n\nexport class FocusZone extends React.Component<IFocusZoneProps> implements IFocusZone {\n  public static contextType = MergeStylesShadowRootContext;\n\n  public static defaultProps: IFocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    shouldRaiseClicks: true,\n    // Hardcoding uncontrolled flag for proper interop with FluentUI V9.\n    'data-tabster': '{\"uncontrolled\": {}}',\n  } as IFocusZonePropsWithTabster;\n\n  private _root: React.RefObject<HTMLElement> = React.createRef();\n  private _mergedRef = createMergedRef<HTMLElement>();\n\n  private _id: string;\n\n  /** The most recently focused child element. */\n  private _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  private _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  private _isParked: boolean;\n\n  /** The child element with tabindex=0. */\n  private _defaultFocusElement: HTMLElement | null;\n  private _focusAlignment: Point;\n  private _isInnerZone: boolean;\n  private _parkedTabIndex: string | null | undefined;\n\n  /** Used to allow moving to next focusable element even when we're focusing on a input element when pressing tab */\n  private _processingTabKey: boolean;\n\n  /** Provides granular control over `shouldRaiseClicks` and should be preferred over `props.shouldRaiseClicks`. */\n  private _shouldRaiseClicksOnEnter: boolean;\n  private _shouldRaiseClicksOnSpace: boolean;\n\n  private _inShadowRoot: boolean;\n\n  /** Used for testing purposes only. */\n  public static getOuterZones(): number {\n    return _outerZones.size;\n  }\n\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n   * for ref counting to work correctly!\n   */\n  private static _onKeyDownCapture(ev: KeyboardEvent): void {\n    // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n    if (ev.which === KeyCodes.tab) {\n      _outerZones.forEach((zone: FocusZone) => zone._updateTabIndexes());\n    }\n  }\n\n  constructor(props: IFocusZoneProps) {\n    super(props);\n    // Manage componentRef resolution.\n    initializeComponentRef(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('FocusZone', props, {\n        rootProps: undefined,\n        allowTabKey: 'handleTabKey',\n        elementType: 'as',\n        ariaDescribedBy: 'aria-describedby',\n        ariaLabelledBy: 'aria-labelledby',\n      });\n    }\n\n    this._id = getId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n\n    const shouldRaiseClicksFallback = props.shouldRaiseClicks ?? FocusZone.defaultProps.shouldRaiseClicks ?? true;\n    this._shouldRaiseClicksOnEnter = props.shouldRaiseClicksOnEnter ?? shouldRaiseClicksFallback;\n    this._shouldRaiseClicksOnSpace = props.shouldRaiseClicksOnSpace ?? shouldRaiseClicksFallback;\n  }\n\n  public componentDidMount(): void {\n    const { current: root } = this._root;\n\n    this._inShadowRoot = !!this.context?.shadowRoot;\n\n    _allInstances[this._id] = this;\n\n    if (root) {\n      let parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n\n      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n        if (isElementFocusZone(parentElement)) {\n          this._isInnerZone = true;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      if (!this._isInnerZone) {\n        _outerZones.add(this);\n\n        this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n      }\n\n      this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n\n      // Assign initial tab indexes so that we can set initial focus as appropriate.\n      this._updateTabIndexes();\n\n      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement) as HTMLElement;\n        // eslint-disable-next-line deprecation/deprecation\n      } else if (this.props.defaultActiveElement) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement) as HTMLElement;\n      }\n\n      if (this.props.shouldFocusOnMount) {\n        this.focus();\n      }\n    }\n  }\n\n  public componentDidUpdate(): void {\n    const { current: root } = this._root;\n    const doc = this._getDocument();\n    this._inShadowRoot = !!this.context?.shadowRoot;\n\n    // If either _activeElement or _defaultFocusElement are no longer contained by _root,\n    // reset those variables (and update tab indexes) to avoid memory leaks\n    if (\n      (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) ||\n      (this._defaultFocusElement &&\n        !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS))\n    ) {\n      this._activeElement = null;\n      this._defaultFocusElement = null;\n      this._updateTabIndexes();\n    }\n\n    if (\n      !this.props.preventFocusRestoration &&\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(root as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this._setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this._setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this._setParkedFocus(true);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  public render(): React.ReactNode {\n    // eslint-disable-next-line deprecation/deprecation\n    const { as: tag, elementType, rootProps, ariaDescribedBy, ariaLabelledBy, className } = this.props;\n    const divProps = getNativeProps(this.props, htmlElementProperties);\n\n    const Tag = tag || elementType || 'div';\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this._evaluateFocusBeforeRender();\n\n    // Only support RTL defined in global theme, not contextual theme/RTL.\n    const theme: ITheme = getTheme();\n\n    return (\n      <Tag\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        {...divProps}\n        {\n          // root props has been deprecated and should get removed.\n          // it needs to be marked as \"any\" since root props expects a div element, but really Tag can\n          // be any native element so typescript rightly flags this as a problem.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ...(rootProps as any)\n        }\n        // Once the getClassName correctly memoizes inputs this should\n        // be replaced so that className is passed to getRootClass and is included there so\n        // the class names will always be in the same order.\n        className={css(getRootClass(), className)}\n        // eslint-disable-next-line deprecation/deprecation\n        ref={this._mergedRef(this.props.elementRef, this._root)}\n        data-focuszone-id={this._id}\n        // eslint-disable-next-line react/jsx-no-bind\n        onKeyDown={(ev: React.KeyboardEvent<HTMLElement>) => this._onKeyDown(ev, theme)}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement: boolean = false, bypassHiddenElements: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this._getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      } else if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement) &&\n        isElementTabbable(this._activeElement, undefined, this._inShadowRoot) &&\n        (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))\n      ) {\n        this._activeElement.focus();\n        return true;\n      } else {\n        const firstChild = this._root.current.firstChild as HTMLElement;\n\n        return this.focusElement(\n          getNextElement(\n            this._root.current,\n            firstChild,\n            true,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            bypassHiddenElements,\n          ) as HTMLElement,\n        );\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(element: HTMLElement, forceAlignment?: boolean): boolean {\n    // eslint-disable-next-line deprecation/deprecation\n    const { onBeforeFocus, shouldReceiveFocus } = this.props;\n\n    if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {\n      return false;\n    }\n\n    if (element) {\n      // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n      this._setActiveElement(element, forceAlignment);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n   * rather than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  public setFocusAlignment(point: Point): void {\n    this._focusAlignment = point;\n  }\n\n  public get defaultFocusElement() {\n    return this._defaultFocusElement;\n  }\n\n  public get activeElement() {\n    return this._activeElement;\n  }\n\n  private _evaluateFocusBeforeRender(): void {\n    const { current: root } = this._root;\n\n    const doc = this._getDocument();\n    if (doc) {\n      const focusedElement = doc.activeElement as HTMLElement;\n\n      // Only update the index path if we are not parked on the root.\n      if (focusedElement !== root) {\n        const shouldRestoreFocus = elementContains(root, focusedElement, false);\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root as HTMLElement, focusedElement) : undefined;\n      }\n    }\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const {\n      onActiveElementChanged,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotAllowFocusEventToPropagate,\n      stopFocusPropagation,\n      // eslint-disable-next-line deprecation/deprecation\n      onFocusNotification,\n      onFocus,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n    } = this.props;\n    const isImmediateDescendant = this._isImmediateDescendantOfZone(ev.target as HTMLElement);\n    let newActiveElement: HTMLElement | null | undefined;\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (\n          isElementTabbable(parentElement, undefined, this._inShadowRoot) &&\n          this._isImmediateDescendantOfZone(parentElement)\n        ) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus =\n        defaultTabbableElement &&\n        typeof defaultTabbableElement === 'function' &&\n        this._root.current &&\n        defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus, undefined, this._inShadowRoot)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n          newActiveElement = null;\n        }\n      }\n    }\n\n    const initialElementFocused = !this._activeElement;\n\n    // If the new active element is a child of this zone and received focus,\n    // update alignment an immediate descendant\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      if (isImmediateDescendant || initialElementFocused) {\n        this._setFocusAlignment(newActiveElement, true, true);\n      }\n\n      this._activeElement = newActiveElement;\n\n      if (initialElementFocused) {\n        this._updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n      ev.stopPropagation();\n    }\n\n    if (onFocus) {\n      onFocus(ev);\n    } else if (onFocusNotification) {\n      onFocusNotification();\n    }\n  };\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  private _setParkedFocus(isParked: boolean): void {\n    const { current: root } = this._root;\n\n    if (root && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = root.getAttribute('tabindex');\n          root.setAttribute('tabindex', '-1');\n        }\n        root.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          root.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          root.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  private _onBlur = (): void => {\n    this._setParkedFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target, undefined, this._inShadowRoot)) {\n        this._setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  private _setActiveElement(element: HTMLElement, forceAlignment?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this._updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this._setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  private _preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>, theme: ITheme): boolean | undefined => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { direction, disabled, isInnerZoneKeystroke, pagingSupportDisabled, shouldEnterInnerZone } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return;\n    }\n\n    if (this._getDocument().activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return;\n    }\n\n    if (\n      ((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&\n      this._isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this._getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return;\n        }\n      } else {\n        return;\n      }\n    } else if (ev.altKey) {\n      return;\n    } else {\n      // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.space:\n          if (this._shouldRaiseClicksOnSpace && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.left:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusLeft(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.right:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusRight(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.up:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusUp()) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.down:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusDown()) {\n              break;\n            }\n          }\n          return;\n        case KeyCodes.pageDown:\n          if (!pagingSupportDisabled && this._moveFocusPaging(true)) {\n            break;\n          }\n          return;\n        case KeyCodes.pageUp:\n          if (!pagingSupportDisabled && this._moveFocusPaging(false)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.tab:\n          if (\n            // eslint-disable-next-line deprecation/deprecation\n            this.props.allowTabKey ||\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this._isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (\n              direction === FocusZoneDirection.vertical ||\n              !this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\n            ) {\n              focusChanged = ev.shiftKey ? this._moveFocusUp() : this._moveFocusDown();\n            } else {\n              const tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this._moveFocusLeft(theme) : this._moveFocusRight(theme);\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n              this._activeElement = null;\n            }\n          }\n          return;\n\n        case KeyCodes.home:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.end:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, true))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.enter:\n          if (this._shouldRaiseClicksOnEnter && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        default:\n          return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  private _tryInvokeClickForFocusable(targetElement: HTMLElement, ev?: React.KeyboardEvent<HTMLElement>): boolean {\n    let target = targetElement;\n    if (target === this._root.current) {\n      return false;\n    }\n\n    do {\n      if (\n        target.tagName === 'BUTTON' ||\n        target.tagName === 'A' ||\n        target.tagName === 'INPUT' ||\n        target.tagName === 'TEXTAREA' ||\n        target.tagName === 'SUMMARY'\n      ) {\n        return false;\n      }\n\n      if (\n        this._isImmediateDescendantOfZone(target) &&\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\n      ) {\n        raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    } while (target !== this._root.current);\n\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  private _getFirstInnerZone(rootElement?: HTMLElement | null): FocusZone | null {\n    rootElement = rootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this._getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  private _moveFocus(\n    isForward: boolean,\n    // eslint-disable-next-line deprecation/deprecation\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (\n        isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element)\n      ) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          // eslint-disable-next-line deprecation/deprecation\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      } else {\n        return this.focusElement(\n          getPreviousElement(\n            this._root.current,\n            this._root.current.lastElementChild as HTMLElement,\n            true,\n            true,\n            true,\n          ) as HTMLElement,\n        );\n      }\n    }\n\n    return changedFocus;\n  }\n\n  private _moveFocusDown(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      // eslint-disable-next-line deprecation/deprecation\n      this._moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusUp(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      // eslint-disable-next-line deprecation/deprecation\n      this._moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusLeft(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        getRTL(theme),\n        // eslint-disable-next-line deprecation/deprecation\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusRight(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        !getRTL(theme),\n        // eslint-disable-next-line deprecation/deprecation\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _getHorizontalDistanceFromCenter = (\n    isForward: boolean,\n    // eslint-disable-next-line deprecation/deprecation\n    activeRect: ClientRect,\n    // eslint-disable-next-line deprecation/deprecation\n    targetRect: ClientRect,\n  ): number => {\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n    // ClientRect values can be floats that differ by very small fractions of a decimal.\n    // If the difference between top and bottom are within a pixel then we should treat\n    // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n    // but without Math.Floor they will be handled incorrectly.\n    const targetRectTop = Math.floor(targetRect.top);\n    const activeRectBottom = Math.floor(activeRect.bottom);\n    const targetRectBottom = Math.floor(targetRect.bottom);\n    const activeRectTop = Math.floor(activeRect.top);\n    const isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n    const isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n    if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n      if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n        return 0;\n      }\n      return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n    }\n\n    if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n      return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n    }\n    return LARGE_DISTANCE_FROM_CENTER;\n  };\n\n  private _moveFocusPaging(isForward: boolean, useDefaultWrap: boolean = true): boolean {\n    let element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n    const scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    let candidateDistance = -1;\n    let candidateElement = undefined;\n    let targetTop = -1;\n    let targetBottom = -1;\n    const pagesize = (scrollableParent as HTMLElement).clientHeight;\n    const activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element);\n      if (element) {\n        const targetRect = element.getBoundingClientRect();\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const activeRectTop = Math.floor(activeRect.top);\n        const elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        const isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        const isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    let changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this._setFocusAlignment(candidateElement as HTMLElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n    return changedFocus;\n  }\n\n  private _setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean): void {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  private _isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this._getOwnerZone(element) === this._root.current;\n  }\n\n  private _getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return parentElement;\n  }\n\n  private _updateTabIndexes(element?: HTMLElement): void {\n    if (\n      !this._activeElement &&\n      this.props.defaultTabbableElement &&\n      typeof this.props.defaultTabbableElement === 'function'\n    ) {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current as HTMLElement);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement, undefined, this._inShadowRoot)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child, undefined, this._inShadowRoot)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this._updateTabIndexes(child);\n    }\n  }\n\n  private _isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  private _isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _shouldInputLoseFocus(element: HTMLInputElement | HTMLTextAreaElement, isForward?: boolean): boolean {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n      const isReadonly = element.readOnly;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length, it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n      // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n      // determined by calling the callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward && !isReadonly) ||\n        (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _shouldWrapFocus(\n    element: HTMLElement,\n    noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  ): boolean {\n    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  }\n\n  /**\n   * Returns true if the element is a descendant of the FocusZone through a React portal.\n   */\n  private _portalContainsElement(element: HTMLElement): boolean {\n    return element && !!this._root.current && portalContainsElement(element, this._root.current);\n  }\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,kBAAkB,EAAEC,yBAAyB,QAAQ,mBAAmB;AACjF,SACEC,QAAQ,EACRC,GAAG,EACHC,eAAe,EACfC,WAAW,EACXC,mBAAmB,EACnBC,uBAAuB,EACvBC,KAAK,EACLC,cAAc,EACdC,cAAc,EACdC,SAAS,EACTC,kBAAkB,EAClBC,MAAM,EACNC,qBAAqB,EACrBC,sBAAsB,EACtBC,qBAAqB,EACrBC,kBAAkB,EAClBC,iBAAiB,EACjBC,eAAe,EACfC,gBAAgB,EAChBC,qBAAqB,EACrBC,oBAAoB,EACpBC,eAAe,EACfC,4BAA4B,EAC5BC,4BAA4B,QACvB,qBAAqB;AAC5B,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,QAAQ,QAAQ,2BAA2B;AAKpD,IAAMC,sBAAsB,GAAG,mBAAmB;AAClD,IAAMC,2BAA2B,GAAG,6BAA6B;AACjE,IAAMC,sBAAsB,GAAG,mBAAmB;AAClD,IAAMC,QAAQ,GAAG,UAAU;AAC3B,IAAMC,gBAAgB,GAAG,uBAAuB;AAChD,IAAMC,kBAAkB,GAAG,yBAAyB;AACpD,IAAMC,0BAA0B,GAAG,SAAS;AAC5C,IAAMC,mCAAmC,GAAG,CAAC,SAAS;AAEtD,IAAIC,eAAuB;AAE3B,IAAMC,cAAc,GAAW,cAAc;AAE7C;;;AAGA,SAASC,2BAA2BA,CAACC,MAAe,EAAEC,EAAqC;EACzF,IAAIC,KAAK;EACT,IAAI,OAAOC,UAAU,KAAK,UAAU,EAAE;IACpCD,KAAK,GAAG,IAAIC,UAAU,CAAC,OAAO,EAAE;MAC9BC,OAAO,EAAEH,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEG,OAAO;MACpBC,OAAO,EAAEJ,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEI,OAAO;MACpBC,QAAQ,EAAEL,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEK,QAAQ;MACtBC,MAAM,EAAEN,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEM,MAAM;MAClBC,OAAO,EAAEP,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEO,OAAO;MACpBC,UAAU,EAAER,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEQ;KACjB,CAAC;GACH,MAAM;IACL;IACAP,KAAK,GAAGQ,QAAQ,CAACC,WAAW,CAAC,aAAa,CAAC;IAC3C;IACAT,KAAK,CAACU,cAAc,CAClB,OAAO,EACPX,EAAE,GAAGA,EAAE,CAACO,OAAO,GAAG,KAAK,EACvBP,EAAE,GAAGA,EAAE,CAACQ,UAAU,GAAG,KAAK;IAC1B;IACAI,MAAM;IAAE;IACR,CAAC;IAAE;IACH,CAAC;IAAE;IACH,CAAC;IAAE;IACH,CAAC;IAAE;IACH,CAAC;IAAE;IACHZ,EAAE,GAAGA,EAAE,CAACG,OAAO,GAAG,KAAK,EACvBH,EAAE,GAAGA,EAAE,CAACM,MAAM,GAAG,KAAK,EACtBN,EAAE,GAAGA,EAAE,CAACK,QAAQ,GAAG,KAAK,EACxBL,EAAE,GAAGA,EAAE,CAACI,OAAO,GAAG,KAAK,EACvB,CAAC;IAAE;IACH,IAAI,CACL;;EAGHL,MAAM,CAACc,aAAa,CAACZ,KAAK,CAAC;AAC7B;AAEA;AACA,SAASa,YAAYA,CAAA;EACnB,IAAI,CAAClB,eAAe,EAAE;IACpBA,eAAe,GAAGV,WAAW,CAC3B;MACE6B,SAAS,EAAE;QACT,QAAQ,EAAE;UACRC,OAAO,EAAE;;;KAGd,EACDnB,cAAc,CACf;;EAEH,OAAOD,eAAe;AACxB;AAEA,IAAMqB,aAAa,GAEf,EAAE;AACN,IAAMC,WAAW,GAAmB,IAAIC,GAAG,EAAE;AAE7C,IAAMC,mBAAmB,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,CAAC;AAEvG,IAAMC,sBAAsB,GAAG,KAAK;AAMpC,IAAAC,SAAA,0BAAAC,MAAA;EAA+BC,SAAA,CAAAF,SAAA,EAAAC,MAAA;EA8D7B,SAAAD,UAAYG,KAAsB;;IAAlC,IAAAC,KAAA,GACEH,MAAA,CAAAI,IAAA,OAAMF,KAAK,CAAC;IApDNC,KAAA,CAAAE,KAAK,GAAiCrE,KAAK,CAACsE,SAAS,EAAE;IACvDH,KAAA,CAAAI,UAAU,GAAG/C,eAAe,EAAe;IA+V3C2C,KAAA,CAAAK,QAAQ,GAAG,UAAC/B,EAAiC;MACnD,IAAI0B,KAAI,CAACM,sBAAsB,CAAChC,EAAE,CAACD,MAAqB,CAAC,EAAE;QACzD;QACA;;MAGI,IAAAkC,EAAA,GAUFP,KAAI,CAACD,KAAK;QATZS,sBAAsB,GAAAD,EAAA,CAAAC,sBAAA;QACtB;QACAC,+BAA+B,GAAAF,EAAA,CAAAE,+BAAA;QAC/BC,oBAAoB,GAAAH,EAAA,CAAAG,oBAAA;QACpB;QACAC,mBAAmB,GAAAJ,EAAA,CAAAI,mBAAA;QACnBC,OAAO,GAAAL,EAAA,CAAAK,OAAA;QACPC,wCAAwC,GAAAN,EAAA,CAAAM,wCAAA;QACxCC,sBAAsB,GAAAP,EAAA,CAAAO,sBACV;MACd,IAAMC,qBAAqB,GAAGf,KAAI,CAACgB,4BAA4B,CAAC1C,EAAE,CAACD,MAAqB,CAAC;MACzF,IAAI4C,gBAAgD;MAEpD,IAAIF,qBAAqB,EAAE;QACzBE,gBAAgB,GAAG3C,EAAE,CAACD,MAAqB;OAC5C,MAAM;QACL,IAAI6C,aAAa,GAAG5C,EAAE,CAACD,MAAqB;QAE5C,OAAO6C,aAAa,IAAIA,aAAa,KAAKlB,KAAI,CAACE,KAAK,CAACiB,OAAO,EAAE;UAC5D,IACEnE,iBAAiB,CAACkE,aAAa,EAAEE,SAAS,EAAEpB,KAAI,CAACqB,aAAa,CAAC,IAC/DrB,KAAI,CAACgB,4BAA4B,CAACE,aAAa,CAAC,EAChD;YACAD,gBAAgB,GAAGC,aAAa;YAChC;;UAEFA,aAAa,GAAGzE,SAAS,CAACyE,aAAa,EAAEvB,sBAAsB,CAAgB;;;MAInF;MACA,IAAIkB,wCAAwC,IAAIvC,EAAE,CAACD,MAAM,KAAK2B,KAAI,CAACE,KAAK,CAACiB,OAAO,EAAE;QAChF,IAAMG,mBAAmB,GACvBR,sBAAsB,IACtB,OAAOA,sBAAsB,KAAK,UAAU,IAC5Cd,KAAI,CAACE,KAAK,CAACiB,OAAO,IAClBL,sBAAsB,CAACd,KAAI,CAACE,KAAK,CAACiB,OAAO,CAAC;QAE5C;QACA,IAAIG,mBAAmB,IAAItE,iBAAiB,CAACsE,mBAAmB,EAAEF,SAAS,EAAEpB,KAAI,CAACqB,aAAa,CAAC,EAAE;UAChGJ,gBAAgB,GAAGK,mBAAmB;UACtCA,mBAAmB,CAACC,KAAK,EAAE;SAC5B,MAAM;UACL;UACAvB,KAAI,CAACuB,KAAK,CAAC,IAAI,CAAC;UAChB,IAAIvB,KAAI,CAACwB,cAAc,EAAE;YACvB;YACAP,gBAAgB,GAAG,IAAI;;;;MAK7B,IAAMQ,qBAAqB,GAAG,CAACzB,KAAI,CAACwB,cAAc;MAElD;MACA;MACA,IAAIP,gBAAgB,IAAIA,gBAAgB,KAAKjB,KAAI,CAACwB,cAAc,EAAE;QAChE,IAAIT,qBAAqB,IAAIU,qBAAqB,EAAE;UAClDzB,KAAI,CAAC0B,kBAAkB,CAACT,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC;;QAGvDjB,KAAI,CAACwB,cAAc,GAAGP,gBAAgB;QAEtC,IAAIQ,qBAAqB,EAAE;UACzBzB,KAAI,CAAC2B,iBAAiB,EAAE;;;MAI5B,IAAInB,sBAAsB,EAAE;QAC1BA,sBAAsB,CAACR,KAAI,CAACwB,cAA6B,EAAElD,EAAE,CAAC;;MAGhE,IAAIoC,oBAAoB,IAAID,+BAA+B,EAAE;QAC3DnC,EAAE,CAACsD,eAAe,EAAE;;MAGtB,IAAIhB,OAAO,EAAE;QACXA,OAAO,CAACtC,EAAE,CAAC;OACZ,MAAM,IAAIqC,mBAAmB,EAAE;QAC9BA,mBAAmB,EAAE;;IAEzB,CAAC;IA+BOX,KAAA,CAAA6B,OAAO,GAAG;MAChB7B,KAAI,CAAC8B,eAAe,CAAC,KAAK,CAAC;IAC7B,CAAC;IAEO9B,KAAA,CAAA+B,YAAY,GAAG,UAACzD,EAAiC;MACvD,IAAI0B,KAAI,CAACM,sBAAsB,CAAChC,EAAE,CAACD,MAAqB,CAAC,EAAE;QACzD;QACA;;MAGM,IAAA2D,QAAQ,GAAKhC,KAAI,CAACD,KAAK,CAAAiC,QAAf;MAEhB,IAAIA,QAAQ,EAAE;QACZ;;MAGF,IAAI3D,MAAM,GAAGC,EAAE,CAACD,MAAqB;MACrC,IAAM4D,IAAI,GAAG,EAAE;MAEf,OAAO5D,MAAM,IAAIA,MAAM,KAAK2B,KAAI,CAACE,KAAK,CAACiB,OAAO,EAAE;QAC9Cc,IAAI,CAACC,IAAI,CAAC7D,MAAM,CAAC;QACjBA,MAAM,GAAG5B,SAAS,CAAC4B,MAAM,EAAEsB,sBAAsB,CAAgB;;MAGnE,OAAOsC,IAAI,CAACE,MAAM,EAAE;QAClB9D,MAAM,GAAG4D,IAAI,CAACG,GAAG,EAAiB;QAElC,IAAI/D,MAAM,IAAIrB,iBAAiB,CAACqB,MAAM,EAAE+C,SAAS,EAAEpB,KAAI,CAACqB,aAAa,CAAC,EAAE;UACtErB,KAAI,CAACqC,iBAAiB,CAAChE,MAAM,EAAE,IAAI,CAAC;;QAGtC,IAAItB,kBAAkB,CAACsB,MAAM,CAAC,EAAE;UAC9B;UACA;;;IAGN,CAAC;IA4BD;;;IAGQ2B,KAAA,CAAAsC,UAAU,GAAG,UAAChE,EAAoC,EAAEiE,KAAa;MACvE,IAAIvC,KAAI,CAACM,sBAAsB,CAAChC,EAAE,CAACD,MAAqB,CAAC,EAAE;QACzD;QACA;;MAGF;MACM,IAAAkC,EAAA,GAA6FP,KAAI,CAACD,KAAK;QAArGyC,SAAS,GAAAjC,EAAA,CAAAiC,SAAA;QAAER,QAAQ,GAAAzB,EAAA,CAAAyB,QAAA;QAAES,oBAAoB,GAAAlC,EAAA,CAAAkC,oBAAA;QAAEC,qBAAqB,GAAAnC,EAAA,CAAAmC,qBAAA;QAAEC,oBAAoB,GAAApC,EAAA,CAAAoC,oBAAe;MAE7G,IAAIX,QAAQ,EAAE;QACZ;;MAGF,IAAIhC,KAAI,CAACD,KAAK,CAAC6C,SAAS,EAAE;QACxB5C,KAAI,CAACD,KAAK,CAAC6C,SAAS,CAACtE,EAAE,CAAC;;MAG1B;MACA,IAAIA,EAAE,CAACuE,kBAAkB,EAAE,EAAE;QAC3B;;MAGF,IAAI7C,KAAI,CAAC8C,YAAY,EAAE,CAACC,aAAa,KAAK/C,KAAI,CAACE,KAAK,CAACiB,OAAO,IAAInB,KAAI,CAACgD,YAAY,EAAE;QACjF;QACA;QACA;;MAGF,IACE,CAAEL,oBAAoB,IAAIA,oBAAoB,CAACrE,EAAE,CAAC,IAAMmE,oBAAoB,IAAIA,oBAAoB,CAACnE,EAAE,CAAE,KACzG0B,KAAI,CAACgB,4BAA4B,CAAC1C,EAAE,CAACD,MAAqB,CAAC,EAC3D;QACA;QACA,IAAM4E,SAAS,GAAGjD,KAAI,CAACkD,kBAAkB,EAAE;QAE3C,IAAID,SAAS,EAAE;UACb,IAAI,CAACA,SAAS,CAAC1B,KAAK,CAAC,IAAI,CAAC,EAAE;YAC1B;;SAEH,MAAM,IAAIzE,qBAAqB,CAACwB,EAAE,CAACD,MAAqB,CAAC,EAAE;UAC1D,IACE,CAAC2B,KAAI,CAACmD,YAAY,CAChB3G,cAAc,CACZ8B,EAAE,CAACD,MAAqB,EACvBC,EAAE,CAACD,MAAsB,CAAC+E,UAAyB,EACpD,IAAI,CACU,CACjB,EACD;YACA;;SAEH,MAAM;UACL;;OAEH,MAAM,IAAI9E,EAAE,CAACM,MAAM,EAAE;QACpB;OACD,MAAM;QACL;QACA,QAAQN,EAAE,CAAC+E,KAAK;UACd,KAAKrH,QAAQ,CAACsH,KAAK;YACjB,IAAItD,KAAI,CAACuD,yBAAyB,IAAIvD,KAAI,CAACwD,2BAA2B,CAAClF,EAAE,CAACD,MAAqB,EAAEC,EAAE,CAAC,EAAE;cACpG;;YAEF;UAEF,KAAKtC,QAAQ,CAACyH,IAAI;YAChB,IAAIjB,SAAS,KAAK1G,kBAAkB,CAAC4H,QAAQ,EAAE;cAC7C1D,KAAI,CAAC2D,0BAA0B,CAACrF,EAAE,CAAC;cACnC,IAAI0B,KAAI,CAAC4D,cAAc,CAACrB,KAAK,CAAC,EAAE;gBAC9B;;;YAGJ;UAEF,KAAKvG,QAAQ,CAAC6H,KAAK;YACjB,IAAIrB,SAAS,KAAK1G,kBAAkB,CAAC4H,QAAQ,EAAE;cAC7C1D,KAAI,CAAC2D,0BAA0B,CAACrF,EAAE,CAAC;cACnC,IAAI0B,KAAI,CAAC8D,eAAe,CAACvB,KAAK,CAAC,EAAE;gBAC/B;;;YAGJ;UAEF,KAAKvG,QAAQ,CAAC+H,EAAE;YACd,IAAIvB,SAAS,KAAK1G,kBAAkB,CAACkI,UAAU,EAAE;cAC/ChE,KAAI,CAAC2D,0BAA0B,CAACrF,EAAE,CAAC;cACnC,IAAI0B,KAAI,CAACiE,YAAY,EAAE,EAAE;gBACvB;;;YAGJ;UAEF,KAAKjI,QAAQ,CAACkI,IAAI;YAChB,IAAI1B,SAAS,KAAK1G,kBAAkB,CAACkI,UAAU,EAAE;cAC/ChE,KAAI,CAAC2D,0BAA0B,CAACrF,EAAE,CAAC;cACnC,IAAI0B,KAAI,CAACmE,cAAc,EAAE,EAAE;gBACzB;;;YAGJ;UACF,KAAKnI,QAAQ,CAACoI,QAAQ;YACpB,IAAI,CAAC1B,qBAAqB,IAAI1C,KAAI,CAACqE,gBAAgB,CAAC,IAAI,CAAC,EAAE;cACzD;;YAEF;UACF,KAAKrI,QAAQ,CAACsI,MAAM;YAClB,IAAI,CAAC5B,qBAAqB,IAAI1C,KAAI,CAACqE,gBAAgB,CAAC,KAAK,CAAC,EAAE;cAC1D;;YAEF;UAEF,KAAKrI,QAAQ,CAACuI,GAAG;YACf;YACE;YACAvE,KAAI,CAACD,KAAK,CAACyE,WAAW,IACtBxE,KAAI,CAACD,KAAK,CAAC0E,YAAY,KAAK1I,yBAAyB,CAAC2I,GAAG,IACxD1E,KAAI,CAACD,KAAK,CAAC0E,YAAY,KAAK1I,yBAAyB,CAAC4I,SAAS,IAC9D3E,KAAI,CAAC4E,eAAe,CAACtG,EAAE,CAACD,MAAqB,CAAE,EACjD;cACA,IAAIwG,YAAY,GAAG,KAAK;cACxB7E,KAAI,CAAC8E,iBAAiB,GAAG,IAAI;cAC7B,IACEtC,SAAS,KAAK1G,kBAAkB,CAAC4H,QAAQ,IACzC,CAAC1D,KAAI,CAAC+E,gBAAgB,CAAC/E,KAAI,CAACwB,cAA6B,EAAEzD,kBAAkB,CAAC,EAC9E;gBACA8G,YAAY,GAAGvG,EAAE,CAACK,QAAQ,GAAGqB,KAAI,CAACiE,YAAY,EAAE,GAAGjE,KAAI,CAACmE,cAAc,EAAE;eACzE,MAAM;gBACL,IAAMa,gBAAgB,GAAGrI,MAAM,CAAC4F,KAAK,CAAC,GAAG,CAACjE,EAAE,CAACK,QAAQ,GAAGL,EAAE,CAACK,QAAQ;gBACnEkG,YAAY,GAAGG,gBAAgB,GAAGhF,KAAI,CAAC4D,cAAc,CAACrB,KAAK,CAAC,GAAGvC,KAAI,CAAC8D,eAAe,CAACvB,KAAK,CAAC;;cAE5FvC,KAAI,CAAC8E,iBAAiB,GAAG,KAAK;cAC9B,IAAID,YAAY,EAAE;gBAChB;eACD,MAAM,IAAI7E,KAAI,CAACD,KAAK,CAACkF,uCAAuC,EAAE;gBAC7DjF,KAAI,CAACwB,cAAc,GAAG,IAAI;;;YAG9B;UAEF,KAAKxF,QAAQ,CAACkJ,IAAI;YAChB,IACElF,KAAI,CAACmF,yBAAyB,CAAC7G,EAAE,CAACD,MAAqB,CAAC,IACvD2B,KAAI,CAAC4E,eAAe,CAACtG,EAAE,CAACD,MAAqB,CAAC,IAC7C,CAAC2B,KAAI,CAACoF,qBAAqB,CAAC9G,EAAE,CAACD,MAA0B,EAAE,KAAK,CAAE,EACpE;cACA,OAAO,KAAK;;YAEd,IAAM+E,UAAU,GAAGpD,KAAI,CAACE,KAAK,CAACiB,OAAO,IAAKnB,KAAI,CAACE,KAAK,CAACiB,OAAO,CAACiC,UAAiC;YAC9F,IACEpD,KAAI,CAACE,KAAK,CAACiB,OAAO,IAClBiC,UAAU,IACVpD,KAAI,CAACmD,YAAY,CAAC3G,cAAc,CAACwD,KAAI,CAACE,KAAK,CAACiB,OAAO,EAAEiC,UAAU,EAAE,IAAI,CAAgB,CAAC,EACtF;cACA;;YAEF;UAEF,KAAKpH,QAAQ,CAACqJ,GAAG;YACf,IACErF,KAAI,CAACmF,yBAAyB,CAAC7G,EAAE,CAACD,MAAqB,CAAC,IACvD2B,KAAI,CAAC4E,eAAe,CAACtG,EAAE,CAACD,MAAqB,CAAC,IAC7C,CAAC2B,KAAI,CAACoF,qBAAqB,CAAC9G,EAAE,CAACD,MAA0B,EAAE,IAAI,CAAE,EACnE;cACA,OAAO,KAAK;;YAGd,IAAMiH,SAAS,GAAGtF,KAAI,CAACE,KAAK,CAACiB,OAAO,IAAKnB,KAAI,CAACE,KAAK,CAACiB,OAAO,CAACmE,SAAgC;YAC5F,IACEtF,KAAI,CAACE,KAAK,CAACiB,OAAO,IAClBnB,KAAI,CAACmD,YAAY,CAACzG,kBAAkB,CAACsD,KAAI,CAACE,KAAK,CAACiB,OAAO,EAAEmE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAgB,CAAC,EACrG;cACA;;YAEF;UAEF,KAAKtJ,QAAQ,CAACuJ,KAAK;YACjB,IAAIvF,KAAI,CAACwF,yBAAyB,IAAIxF,KAAI,CAACwD,2BAA2B,CAAClF,EAAE,CAACD,MAAqB,EAAEC,EAAE,CAAC,EAAE;cACpG;;YAEF;UAEF;YACE;;;MAINA,EAAE,CAACmH,cAAc,EAAE;MACnBnH,EAAE,CAACsD,eAAe,EAAE;IACtB,CAAC;IAkUO5B,KAAA,CAAA0F,gCAAgC,GAAG,UACzCC,SAAkB;IAClB;IACAC,UAAsB;IACtB;IACAC,UAAsB;MAEtB;MACA,IAAMC,aAAa,GAAG9F,KAAI,CAAC+F,eAAe,CAACtC,IAAI,IAAIzD,KAAI,CAAC+F,eAAe,CAACC,CAAC,IAAI,CAAC;MAC9E;MACA;MACA;MACA;MACA,IAAMC,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACN,UAAU,CAACO,GAAG,CAAC;MAChD,IAAMC,gBAAgB,GAAGH,IAAI,CAACC,KAAK,CAACP,UAAU,CAACU,MAAM,CAAC;MACtD,IAAMC,gBAAgB,GAAGL,IAAI,CAACC,KAAK,CAACN,UAAU,CAACS,MAAM,CAAC;MACtD,IAAME,aAAa,GAAGN,IAAI,CAACC,KAAK,CAACP,UAAU,CAACQ,GAAG,CAAC;MAChD,IAAMK,4BAA4B,GAAGd,SAAS,IAAIM,aAAa,GAAGI,gBAAgB;MAClF,IAAMK,0BAA0B,GAAG,CAACf,SAAS,IAAIY,gBAAgB,GAAGC,aAAa;MAEjF,IAAIC,4BAA4B,IAAIC,0BAA0B,EAAE;QAC9D,IAAIZ,aAAa,IAAID,UAAU,CAACpC,IAAI,IAAIqC,aAAa,IAAID,UAAU,CAACpC,IAAI,GAAGoC,UAAU,CAACc,KAAK,EAAE;UAC3F,OAAO,CAAC;;QAEV,OAAOT,IAAI,CAACU,GAAG,CAACf,UAAU,CAACpC,IAAI,GAAGoC,UAAU,CAACc,KAAK,GAAG,CAAC,GAAGb,aAAa,CAAC;;MAGzE,IAAI,CAAC9F,KAAI,CAAC+E,gBAAgB,CAAC/E,KAAI,CAACwB,cAA6B,EAAE1D,gBAAgB,CAAC,EAAE;QAChF,OAAOG,mCAAmC;;MAE5C,OAAOD,0BAA0B;IACnC,CAAC;IAlgCC;IACAnB,sBAAsB,CAACmD,KAAI,CAAC;IAE5B,IAAI6G,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC7J,gBAAgB,CAAC,WAAW,EAAE6C,KAAK,EAAE;QACnCiH,SAAS,EAAE5F,SAAS;QACpBoD,WAAW,EAAE,cAAc;QAC3ByC,WAAW,EAAE,IAAI;QACjBC,eAAe,EAAE,kBAAkB;QACnCC,cAAc,EAAE;OACjB,CAAC;;IAGJnH,KAAI,CAACoH,GAAG,GAAG9K,KAAK,CAAC,WAAW,CAAC;IAE7B0D,KAAI,CAAC+F,eAAe,GAAG;MACrBtC,IAAI,EAAE,CAAC;MACP2C,GAAG,EAAE;KACN;IAEDpG,KAAI,CAAC8E,iBAAiB,GAAG,KAAK;IAE9B,IAAMuC,yBAAyB,GAAG,CAAAC,EAAA,IAAA/G,EAAA,GAAAR,KAAK,CAACwH,iBAAiB,cAAAhH,EAAA,cAAAA,EAAA,GAAIX,SAAS,CAAC4H,YAAY,CAACD,iBAAiB,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI;IAC7GtH,KAAI,CAACwF,yBAAyB,GAAG,CAAAiC,EAAA,GAAA1H,KAAK,CAAC2H,wBAAwB,cAAAD,EAAA,cAAAA,EAAA,GAAIJ,yBAAyB;IAC5FrH,KAAI,CAACuD,yBAAyB,GAAG,CAAAoE,EAAA,GAAA5H,KAAK,CAAC6H,wBAAwB,cAAAD,EAAA,cAAAA,EAAA,GAAIN,yBAAyB;;EAC9F;EA5CA;EACczH,SAAA,CAAAiI,aAAa,GAA3B;IACE,OAAOrI,WAAW,CAACsI,IAAI;EACzB,CAAC;EAED;;;;;EAKelI,SAAA,CAAAmI,iBAAiB,GAAhC,UAAiCzJ,EAAiB;IAChD;IACA,IAAIA,EAAE,CAAC+E,KAAK,KAAKrH,QAAQ,CAACuI,GAAG,EAAE;MAC7B/E,WAAW,CAACwI,OAAO,CAAC,UAACC,IAAe;QAAK,OAAAA,IAAI,CAACtG,iBAAiB,EAAE;MAAxB,CAAwB,CAAC;;EAEtE,CAAC;EA+BM/B,SAAA,CAAAsI,SAAA,CAAAC,iBAAiB,GAAxB;;IACU,IAASC,IAAI,GAAK,IAAI,CAAClI,KAAK,CAAAiB,OAAf;IAErB,IAAI,CAACE,aAAa,GAAG,CAAC,EAAC,CAAAd,EAAA,OAAI,CAAC8H,OAAO,cAAA9H,EAAA,uBAAAA,EAAA,CAAE+H,UAAU;IAE/C/I,aAAa,CAAC,IAAI,CAAC6H,GAAG,CAAC,GAAG,IAAI;IAE9B,IAAIgB,IAAI,EAAE;MACR,IAAIlH,aAAa,GAAGzE,SAAS,CAAC2L,IAAI,EAAEzI,sBAAsB,CAAC;MAE3D,OAAOuB,aAAa,IAAIA,aAAa,KAAK,IAAI,CAAC4B,YAAY,EAAE,CAACyF,IAAI,IAAIrH,aAAa,CAACsH,QAAQ,KAAK,CAAC,EAAE;QAClG,IAAIzL,kBAAkB,CAACmE,aAAa,CAAC,EAAE;UACrC,IAAI,CAAC8B,YAAY,GAAG,IAAI;UACxB;;QAEF9B,aAAa,GAAGzE,SAAS,CAACyE,aAAa,EAAEvB,sBAAsB,CAAC;;MAGlE,IAAI,CAAC,IAAI,CAACqD,YAAY,EAAE;QACtBxD,WAAW,CAACiJ,GAAG,CAAC,IAAI,CAAC;QAErB,IAAI,CAACvI,KAAK,CAACiB,OAAO,IAAI,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACuH,gBAAgB,CAAC,SAAS,EAAE9I,SAAS,CAACmI,iBAAiB,EAAE,IAAI,CAAC;;MAGzG,IAAI,CAAC7H,KAAK,CAACiB,OAAO,IAAI,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACuH,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC7G,OAAO,EAAE,IAAI,CAAC;MAErF;MACA,IAAI,CAACF,iBAAiB,EAAE;MAExB,IAAI,IAAI,CAAC5B,KAAK,CAACe,sBAAsB,IAAI,OAAO,IAAI,CAACf,KAAK,CAACe,sBAAsB,KAAK,QAAQ,EAAE;QAC9F,IAAI,CAACU,cAAc,GAAG,IAAI,CAACsB,YAAY,EAAE,CAAC6F,aAAa,CAAC,IAAI,CAAC5I,KAAK,CAACe,sBAAsB,CAAgB;QACzG;OACD,MAAM,IAAI,IAAI,CAACf,KAAK,CAAC6I,oBAAoB,EAAE;QAC1C;QACA,IAAI,CAACpH,cAAc,GAAG,IAAI,CAACsB,YAAY,EAAE,CAAC6F,aAAa,CAAC,IAAI,CAAC5I,KAAK,CAAC6I,oBAAoB,CAAgB;;MAGzG,IAAI,IAAI,CAAC7I,KAAK,CAAC8I,kBAAkB,EAAE;QACjC,IAAI,CAACtH,KAAK,EAAE;;;EAGlB,CAAC;EAEM3B,SAAA,CAAAsI,SAAA,CAAAY,kBAAkB,GAAzB;;IACU,IAASV,IAAI,GAAK,IAAI,CAAClI,KAAK,CAAAiB,OAAf;IACrB,IAAM4H,GAAG,GAAG,IAAI,CAACjG,YAAY,EAAE;IAC/B,IAAI,CAACzB,aAAa,GAAG,CAAC,EAAC,CAAAd,EAAA,OAAI,CAAC8H,OAAO,cAAA9H,EAAA,uBAAAA,EAAA,CAAE+H,UAAU;IAE/C;IACA;IACA,IACG,IAAI,CAAC9G,cAAc,IAAI,CAACtF,eAAe,CAAC,IAAI,CAACgE,KAAK,CAACiB,OAAO,EAAE,IAAI,CAACK,cAAc,EAAE7B,sBAAsB,CAAC,IACxG,IAAI,CAACqJ,oBAAoB,IACxB,CAAC9M,eAAe,CAAC,IAAI,CAACgE,KAAK,CAACiB,OAAO,EAAE,IAAI,CAAC6H,oBAAoB,EAAErJ,sBAAsB,CAAE,EAC1F;MACA,IAAI,CAAC6B,cAAc,GAAG,IAAI;MAC1B,IAAI,CAACwH,oBAAoB,GAAG,IAAI;MAChC,IAAI,CAACrH,iBAAiB,EAAE;;IAG1B,IACE,CAAC,IAAI,CAAC5B,KAAK,CAACkJ,uBAAuB,IACnCF,GAAG,IACH,IAAI,CAACG,cAAc,KAClBH,GAAG,CAAChG,aAAa,KAAKgG,GAAG,CAACR,IAAI,IAAIQ,GAAG,CAAChG,aAAa,KAAK,IAAI,IAAIgG,GAAG,CAAChG,aAAa,KAAKqF,IAAI,CAAC,EAC5F;MACA;MACA,IAAMe,cAAc,GAAG9M,uBAAuB,CAAC+L,IAAmB,EAAE,IAAI,CAACc,cAAc,CAAC;MAExF,IAAIC,cAAc,EAAE;QAClB,IAAI,CAAC9G,iBAAiB,CAAC8G,cAAc,EAAE,IAAI,CAAC;QAC5CA,cAAc,CAAC5H,KAAK,EAAE;QACtB,IAAI,CAACO,eAAe,CAAC,KAAK,CAAC;OAC5B,MAAM;QACL;QACA;QACA,IAAI,CAACA,eAAe,CAAC,IAAI,CAAC;;;EAGhC,CAAC;EAEMlC,SAAA,CAAAsI,SAAA,CAAAkB,oBAAoB,GAA3B;IACE,OAAO7J,aAAa,CAAC,IAAI,CAAC6H,GAAG,CAAC;IAE9B,IAAI,CAAC,IAAI,CAACpE,YAAY,EAAE;MACtBxD,WAAW,CAAC6J,MAAM,CAAC,IAAI,CAAC;MAExB,IAAI,CAACnJ,KAAK,CAACiB,OAAO,IAAI,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACmI,mBAAmB,CAAC,SAAS,EAAE1J,SAAS,CAACmI,iBAAiB,EAAE,IAAI,CAAC;;IAG5G,IAAI,IAAI,CAAC7H,KAAK,CAACiB,OAAO,EAAE;MACtB,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACmI,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAACzH,OAAO,EAAE,IAAI,CAAC;;IAGpE,IAAI,CAACL,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACwH,oBAAoB,GAAG,IAAI;EAClC,CAAC;EAEMpJ,SAAA,CAAAsI,SAAA,CAAAqB,MAAM,GAAb;IAAA,IAAAvJ,KAAA;IACE;IACM,IAAAO,EAAA,GAAkF,IAAI,CAACR,KAAK;MAAtFyJ,GAAG,GAAAjJ,EAAA,CAAAkJ,EAAA;MAAExC,WAAW,GAAA1G,EAAA,CAAA0G,WAAA;MAAED,SAAS,GAAAzG,EAAA,CAAAyG,SAAA;MAAEE,eAAe,GAAA3G,EAAA,CAAA2G,eAAA;MAAEC,cAAc,GAAA5G,EAAA,CAAA4G,cAAA;MAAEuC,SAAS,GAAAnJ,EAAA,CAAAmJ,SAAe;IAClG,IAAMC,QAAQ,GAAGpN,cAAc,CAAC,IAAI,CAACwD,KAAK,EAAEnD,qBAAqB,CAAC;IAElE,IAAMgN,GAAG,GAAGJ,GAAG,IAAIvC,WAAW,IAAI,KAAK;IAEvC;IACA;IACA;IACA;IACA;IACA,IAAI,CAAC4C,0BAA0B,EAAE;IAEjC;IACA,IAAMtH,KAAK,GAAW9E,QAAQ,EAAE;IAEhC,OACE5B,KAAA,CAAAiO,aAAA,CAACF,GAAG,EAAAG,QAAA;MAAA,mBACe5C,cAAc;MAAA,oBACbD;IAAe,GAC7ByC,QAAQ,EAMN3C,SAAiB;MAEvB;MACA;MACA;MACA0C,SAAS,EAAEzN,GAAG,CAACmD,YAAY,EAAE,EAAEsK,SAAS,CAAC;MACzC;MACAM,GAAG,EAAE,IAAI,CAAC5J,UAAU,CAAC,IAAI,CAACL,KAAK,CAACkK,UAAU,EAAE,IAAI,CAAC/J,KAAK,CAAC;MAAA,qBACpC,IAAI,CAACkH,GAAG;MAC3B;MACAxE,SAAS,EAAE,SAAAA,CAACtE,EAAoC;QAAK,OAAA0B,KAAI,CAACsC,UAAU,CAAChE,EAAE,EAAEiE,KAAK,CAAC;MAA1B,CAA0B;MAC/E3B,OAAO,EAAE,IAAI,CAACP,QAAQ;MACtB6J,kBAAkB,EAAE,IAAI,CAACnI;IAAY,IAEpC,IAAI,CAAChC,KAAK,CAACoK,QAAQ,CAChB;EAEV,CAAC;EAED;;;;;;;EAOOvK,SAAA,CAAAsI,SAAA,CAAA3G,KAAK,GAAZ,UAAa6I,qBAAsC,EAAEC,oBAAqC;IAA7E,IAAAD,qBAAA;MAAAA,qBAAA,QAAsC;IAAA;IAAE,IAAAC,oBAAA;MAAAA,oBAAA,QAAqC;IAAA;IACxF,IAAI,IAAI,CAACnK,KAAK,CAACiB,OAAO,EAAE;MACtB,IACE,CAACiJ,qBAAqB,IACtB,IAAI,CAAClK,KAAK,CAACiB,OAAO,CAACmJ,YAAY,CAAC5M,sBAAsB,CAAC,KAAK,MAAM,IAClE,IAAI,CAACsF,YAAY,EACjB;QACA,IAAMuH,gBAAgB,GAAG,IAAI,CAACC,aAAa,CAAC,IAAI,CAACtK,KAAK,CAACiB,OAAO,CAAgB;QAE9E,IAAIoJ,gBAAgB,KAAK,IAAI,CAACrK,KAAK,CAACiB,OAAO,EAAE;UAC3C,IAAMsJ,SAAS,GAAGlL,aAAa,CAACgL,gBAAgB,CAACD,YAAY,CAAC1M,sBAAsB,CAAW,CAAC;UAEhG,OAAO,CAAC,CAAC6M,SAAS,IAAIA,SAAS,CAACtH,YAAY,CAAC,IAAI,CAACjD,KAAK,CAACiB,OAAO,CAAC;;QAGlE,OAAO,KAAK;OACb,MAAM,IACL,CAACiJ,qBAAqB,IACtB,IAAI,CAAC5I,cAAc,IACnBtF,eAAe,CAAC,IAAI,CAACgE,KAAK,CAACiB,OAAO,EAAE,IAAI,CAACK,cAAc,CAAC,IACxDxE,iBAAiB,CAAC,IAAI,CAACwE,cAAc,EAAEJ,SAAS,EAAE,IAAI,CAACC,aAAa,CAAC,KACpE,CAACgJ,oBAAoB,IAAI/M,4BAA4B,CAAC,IAAI,CAACkE,cAAc,CAAC,CAAC,EAC5E;QACA,IAAI,CAACA,cAAc,CAACD,KAAK,EAAE;QAC3B,OAAO,IAAI;OACZ,MAAM;QACL,IAAM6B,UAAU,GAAG,IAAI,CAAClD,KAAK,CAACiB,OAAO,CAACiC,UAAyB;QAE/D,OAAO,IAAI,CAACD,YAAY,CACtB3G,cAAc,CACZ,IAAI,CAAC0D,KAAK,CAACiB,OAAO,EAClBiC,UAAU,EACV,IAAI,EACJhC,SAAS,EACTA,SAAS,EACTA,SAAS,EACTA,SAAS,EACTA,SAAS,EACTiJ,oBAAoB,CACN,CACjB;;;IAGL,OAAO,KAAK;EACd,CAAC;EAED;;;;EAIOzK,SAAA,CAAAsI,SAAA,CAAAwC,SAAS,GAAhB;IACE,IAAI,IAAI,CAACxK,KAAK,CAACiB,OAAO,EAAE;MACtB,IAAMmE,SAAS,GAAG,IAAI,CAACpF,KAAK,CAACiB,OAAO,IAAK,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACmE,SAAgC;MAE5F,OAAO,IAAI,CAACnC,YAAY,CAACzG,kBAAkB,CAAC,IAAI,CAACwD,KAAK,CAACiB,OAAO,EAAEmE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAgB,CAAC;;IAG9G,OAAO,KAAK;EACd,CAAC;EAED;;;;;;;;EAQO1F,SAAA,CAAAsI,SAAA,CAAA/E,YAAY,GAAnB,UAAoBwH,OAAoB,EAAEC,cAAwB;IAChE;IACM,IAAArK,EAAA,GAAwC,IAAI,CAACR,KAAK;MAAhD8K,aAAa,GAAAtK,EAAA,CAAAsK,aAAA;MAAEC,kBAAkB,GAAAvK,EAAA,CAAAuK,kBAAe;IAExD,IAAKA,kBAAkB,IAAI,CAACA,kBAAkB,CAACH,OAAO,CAAC,IAAME,aAAa,IAAI,CAACA,aAAa,CAACF,OAAO,CAAE,EAAE;MACtG,OAAO,KAAK;;IAGd,IAAIA,OAAO,EAAE;MACX;MACA,IAAI,CAACtI,iBAAiB,CAACsI,OAAO,EAAEC,cAAc,CAAC;MAC/C,IAAI,IAAI,CAACpJ,cAAc,EAAE;QACvB,IAAI,CAACA,cAAc,CAACD,KAAK,EAAE;;MAG7B,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd,CAAC;EAED;;;;;EAKO3B,SAAA,CAAAsI,SAAA,CAAA6C,iBAAiB,GAAxB,UAAyBC,KAAY;IACnC,IAAI,CAACjF,eAAe,GAAGiF,KAAK;EAC9B,CAAC;EAEDC,MAAA,CAAAC,cAAA,CAAWtL,SAAA,CAAAsI,SAAA,uBAAmB;SAA9B,SAAAiD,CAAA;MACE,OAAO,IAAI,CAACnC,oBAAoB;IAClC,CAAC;;;;EAEDiC,MAAA,CAAAC,cAAA,CAAWtL,SAAA,CAAAsI,SAAA,iBAAa;SAAxB,SAAAiD,CAAA;MACE,OAAO,IAAI,CAAC3J,cAAc;IAC5B,CAAC;;;;EAEO5B,SAAA,CAAAsI,SAAA,CAAA2B,0BAA0B,GAAlC;IACU,IAASzB,IAAI,GAAK,IAAI,CAAClI,KAAK,CAAAiB,OAAf;IAErB,IAAM4H,GAAG,GAAG,IAAI,CAACjG,YAAY,EAAE;IAC/B,IAAIiG,GAAG,EAAE;MACP,IAAMqC,cAAc,GAAGrC,GAAG,CAAChG,aAA4B;MAEvD;MACA,IAAIqI,cAAc,KAAKhD,IAAI,EAAE;QAC3B,IAAMiD,kBAAkB,GAAGnP,eAAe,CAACkM,IAAI,EAAEgD,cAAc,EAAE,KAAK,CAAC;QACvE,IAAI,CAAClC,cAAc,GAAGmC,kBAAkB,GAAGjP,mBAAmB,CAACgM,IAAmB,EAAEgD,cAAc,CAAC,GAAGhK,SAAS;;;EAGrH,CAAC;EA4FD;;;;;;EAMQxB,SAAA,CAAAsI,SAAA,CAAApG,eAAe,GAAvB,UAAwBwJ,QAAiB;IAC/B,IAASlD,IAAI,GAAK,IAAI,CAAClI,KAAK,CAAAiB,OAAf;IAErB,IAAIiH,IAAI,IAAI,IAAI,CAACmD,SAAS,KAAKD,QAAQ,EAAE;MACvC,IAAI,CAACC,SAAS,GAAGD,QAAQ;MAEzB,IAAIA,QAAQ,EAAE;QACZ,IAAI,CAAC,IAAI,CAACvL,KAAK,CAACyL,cAAc,EAAE;UAC9B,IAAI,CAACC,eAAe,GAAGrD,IAAI,CAACkC,YAAY,CAAC,UAAU,CAAC;UACpDlC,IAAI,CAACsD,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC;;QAErCtD,IAAI,CAAC7G,KAAK,EAAE;OACb,MAAM,IAAI,CAAC,IAAI,CAACxB,KAAK,CAACyL,cAAc,EAAE;QACrC,IAAI,IAAI,CAACC,eAAe,EAAE;UACxBrD,IAAI,CAACsD,YAAY,CAAC,UAAU,EAAE,IAAI,CAACD,eAAe,CAAC;UACnD,IAAI,CAACA,eAAe,GAAGrK,SAAS;SACjC,MAAM;UACLgH,IAAI,CAACuD,eAAe,CAAC,UAAU,CAAC;;;;EAIxC,CAAC;EAwCO/L,SAAA,CAAAsI,SAAA,CAAA7F,iBAAiB,GAAzB,UAA0BsI,OAAoB,EAAEC,cAAwB;IACtE,IAAMgB,qBAAqB,GAAG,IAAI,CAACpK,cAAc;IAEjD,IAAI,CAACA,cAAc,GAAGmJ,OAAO;IAE7B,IAAIiB,qBAAqB,EAAE;MACzB,IAAI7O,kBAAkB,CAAC6O,qBAAqB,CAAC,EAAE;QAC7C,IAAI,CAACjK,iBAAiB,CAACiK,qBAAqB,CAAC;;MAG/CA,qBAAqB,CAACC,QAAQ,GAAG,CAAC,CAAC;;IAGrC,IAAI,IAAI,CAACrK,cAAc,EAAE;MACvB,IAAI,CAAC,IAAI,CAACuE,eAAe,IAAI6E,cAAc,EAAE;QAC3C,IAAI,CAAClJ,kBAAkB,CAACiJ,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC;;MAG9C,IAAI,CAACnJ,cAAc,CAACqK,QAAQ,GAAG,CAAC;;EAEpC,CAAC;EAEOjM,SAAA,CAAAsI,SAAA,CAAAvE,0BAA0B,GAAlC,UAAmCrF,EAAoC;IACrE,IAAI,CAACyB,KAAK,CAAC+L,yBAAyB,IAAIxN,EAAE,CAACmH,cAAc,EAAE;EAC7D,CAAC;EAmMD;;;EAGQ7F,SAAA,CAAAsI,SAAA,CAAA1E,2BAA2B,GAAnC,UAAoCuI,aAA0B,EAAEzN,EAAqC;IACnG,IAAID,MAAM,GAAG0N,aAAa;IAC1B,IAAI1N,MAAM,KAAK,IAAI,CAAC6B,KAAK,CAACiB,OAAO,EAAE;MACjC,OAAO,KAAK;;IAGd,GAAG;MACD,IACE9C,MAAM,CAAC2N,OAAO,KAAK,QAAQ,IAC3B3N,MAAM,CAAC2N,OAAO,KAAK,GAAG,IACtB3N,MAAM,CAAC2N,OAAO,KAAK,OAAO,IAC1B3N,MAAM,CAAC2N,OAAO,KAAK,UAAU,IAC7B3N,MAAM,CAAC2N,OAAO,KAAK,SAAS,EAC5B;QACA,OAAO,KAAK;;MAGd,IACE,IAAI,CAAChL,4BAA4B,CAAC3C,MAAM,CAAC,IACzCA,MAAM,CAACiM,YAAY,CAAC5M,sBAAsB,CAAC,KAAK,MAAM,IACtDW,MAAM,CAACiM,YAAY,CAAC3M,2BAA2B,CAAC,KAAK,MAAM,EAC3D;QACAS,2BAA2B,CAACC,MAAM,EAAEC,EAAE,CAAC;QACvC,OAAO,IAAI;;MAGbD,MAAM,GAAG5B,SAAS,CAAC4B,MAAM,EAAEsB,sBAAsB,CAAgB;KAClE,QAAQtB,MAAM,KAAK,IAAI,CAAC6B,KAAK,CAACiB,OAAO;IAEtC,OAAO,KAAK;EACd,CAAC;EAED;;;EAGQvB,SAAA,CAAAsI,SAAA,CAAAhF,kBAAkB,GAA1B,UAA2B+I,WAAgC;IACzDA,WAAW,GAAGA,WAAW,IAAI,IAAI,CAACzK,cAAc,IAAI,IAAI,CAACtB,KAAK,CAACiB,OAAO;IAEtE,IAAI,CAAC8K,WAAW,EAAE;MAChB,OAAO,IAAI;;IAGb,IAAIlP,kBAAkB,CAACkP,WAAW,CAAC,EAAE;MACnC,OAAO1M,aAAa,CAAC0M,WAAW,CAAC3B,YAAY,CAAC1M,sBAAsB,CAAW,CAAC;;IAGlF,IAAIsO,KAAK,GAAGD,WAAW,CAACE,iBAAuC;IAE/D,OAAOD,KAAK,EAAE;MACZ,IAAInP,kBAAkB,CAACmP,KAAK,CAAC,EAAE;QAC7B,OAAO3M,aAAa,CAAC2M,KAAK,CAAC5B,YAAY,CAAC1M,sBAAsB,CAAW,CAAC;;MAE5E,IAAMwO,KAAK,GAAG,IAAI,CAAClJ,kBAAkB,CAACgJ,KAAK,CAAC;MAE5C,IAAIE,KAAK,EAAE;QACT,OAAOA,KAAK;;MAGdF,KAAK,GAAGA,KAAK,CAACG,kBAAwC;;IAGxD,OAAO,IAAI;EACb,CAAC;EAEOzM,SAAA,CAAAsI,SAAA,CAAAoE,UAAU,GAAlB,UACE3G,SAAkB;EAClB;EACA4G,qBAAiF,EACjFjO,EAAU,EACVkO,cAA8B;IAA9B,IAAAA,cAAA;MAAAA,cAAA,OAA8B;IAAA;IAE9B,IAAI7B,OAAO,GAAG,IAAI,CAACnJ,cAAc;IACjC,IAAIiL,iBAAiB,GAAG,CAAC,CAAC;IAC1B,IAAIC,gBAAgB,GAA4BtL,SAAS;IACzD,IAAIuL,YAAY,GAAG,KAAK;IACxB,IAAMC,eAAe,GAAG,IAAI,CAAC7M,KAAK,CAACyC,SAAS,KAAK1G,kBAAkB,CAAC+Q,aAAa;IAEjF,IAAI,CAAClC,OAAO,IAAI,CAAC,IAAI,CAACzK,KAAK,CAACiB,OAAO,EAAE;MACnC,OAAO,KAAK;;IAGd,IAAI,IAAI,CAACyD,eAAe,CAAC+F,OAAO,CAAC,EAAE;MACjC,IAAI,CAAC,IAAI,CAACvF,qBAAqB,CAACuF,OAA2B,EAAEhF,SAAS,CAAC,EAAE;QACvE,OAAO,KAAK;;;IAIhB,IAAMC,UAAU,GAAGgH,eAAe,GAAGjC,OAAO,CAACmC,qBAAqB,EAAE,GAAG,IAAI;IAE3E,GAAG;MACDnC,OAAO,GACLhF,SAAS,GAAGnJ,cAAc,CAAC,IAAI,CAAC0D,KAAK,CAACiB,OAAO,EAAEwJ,OAAO,CAAC,GAAGjO,kBAAkB,CAAC,IAAI,CAACwD,KAAK,CAACiB,OAAO,EAAEwJ,OAAO,CAC1F;MAEhB,IAAIiC,eAAe,EAAE;QACnB,IAAIjC,OAAO,EAAE;UACX,IAAM9E,UAAU,GAAG8E,OAAO,CAACmC,qBAAqB,EAAE;UAClD;UACA,IAAMC,eAAe,GAAGR,qBAAqB,CAAC3G,UAAwB,EAAEC,UAAU,CAAC;UAEnF,IAAIkH,eAAe,KAAK,CAAC,CAAC,IAAIN,iBAAiB,KAAK,CAAC,CAAC,EAAE;YACtDC,gBAAgB,GAAG/B,OAAO;YAC1B;;UAGF,IAAIoC,eAAe,GAAG,CAAC,CAAC,KAAKN,iBAAiB,KAAK,CAAC,CAAC,IAAIM,eAAe,GAAGN,iBAAiB,CAAC,EAAE;YAC7FA,iBAAiB,GAAGM,eAAe;YACnCL,gBAAgB,GAAG/B,OAAO;;UAG5B,IAAI8B,iBAAiB,IAAI,CAAC,IAAIM,eAAe,GAAG,CAAC,EAAE;YACjD;;;OAGL,MAAM;QACLL,gBAAgB,GAAG/B,OAAO;QAC1B;;KAEH,QAAQA,OAAO;IAEhB;IACA,IAAI+B,gBAAgB,IAAIA,gBAAgB,KAAK,IAAI,CAAClL,cAAc,EAAE;MAChEmL,YAAY,GAAG,IAAI;MACnB,IAAI,CAACxJ,YAAY,CAACuJ,gBAAgB,CAAC;KACpC,MAAM,IAAI,IAAI,CAAC3M,KAAK,CAACiN,oBAAoB,IAAIR,cAAc,EAAE;MAC5D,IAAI7G,SAAS,EAAE;QACb,OAAO,IAAI,CAACxC,YAAY,CACtB3G,cAAc,CAAC,IAAI,CAAC0D,KAAK,CAACiB,OAAO,EAAE,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACgL,iBAAgC,EAAE,IAAI,CAAgB,CAC7G;OACF,MAAM;QACL,OAAO,IAAI,CAAChJ,YAAY,CACtBzG,kBAAkB,CAChB,IAAI,CAACwD,KAAK,CAACiB,OAAO,EAClB,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAAC8L,gBAA+B,EAClD,IAAI,EACJ,IAAI,EACJ,IAAI,CACU,CACjB;;;IAIL,OAAON,YAAY;EACrB,CAAC;EAEO/M,SAAA,CAAAsI,SAAA,CAAA/D,cAAc,GAAtB;IAAA,IAAAnE,KAAA;IACE,IAAIkN,SAAS,GAAG,CAAC,CAAC;IAClB;IACA,IAAMpH,aAAa,GAAG,IAAI,CAACC,eAAe,CAACtC,IAAI,IAAI,IAAI,CAACsC,eAAe,CAACC,CAAC,IAAI,CAAC;IAE9E;IACE;IACA,IAAI,CAACsG,UAAU,CAAC,IAAI,EAAE,UAAC1G,UAAsB,EAAEC,UAAsB;MACnE,IAAIsH,QAAQ,GAAG,CAAC,CAAC;MACjB;MACA;MACA;MACA;MACA,IAAMlH,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACN,UAAU,CAACO,GAAG,CAAC;MAChD,IAAMC,gBAAgB,GAAGH,IAAI,CAACC,KAAK,CAACP,UAAU,CAACU,MAAM,CAAC;MAEtD,IAAIL,aAAa,GAAGI,gBAAgB,EAAE;QACpC,IAAI,CAACrG,KAAI,CAAC+E,gBAAgB,CAAC/E,KAAI,CAACwB,cAA6B,EAAE1D,gBAAgB,CAAC,EAAE;UAChF,OAAOG,mCAAmC;;QAG5C,OAAOD,0BAA0B;;MAGnC,IAAKkP,SAAS,KAAK,CAAC,CAAC,IAAIjH,aAAa,IAAII,gBAAgB,IAAKJ,aAAa,KAAKiH,SAAS,EAAE;QAC1FA,SAAS,GAAGjH,aAAa;QACzB,IAAIH,aAAa,IAAID,UAAU,CAACpC,IAAI,IAAIqC,aAAa,IAAID,UAAU,CAACpC,IAAI,GAAGoC,UAAU,CAACc,KAAK,EAAE;UAC3FwG,QAAQ,GAAG,CAAC;SACb,MAAM;UACLA,QAAQ,GAAGjH,IAAI,CAACU,GAAG,CAACf,UAAU,CAACpC,IAAI,GAAGoC,UAAU,CAACc,KAAK,GAAG,CAAC,GAAGb,aAAa,CAAC;;;MAI/E,OAAOqH,QAAQ;IACjB,CAAC,CAAC,EACF;MACA,IAAI,CAACzL,kBAAkB,CAAC,IAAI,CAACF,cAA6B,EAAE,KAAK,EAAE,IAAI,CAAC;MACxE,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd,CAAC;EAEO5B,SAAA,CAAAsI,SAAA,CAAAjE,YAAY,GAApB;IAAA,IAAAjE,KAAA;IACE,IAAIkN,SAAS,GAAG,CAAC,CAAC;IAClB;IACA,IAAMpH,aAAa,GAAG,IAAI,CAACC,eAAe,CAACtC,IAAI,IAAI,IAAI,CAACsC,eAAe,CAACC,CAAC,IAAI,CAAC;IAE9E;IACE;IACA,IAAI,CAACsG,UAAU,CAAC,KAAK,EAAE,UAAC1G,UAAsB,EAAEC,UAAsB;MACpE,IAAIsH,QAAQ,GAAG,CAAC,CAAC;MACjB;MACA;MACA;MACA;MACA,IAAM5G,gBAAgB,GAAGL,IAAI,CAACC,KAAK,CAACN,UAAU,CAACS,MAAM,CAAC;MACtD,IAAML,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACN,UAAU,CAACO,GAAG,CAAC;MAChD,IAAMI,aAAa,GAAGN,IAAI,CAACC,KAAK,CAACP,UAAU,CAACQ,GAAG,CAAC;MAEhD,IAAIG,gBAAgB,GAAGC,aAAa,EAAE;QACpC,IAAI,CAACxG,KAAI,CAAC+E,gBAAgB,CAAC/E,KAAI,CAACwB,cAA6B,EAAE1D,gBAAgB,CAAC,EAAE;UAChF,OAAOG,mCAAmC;;QAE5C,OAAOD,0BAA0B;;MAGnC,IAAKkP,SAAS,KAAK,CAAC,CAAC,IAAI3G,gBAAgB,IAAIC,aAAa,IAAKP,aAAa,KAAKiH,SAAS,EAAE;QAC1FA,SAAS,GAAGjH,aAAa;QACzB,IAAIH,aAAa,IAAID,UAAU,CAACpC,IAAI,IAAIqC,aAAa,IAAID,UAAU,CAACpC,IAAI,GAAGoC,UAAU,CAACc,KAAK,EAAE;UAC3FwG,QAAQ,GAAG,CAAC;SACb,MAAM;UACLA,QAAQ,GAAGjH,IAAI,CAACU,GAAG,CAACf,UAAU,CAACpC,IAAI,GAAGoC,UAAU,CAACc,KAAK,GAAG,CAAC,GAAGb,aAAa,CAAC;;;MAI/E,OAAOqH,QAAQ;IACjB,CAAC,CAAC,EACF;MACA,IAAI,CAACzL,kBAAkB,CAAC,IAAI,CAACF,cAA6B,EAAE,KAAK,EAAE,IAAI,CAAC;MACxE,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd,CAAC;EAEO5B,SAAA,CAAAsI,SAAA,CAAAtE,cAAc,GAAtB,UAAuBrB,KAAa;IAApC,IAAAvC,KAAA;IACE,IAAMoN,UAAU,GAAG,IAAI,CAACrI,gBAAgB,CAAC,IAAI,CAACvD,cAA6B,EAAEzD,kBAAkB,CAAC;IAChG,IACE,IAAI,CAACuO,UAAU,CACb3P,MAAM,CAAC4F,KAAK,CAAC;IACb;IACA,UAACqD,UAAsB,EAAEC,UAAsB;MAC7C,IAAIsH,QAAQ,GAAG,CAAC,CAAC;MACjB,IAAIE,mBAAmB;MAEvB,IAAI1Q,MAAM,CAAC4F,KAAK,CAAC,EAAE;QACjB;QACA;QACA;QACA;QACA8K,mBAAmB,GAAGC,UAAU,CAACzH,UAAU,CAACO,GAAG,CAACmH,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGD,UAAU,CAAC1H,UAAU,CAACU,MAAM,CAACiH,OAAO,CAAC,CAAC,CAAC,CAAC;OACvG,MAAM;QACLF,mBAAmB,GAAGC,UAAU,CAACzH,UAAU,CAACS,MAAM,CAACiH,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGD,UAAU,CAAC1H,UAAU,CAACQ,GAAG,CAACmH,OAAO,CAAC,CAAC,CAAC,CAAC;;MAGxG,IACEF,mBAAmB,IACnBxH,UAAU,CAAChC,KAAK,IAAI+B,UAAU,CAAC/B,KAAK,IACpC7D,KAAI,CAACD,KAAK,CAACyC,SAAS,KAAK1G,kBAAkB,CAAC4H,QAAQ,EACpD;QACAyJ,QAAQ,GAAGvH,UAAU,CAAC/B,KAAK,GAAGgC,UAAU,CAAChC,KAAK;OAC/C,MAAM,IAAI,CAACuJ,UAAU,EAAE;QACtBD,QAAQ,GAAGlP,mCAAmC;;MAGhD,OAAOkP,QAAQ;IACjB,CAAC,EACD/L,SAAS,CAAC,QACVgM,UAAU,CACX,EACD;MACA,IAAI,CAAC1L,kBAAkB,CAAC,IAAI,CAACF,cAA6B,EAAE,IAAI,EAAE,KAAK,CAAC;MACxE,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd,CAAC;EAEO5B,SAAA,CAAAsI,SAAA,CAAApE,eAAe,GAAvB,UAAwBvB,KAAa;IAArC,IAAAvC,KAAA;IACE,IAAMoN,UAAU,GAAG,IAAI,CAACrI,gBAAgB,CAAC,IAAI,CAACvD,cAA6B,EAAEzD,kBAAkB,CAAC;IAChG,IACE,IAAI,CAACuO,UAAU,CACb,CAAC3P,MAAM,CAAC4F,KAAK,CAAC;IACd;IACA,UAACqD,UAAsB,EAAEC,UAAsB;MAC7C,IAAIsH,QAAQ,GAAG,CAAC,CAAC;MACjB,IAAIE,mBAAmB;MAEvB,IAAI1Q,MAAM,CAAC4F,KAAK,CAAC,EAAE;QACjB;QACA;QACA;QACA;QACA8K,mBAAmB,GAAGC,UAAU,CAACzH,UAAU,CAACS,MAAM,CAACiH,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGD,UAAU,CAAC1H,UAAU,CAACQ,GAAG,CAACmH,OAAO,CAAC,CAAC,CAAC,CAAC;OACvG,MAAM;QACLF,mBAAmB,GAAGC,UAAU,CAACzH,UAAU,CAACO,GAAG,CAACmH,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGD,UAAU,CAAC1H,UAAU,CAACU,MAAM,CAACiH,OAAO,CAAC,CAAC,CAAC,CAAC;;MAGxG,IACEF,mBAAmB,IACnBxH,UAAU,CAACpC,IAAI,IAAImC,UAAU,CAACnC,IAAI,IAClCzD,KAAI,CAACD,KAAK,CAACyC,SAAS,KAAK1G,kBAAkB,CAAC4H,QAAQ,EACpD;QACAyJ,QAAQ,GAAGtH,UAAU,CAACpC,IAAI,GAAGmC,UAAU,CAACnC,IAAI;OAC7C,MAAM,IAAI,CAAC2J,UAAU,EAAE;QACtBD,QAAQ,GAAGlP,mCAAmC;;MAGhD,OAAOkP,QAAQ;IACjB,CAAC,EACD/L,SAAS,CAAC,QACVgM,UAAU,CACX,EACD;MACA,IAAI,CAAC1L,kBAAkB,CAAC,IAAI,CAACF,cAA6B,EAAE,IAAI,EAAE,KAAK,CAAC;MACxE,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd,CAAC;EAmCO5B,SAAA,CAAAsI,SAAA,CAAA7D,gBAAgB,GAAxB,UAAyBsB,SAAkB,EAAE6G,cAA8B;IAA9B,IAAAA,cAAA;MAAAA,cAAA,OAA8B;IAAA;IACzE,IAAI7B,OAAO,GAAG,IAAI,CAACnJ,cAAc;IACjC,IAAI,CAACmJ,OAAO,IAAI,CAAC,IAAI,CAACzK,KAAK,CAACiB,OAAO,EAAE;MACnC,OAAO,KAAK;;IAEd,IAAI,IAAI,CAACyD,eAAe,CAAC+F,OAAO,CAAC,EAAE;MACjC,IAAI,CAAC,IAAI,CAACvF,qBAAqB,CAACuF,OAA2B,EAAEhF,SAAS,CAAC,EAAE;QACvE,OAAO,KAAK;;;IAGhB,IAAM6H,gBAAgB,GAAGpQ,oBAAoB,CAACuN,OAAO,CAAC;IACtD,IAAI,CAAC6C,gBAAgB,EAAE;MACrB,OAAO,KAAK;;IAEd,IAAIf,iBAAiB,GAAG,CAAC,CAAC;IAC1B,IAAIC,gBAAgB,GAAGtL,SAAS;IAChC,IAAI8L,SAAS,GAAG,CAAC,CAAC;IAClB,IAAIO,YAAY,GAAG,CAAC,CAAC;IACrB,IAAMC,QAAQ,GAAIF,gBAAgC,CAACG,YAAY;IAC/D,IAAM/H,UAAU,GAAG+E,OAAO,CAACmC,qBAAqB,EAAE;IAClD,GAAG;MACDnC,OAAO,GAAGhF,SAAS,GACfnJ,cAAc,CAAC,IAAI,CAAC0D,KAAK,CAACiB,OAAO,EAAEwJ,OAAO,CAAC,GAC3CjO,kBAAkB,CAAC,IAAI,CAACwD,KAAK,CAACiB,OAAO,EAAEwJ,OAAO,CAAC;MACnD,IAAIA,OAAO,EAAE;QACX,IAAM9E,UAAU,GAAG8E,OAAO,CAACmC,qBAAqB,EAAE;QAClD,IAAM7G,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACN,UAAU,CAACO,GAAG,CAAC;QAChD,IAAMC,gBAAgB,GAAGH,IAAI,CAACC,KAAK,CAACP,UAAU,CAACU,MAAM,CAAC;QACtD,IAAMC,gBAAgB,GAAGL,IAAI,CAACC,KAAK,CAACN,UAAU,CAACS,MAAM,CAAC;QACtD,IAAME,aAAa,GAAGN,IAAI,CAACC,KAAK,CAACP,UAAU,CAACQ,GAAG,CAAC;QAChD,IAAM2G,eAAe,GAAG,IAAI,CAACrH,gCAAgC,CAACC,SAAS,EAAEC,UAAU,EAAEC,UAAU,CAAC;QAChG,IAAM+H,mCAAmC,GAAGjI,SAAS,IAAIM,aAAa,GAAGI,gBAAgB,GAAGqH,QAAQ;QACpG,IAAMG,iCAAiC,GAAG,CAAClI,SAAS,IAAIY,gBAAgB,GAAGC,aAAa,GAAGkH,QAAQ;QAEnG,IAAIE,mCAAmC,IAAIC,iCAAiC,EAAE;UAC5E;;QAEF,IAAId,eAAe,GAAG,CAAC,CAAC,EAAE;UACxB;UACA,IAAIpH,SAAS,IAAIM,aAAa,GAAGiH,SAAS,EAAE;YAC1CA,SAAS,GAAGjH,aAAa;YACzBwG,iBAAiB,GAAGM,eAAe;YACnCL,gBAAgB,GAAG/B,OAAO;WAC3B,MAAM,IAAI,CAAChF,SAAS,IAAIY,gBAAgB,GAAGkH,YAAY,EAAE;YACxD;YACAA,YAAY,GAAGlH,gBAAgB;YAC/BkG,iBAAiB,GAAGM,eAAe;YACnCL,gBAAgB,GAAG/B,OAAO;WAC3B,MAAM,IAAI8B,iBAAiB,KAAK,CAAC,CAAC,IAAIM,eAAe,IAAIN,iBAAiB,EAAE;YAC3EA,iBAAiB,GAAGM,eAAe;YACnCL,gBAAgB,GAAG/B,OAAO;;;;KAIjC,QAAQA,OAAO;IAEhB,IAAIgC,YAAY,GAAG,KAAK;IACxB;IACA,IAAID,gBAAgB,IAAIA,gBAAgB,KAAK,IAAI,CAAClL,cAAc,EAAE;MAChEmL,YAAY,GAAG,IAAI;MACnB,IAAI,CAACxJ,YAAY,CAACuJ,gBAAgB,CAAC;MACnC,IAAI,CAAChL,kBAAkB,CAACgL,gBAA+B,EAAE,KAAK,EAAE,IAAI,CAAC;KACtE,MAAM,IAAI,IAAI,CAAC3M,KAAK,CAACiN,oBAAoB,IAAIR,cAAc,EAAE;MAC5D,IAAI7G,SAAS,EAAE;QACb,OAAO,IAAI,CAACxC,YAAY,CACtB3G,cAAc,CAAC,IAAI,CAAC0D,KAAK,CAACiB,OAAO,EAAE,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAACgL,iBAAgC,EAAE,IAAI,CAAgB,CAC7G;;MAEH,OAAO,IAAI,CAAChJ,YAAY,CACtBzG,kBAAkB,CAChB,IAAI,CAACwD,KAAK,CAACiB,OAAO,EAClB,IAAI,CAACjB,KAAK,CAACiB,OAAO,CAAC8L,gBAA+B,EAClD,IAAI,EACJ,IAAI,EACJ,IAAI,CACU,CACjB;;IAEH,OAAON,YAAY;EACrB,CAAC;EAEO/M,SAAA,CAAAsI,SAAA,CAAAxG,kBAAkB,GAA1B,UAA2BiJ,OAAoB,EAAEmD,YAAsB,EAAEC,UAAoB;IAC3F,IACE,IAAI,CAAChO,KAAK,CAACyC,SAAS,KAAK1G,kBAAkB,CAAC+Q,aAAa,KACxD,CAAC,IAAI,CAAC9G,eAAe,IAAI+H,YAAY,IAAIC,UAAU,CAAC,EACrD;MACA,IAAMC,IAAI,GAAGrD,OAAO,CAACmC,qBAAqB,EAAE;MAC5C,IAAMrJ,IAAI,GAAGuK,IAAI,CAACvK,IAAI,GAAGuK,IAAI,CAACrH,KAAK,GAAG,CAAC;MACvC,IAAMsH,KAAG,GAAGD,IAAI,CAAC5H,GAAG,GAAG4H,IAAI,CAACE,MAAM,GAAG,CAAC;MAEtC,IAAI,CAAC,IAAI,CAACnI,eAAe,EAAE;QACzB,IAAI,CAACA,eAAe,GAAG;UAAEtC,IAAI,EAAAA,IAAA;UAAE2C,GAAG,EAAA6H;QAAA,CAAE;;MAGtC,IAAIH,YAAY,EAAE;QAChB,IAAI,CAAC/H,eAAe,CAACtC,IAAI,GAAGA,IAAI;;MAGlC,IAAIsK,UAAU,EAAE;QACd,IAAI,CAAChI,eAAe,CAACK,GAAG,GAAG6H,KAAG;;;EAGpC,CAAC;EAEOrO,SAAA,CAAAsI,SAAA,CAAAlH,4BAA4B,GAApC,UAAqC2J,OAAqB;IACxD,OAAO,IAAI,CAACH,aAAa,CAACG,OAAO,CAAC,KAAK,IAAI,CAACzK,KAAK,CAACiB,OAAO;EAC3D,CAAC;EAEOvB,SAAA,CAAAsI,SAAA,CAAAsC,aAAa,GAArB,UAAsBG,OAAqB;IACzC,IAAIzJ,aAAa,GAAGzE,SAAS,CAACkO,OAAsB,EAAEhL,sBAAsB,CAAC;IAE7E,OAAOuB,aAAa,IAAIA,aAAa,KAAK,IAAI,CAAChB,KAAK,CAACiB,OAAO,IAAID,aAAa,KAAK,IAAI,CAAC4B,YAAY,EAAE,CAACyF,IAAI,EAAE;MAC1G,IAAIxL,kBAAkB,CAACmE,aAAa,CAAC,EAAE;QACrC,OAAOA,aAAa;;MAGtBA,aAAa,GAAGzE,SAAS,CAACyE,aAAa,EAAEvB,sBAAsB,CAAC;;IAGlE,OAAOuB,aAAa;EACtB,CAAC;EAEOtB,SAAA,CAAAsI,SAAA,CAAAvG,iBAAiB,GAAzB,UAA0BgJ,OAAqB;IAC7C,IACE,CAAC,IAAI,CAACnJ,cAAc,IACpB,IAAI,CAACzB,KAAK,CAACe,sBAAsB,IACjC,OAAO,IAAI,CAACf,KAAK,CAACe,sBAAsB,KAAK,UAAU,EACvD;MACA,IAAI,CAACU,cAAc,GAAG,IAAI,CAACzB,KAAK,CAACe,sBAAsB,CAAC,IAAI,CAACZ,KAAK,CAACiB,OAAsB,CAAC;;IAG5F,IAAI,CAACwJ,OAAO,IAAI,IAAI,CAACzK,KAAK,CAACiB,OAAO,EAAE;MAClC,IAAI,CAAC6H,oBAAoB,GAAG,IAAI;MAChC2B,OAAO,GAAG,IAAI,CAACzK,KAAK,CAACiB,OAAO;MAC5B,IAAI,IAAI,CAACK,cAAc,IAAI,CAACtF,eAAe,CAACyO,OAAO,EAAE,IAAI,CAACnJ,cAAc,CAAC,EAAE;QACzE,IAAI,CAACA,cAAc,GAAG,IAAI;;;IAI9B;IACA;IACA,IAAI,IAAI,CAACA,cAAc,IAAI,CAACxE,iBAAiB,CAAC,IAAI,CAACwE,cAAc,EAAEJ,SAAS,EAAE,IAAI,CAACC,aAAa,CAAC,EAAE;MACjG,IAAI,CAACG,cAAc,GAAG,IAAI;;IAG5B,IAAM2M,UAAU,GAAGxD,OAAO,IAAIA,OAAO,CAACR,QAAQ;IAE9C,KAAK,IAAIiE,UAAU,GAAG,CAAC,EAAED,UAAU,IAAIC,UAAU,GAAGD,UAAU,CAAChM,MAAM,EAAEiM,UAAU,EAAE,EAAE;MACnF,IAAMlC,KAAK,GAAGiC,UAAU,CAACC,UAAU,CAAgB;MAEnD,IAAI,CAACrR,kBAAkB,CAACmP,KAAK,CAAC,EAAE;QAC9B;QACA,IAAIA,KAAK,CAAC5B,YAAY,IAAI4B,KAAK,CAAC5B,YAAY,CAAC5M,sBAAsB,CAAC,KAAK,OAAO,EAAE;UAChFwO,KAAK,CAACR,YAAY,CAAC7N,QAAQ,EAAE,IAAI,CAAC;;QAGpC,IAAIb,iBAAiB,CAACkP,KAAK,EAAE9K,SAAS,EAAE,IAAI,CAACC,aAAa,CAAC,EAAE;UAC3D,IAAI,IAAI,CAACtB,KAAK,CAACiC,QAAQ,EAAE;YACvBkK,KAAK,CAACR,YAAY,CAAC7N,QAAQ,EAAE,IAAI,CAAC;WACnC,MAAM,IACL,CAAC,IAAI,CAACmF,YAAY,KAChB,CAAC,IAAI,CAACxB,cAAc,IAAI,CAAC,IAAI,CAACwH,oBAAoB,IAAK,IAAI,CAACxH,cAAc,KAAK0K,KAAK,CAAC,EACvF;YACA,IAAI,CAAClD,oBAAoB,GAAGkD,KAAK;YACjC,IAAIA,KAAK,CAAC5B,YAAY,CAACzM,QAAQ,CAAC,KAAK,GAAG,EAAE;cACxCqO,KAAK,CAACR,YAAY,CAAC7N,QAAQ,EAAE,GAAG,CAAC;;WAEpC,MAAM,IAAIqO,KAAK,CAAC5B,YAAY,CAACzM,QAAQ,CAAC,KAAK,IAAI,EAAE;YAChDqO,KAAK,CAACR,YAAY,CAAC7N,QAAQ,EAAE,IAAI,CAAC;;SAErC,MAAM,IAAIqO,KAAK,CAACF,OAAO,KAAK,KAAK,IAAIE,KAAK,CAAC5B,YAAY,CAAC,WAAW,CAAC,KAAK,OAAO,EAAE;UACjF;UACA4B,KAAK,CAACR,YAAY,CAAC,WAAW,EAAE,OAAO,CAAC;;OAE3C,MAAM,IAAIQ,KAAK,CAAC5B,YAAY,CAAC5M,sBAAsB,CAAC,KAAK,MAAM,EAAE;QAChE,IACE,CAAC,IAAI,CAACsF,YAAY,KAChB,CAAC,IAAI,CAACxB,cAAc,IAAI,CAAC,IAAI,CAACwH,oBAAoB,IAAK,IAAI,CAACxH,cAAc,KAAK0K,KAAK,CAAC,EACvF;UACA,IAAI,CAAClD,oBAAoB,GAAGkD,KAAK;UACjC,IAAIA,KAAK,CAAC5B,YAAY,CAACzM,QAAQ,CAAC,KAAK,GAAG,EAAE;YACxCqO,KAAK,CAACR,YAAY,CAAC7N,QAAQ,EAAE,GAAG,CAAC;;SAEpC,MAAM,IAAIqO,KAAK,CAAC5B,YAAY,CAACzM,QAAQ,CAAC,KAAK,IAAI,EAAE;UAChDqO,KAAK,CAACR,YAAY,CAAC7N,QAAQ,EAAE,IAAI,CAAC;;;MAItC,IAAI,CAAC8D,iBAAiB,CAACuK,KAAK,CAAC;;EAEjC,CAAC;EAEOtM,SAAA,CAAAsI,SAAA,CAAA/C,yBAAyB,GAAjC,UAAkCwF,OAAoB;IACpD,OAAOA,OAAO,IAAIA,OAAO,CAACL,YAAY,CAAC,iBAAiB,CAAC,KAAK,MAAM;EACtE,CAAC;EAEO1K,SAAA,CAAAsI,SAAA,CAAAtD,eAAe,GAAvB,UAAwB+F,OAAoB;IAC1C,IACEA,OAAO,IACPA,OAAO,CAACqB,OAAO,KACdrB,OAAO,CAACqB,OAAO,CAACqC,WAAW,EAAE,KAAK,OAAO,IAAI1D,OAAO,CAACqB,OAAO,CAACqC,WAAW,EAAE,KAAK,UAAU,CAAC,EAC3F;MACA,OAAO,IAAI;;IAEb,OAAO,KAAK;EACd,CAAC;EAEOzO,SAAA,CAAAsI,SAAA,CAAA9C,qBAAqB,GAA7B,UAA8BuF,OAA+C,EAAEhF,SAAmB;IAChG;IACA,IACE,CAAC,IAAI,CAACb,iBAAiB,IACvB6F,OAAO,IACPA,OAAO,CAAC2D,IAAI,IACZ5O,mBAAmB,CAAC6O,OAAO,CAAC5D,OAAO,CAAC2D,IAAI,CAACD,WAAW,EAAE,CAAC,GAAG,CAAC,CAAC,EAC5D;MACA,IAAMG,cAAc,GAAG7D,OAAO,CAAC6D,cAAc;MAC7C,IAAMC,YAAY,GAAG9D,OAAO,CAAC8D,YAAY;MACzC,IAAMC,eAAe,GAAGF,cAAc,KAAKC,YAAY;MACvD,IAAME,UAAU,GAAGhE,OAAO,CAACiE,KAAK;MAChC,IAAMC,UAAU,GAAGlE,OAAO,CAACmE,QAAQ;MAEnC;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IACEJ,eAAe,IACdF,cAAe,GAAG,CAAC,IAAI,CAAC7I,SAAS,IAAI,CAACkJ,UAAW,IACjDL,cAAc,KAAKG,UAAU,CAACxM,MAAM,IAAIwD,SAAS,IAAI,CAACkJ,UAAW,IACjE,CAAC,CAAC,IAAI,CAAC9O,KAAK,CAAC0E,YAAY,IACxB,EAAE,IAAI,CAAC1E,KAAK,CAACgP,8BAA8B,IAAI,IAAI,CAAChP,KAAK,CAACgP,8BAA8B,CAACpE,OAAO,CAAC,CAAE,EACrG;QACA,OAAO,KAAK;;;IAIhB,OAAO,IAAI;EACb,CAAC;EAEO/K,SAAA,CAAAsI,SAAA,CAAAnD,gBAAgB,GAAxB,UACE4F,OAAoB,EACpBqE,mBAAwE;IAExE,OAAO,IAAI,CAACjP,KAAK,CAACkP,cAAc,GAAGhS,eAAe,CAAC0N,OAAO,EAAEqE,mBAAmB,CAAC,GAAG,IAAI;EACzF,CAAC;EAED;;;EAGQpP,SAAA,CAAAsI,SAAA,CAAA5H,sBAAsB,GAA9B,UAA+BqK,OAAoB;IACjD,OAAOA,OAAO,IAAI,CAAC,CAAC,IAAI,CAACzK,KAAK,CAACiB,OAAO,IAAIhE,qBAAqB,CAACwN,OAAO,EAAE,IAAI,CAACzK,KAAK,CAACiB,OAAO,CAAC;EAC9F,CAAC;EAEOvB,SAAA,CAAAsI,SAAA,CAAApF,YAAY,GAApB;IACE,OAAO3G,WAAW,CAAC,IAAI,CAAC+D,KAAK,CAACiB,OAAO,CAAE;EACzC,CAAC;EAr0CavB,SAAA,CAAAsP,WAAW,GAAG3R,4BAA4B;EAE1CqC,SAAA,CAAA4H,YAAY,GAAoB;IAC5CwF,oBAAoB,EAAE,KAAK;IAC3BxK,SAAS,EAAE1G,kBAAkB,CAAC+Q,aAAa;IAC3CtF,iBAAiB,EAAE,IAAI;IACvB;IACA,cAAc,EAAE;GACa;EA8zCjC,OAAA3H,SAAC;CAAA,CAv0C8B/D,KAAK,CAACsT,SAAS;SAAjCvP,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}