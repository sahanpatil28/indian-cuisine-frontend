{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, canUseDOM, css, divProperties, findIndex, findScrollableParent, getNativeProps, getParent, getWindow, initializeComponentRef } from '../../Utilities';\nimport { ScrollToMode } from './List.types';\nimport { composeRenderFunction } from '../../Utilities';\nimport { getScrollHeight, getScrollYPosition, setScrollYPosition } from './utils/scroll';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getWindowEx } from '../../utilities/dom';\n// import { ListDebugRenderer } from './utils/ListDebugRenderer';\nvar RESIZE_DELAY = 16;\nvar MIN_SCROLL_UPDATE_DELAY = 100;\nvar MAX_SCROLL_UPDATE_DELAY = 500;\nvar IDLE_DEBOUNCE_DELAY = 200;\n// The amount of time to wait before declaring that the list isn't scrolling\nvar DONE_SCROLLING_WAIT = 500;\nvar DEFAULT_ITEMS_PER_PAGE = 10;\nvar DEFAULT_PAGE_HEIGHT = 30;\nvar DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nvar DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nvar PAGE_KEY_PREFIX = 'page-';\nvar SPACER_KEY_PREFIX = 'spacer-';\n// Fraction of a page to have been scrolled before re-running expensive calculations\nvar SCROLL_RATIO = 1 / 3;\nvar EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0\n};\n// Naming expensive measures so that they're named in profiles.\nvar _measurePageRect = function (element) {\n  return element.getBoundingClientRect();\n};\nvar _measureSurfaceRect = _measurePageRect;\nvar _measureScrollRect = _measurePageRect;\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback\n * if provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if\n * provided by the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time.\n * And we start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\nvar List = /** @class */function (_super) {\n  __extends(List, _super);\n  function List(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._surface = React.createRef();\n    _this._pageRefs = {};\n    _this._getDerivedStateFromProps = function (nextProps, previousState) {\n      if (nextProps.items !== _this.props.items || nextProps.renderCount !== _this.props.renderCount || nextProps.startIndex !== _this.props.startIndex || nextProps.version !== _this.props.version || !previousState.hasMounted && _this.props.renderEarly && canUseDOM()) {\n        // We have received new items so we want to make sure that initially we only render a single window to\n        // fill the currently visible rect, and then later render additional windows.\n        _this._resetRequiredWindows();\n        _this._requiredRect = null;\n        _this._measureVersion++;\n        _this._invalidatePageCache();\n        return _this._updatePages(nextProps, previousState);\n      }\n      return previousState;\n    };\n    _this._onRenderRoot = function (props) {\n      var rootRef = props.rootRef,\n        surfaceElement = props.surfaceElement,\n        divProps = props.divProps;\n      return React.createElement(\"div\", __assign({\n        ref: rootRef\n      }, divProps), surfaceElement);\n    };\n    _this._onRenderSurface = function (props) {\n      var surfaceRef = props.surfaceRef,\n        pageElements = props.pageElements,\n        divProps = props.divProps;\n      return React.createElement(\"div\", __assign({\n        ref: surfaceRef\n      }, divProps), pageElements);\n    };\n    _this._onRenderPage = function (pageProps, defaultRender) {\n      var _a;\n      var _b = _this.props,\n        onRenderCell = _b.onRenderCell,\n        onRenderCellConditional = _b.onRenderCellConditional,\n        role = _b.role;\n      var _c = pageProps.page,\n        _d = _c.items,\n        items = _d === void 0 ? [] : _d,\n        startIndex = _c.startIndex,\n        divProps = __rest(pageProps, [\"page\"]);\n      // only assign list item role if no role is assigned\n      var cellRole = role === undefined ? 'listitem' : 'presentation';\n      var cells = [];\n      for (var i = 0; i < items.length; i++) {\n        var index = startIndex + i;\n        var item = items[i];\n        var itemKey = _this.props.getKey ? _this.props.getKey(item, index) : item && item.key;\n        if (itemKey === null || itemKey === undefined) {\n          itemKey = index;\n        }\n        var renderCell = onRenderCellConditional !== null && onRenderCellConditional !== void 0 ? onRenderCellConditional : onRenderCell;\n        var cell = (_a = renderCell === null || renderCell === void 0 ? void 0 : renderCell(item, index, !_this.props.ignoreScrollingState ? _this.state.isScrolling : undefined)) !== null && _a !== void 0 ? _a : null;\n        if (!onRenderCellConditional || cell) {\n          cells.push(React.createElement(\"div\", {\n            role: cellRole,\n            className: 'ms-List-cell',\n            key: itemKey,\n            \"data-list-index\": index,\n            \"data-automationid\": \"ListCell\"\n          }, cell));\n        }\n      }\n      return React.createElement(\"div\", __assign({}, divProps), cells);\n    };\n    initializeComponentRef(_this);\n    _this.state = {\n      pages: [],\n      isScrolling: false,\n      getDerivedStateFromProps: _this._getDerivedStateFromProps,\n      hasMounted: false\n    };\n    _this._estimatedPageHeight = 0;\n    _this._totalEstimates = 0;\n    _this._requiredWindowsAhead = 0;\n    _this._requiredWindowsBehind = 0;\n    // Track the measure version for everything.\n    _this._measureVersion = 0;\n    _this._cachedPageHeights = {};\n    _this._estimatedPageHeight = 0;\n    _this._focusedIndex = -1;\n    _this._pageCache = {};\n    return _this;\n  }\n  // private _debugRenderer: ListDebugRenderer;\n  // private _debugRafId: number | undefined = undefined;\n  List.getDerivedStateFromProps = function (nextProps, previousState) {\n    return previousState.getDerivedStateFromProps(nextProps, previousState);\n  };\n  Object.defineProperty(List.prototype, \"pageRefs\", {\n    get: function () {\n      return this._pageRefs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\n   *\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\n   *\n   * @param index - Index of item to scroll to\n   * @param measureItem - Optional callback to measure the height of an individual item\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\n   */\n  List.prototype.scrollToIndex = function (index, measureItem, scrollToMode) {\n    if (scrollToMode === void 0) {\n      scrollToMode = ScrollToMode.auto;\n    }\n    var startIndex = this.props.startIndex;\n    var renderCount = this._getRenderCount();\n    var endIndex = startIndex + renderCount;\n    var allowedRect = this._allowedRect;\n    var scrollTop = 0;\n    var itemsPerPage = 1;\n    for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      var pageSpecification = this._getPageSpecification(this.props, itemIndex, allowedRect);\n      var pageHeight = pageSpecification.height;\n      itemsPerPage = pageSpecification.itemCount;\n      var requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\n      if (requestedIndexIsInPage) {\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in\n        // just the given item, otherwise we'll only bring the page into view\n        if (measureItem && this._scrollElement) {\n          var scrollRect = _measureScrollRect(this._scrollElement);\n          var scrollPosition = getScrollYPosition(this._scrollElement);\n          var scrollWindow = {\n            top: scrollPosition,\n            bottom: scrollPosition + scrollRect.height\n          };\n          // Adjust for actual item position within page\n          var itemPositionWithinPage = index - itemIndex;\n          for (var itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\n          }\n          var scrollBottom = scrollTop + measureItem(index);\n          // If scrollToMode is set to something other than auto, we always want to\n          // scroll the item into a specific position on the page.\n          switch (scrollToMode) {\n            case ScrollToMode.top:\n              setScrollYPosition(this._scrollElement, scrollTop);\n              return;\n            case ScrollToMode.bottom:\n              setScrollYPosition(this._scrollElement, scrollBottom - scrollRect.height);\n              return;\n            case ScrollToMode.center:\n              setScrollYPosition(this._scrollElement, (scrollTop + scrollBottom - scrollRect.height) / 2);\n              return;\n            case ScrollToMode.auto:\n            default:\n              break;\n          }\n          var itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\n          if (itemIsFullyVisible) {\n            // Item is already visible, do nothing.\n            return;\n          }\n          var itemIsPartiallyAbove = scrollTop < scrollWindow.top;\n          var itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\n          if (itemIsPartiallyAbove) {\n            //  We will just scroll to 'scrollTop'\n            //  .------.   - scrollTop\n            //  |Item  |\n            //  | .----|-. - scrollWindow.top\n            //  '------' |\n            //    |      |\n            //    '------'\n          } else if (itemIsPartiallyBelow) {\n            //  Adjust scrollTop position to just bring in the element\n            // .------.  - scrollTop\n            // |      |\n            // | .------.\n            // '-|----' | - scrollWindow.bottom\n            //   | Item |\n            //   '------' - scrollBottom\n            scrollTop = scrollBottom - scrollRect.height;\n          }\n        }\n        if (this._scrollElement) {\n          setScrollYPosition(this._scrollElement, scrollTop);\n        }\n        return;\n      }\n      scrollTop += pageHeight;\n    }\n  };\n  List.prototype.getStartItemIndexInView = function (measureItem) {\n    var pages = this.state.pages || [];\n    for (var _i = 0, pages_1 = pages; _i < pages_1.length; _i++) {\n      var page = pages_1[_i];\n      var isPageVisible = !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\n      if (isPageVisible) {\n        if (!measureItem) {\n          var rowHeight = Math.floor(page.height / page.itemCount);\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\n        } else {\n          var totalRowHeight = 0;\n          for (var itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\n            var rowHeight = measureItem(itemIndex);\n            if (page.top + totalRowHeight <= this._scrollTop && this._scrollTop < page.top + totalRowHeight + rowHeight) {\n              return itemIndex;\n            } else {\n              totalRowHeight += rowHeight;\n            }\n          }\n        }\n      }\n    }\n    return 0;\n  };\n  List.prototype.componentDidMount = function () {\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    // Ensure that scrolls are lazy updated.\n    this._onAsyncScrollDebounced = this._async.debounce(this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\n      leading: false,\n      maxWait: MAX_SCROLL_UPDATE_DELAY\n    });\n    this._onAsyncIdleDebounced = this._async.debounce(this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\n      leading: false\n    });\n    this._onAsyncResizeDebounced = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n      leading: false\n    });\n    this._onScrollingDoneDebounced = this._async.debounce(this._onScrollingDone, DONE_SCROLLING_WAIT, {\n      leading: false\n    });\n    this._scrollElement = findScrollableParent(this._root.current);\n    this._scrollTop = 0;\n    this.setState(__assign(__assign({}, this._updatePages(this.props, this.state)), {\n      hasMounted: true\n    }));\n    this._measureVersion++;\n    var win = getWindowEx(this.context);\n    this._events.on(win, 'resize', this._onAsyncResizeDebounced);\n    if (this._root.current) {\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\n    }\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScrollDebounced);\n    }\n    // this._debugRenderer = new ListDebugRenderer();\n    // const debugRender = () => {\n    //   this._debugRenderer.render({\n    //     visibleRect: this._visibleRect,\n    //     allowedRect: this._allowedRect,\n    //     requiredRect: this._requiredRect,\n    //     materializedRect: this._materializedRect,\n    //     surfaceRect: this._surfaceRect,\n    //     totalListHeight: this.getTotalListHeight(),\n    //     pages: this.state.pages,\n    //     scrollTop: Math.abs(this._scrollTop - getScrollYPosition(this._scrollElement)),\n    //     estimatedLine: this._estimatedPageHeight * SCROLL_RATIO,\n    //     scrollY: getScrollYPosition(this._scrollElement),\n    //   });\n    //   this._debugRafId = requestAnimationFrame(debugRender);\n    // };\n    // debugRender();\n  };\n  List.prototype.componentDidUpdate = function (previousProps, previousState) {\n    // Multiple updates may have been queued, so the callback will reflect all of them.\n    // Re-fetch the current props and states to avoid using a stale props or state captured in the closure.\n    var finalProps = this.props;\n    var finalState = this.state;\n    if (this.state.pagesVersion !== previousState.pagesVersion) {\n      // If we weren't provided with the page height, measure the pages\n      if (!finalProps.getPageHeight) {\n        // If measured version is invalid since we've updated the DOM\n        var heightsChanged = this._updatePageMeasurements(finalState.pages);\n        // On first render, we should re-measure so that we don't get a visual glitch.\n        if (heightsChanged) {\n          this._materializedRect = null;\n          if (!this._hasCompletedFirstRender) {\n            this._hasCompletedFirstRender = true;\n            this.setState(this._updatePages(finalProps, finalState));\n          } else {\n            this._onAsyncScrollDebounced();\n          }\n        } else {\n          // Enqueue an idle bump.\n          this._onAsyncIdleDebounced();\n        }\n      } else {\n        // Enqueue an idle bump\n        this._onAsyncIdleDebounced();\n      }\n      // Notify the caller that rendering the new pages has completed\n      if (finalProps.onPagesUpdated) {\n        finalProps.onPagesUpdated(finalState.pages);\n      }\n    }\n  };\n  List.prototype.componentWillUnmount = function () {\n    var _a, _b;\n    (_a = this._async) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this._events) === null || _b === void 0 ? void 0 : _b.dispose();\n    delete this._scrollElement;\n    // this._debugRenderer.dispose();\n    // if (this._debugRafId) {\n    //   cancelAnimationFrame(this._debugRafId);\n    //   this._debugRafId = undefined;\n    // }\n  };\n  List.prototype.shouldComponentUpdate = function (newProps, newState) {\n    var oldPages = this.state.pages;\n    var newPages = newState.pages;\n    var shouldComponentUpdate = false;\n    // Update if the page stops scrolling\n    if (!newState.isScrolling && this.state.isScrolling) {\n      return true;\n    }\n    if (newProps.version !== this.props.version) {\n      return true;\n    }\n    if (newProps.className !== this.props.className) {\n      return true;\n    }\n    if (newProps.items === this.props.items && oldPages.length === newPages.length) {\n      for (var i = 0; i < oldPages.length; i++) {\n        var oldPage = oldPages[i];\n        var newPage = newPages[i];\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n    return shouldComponentUpdate;\n  };\n  List.prototype.forceUpdate = function () {\n    this._invalidatePageCache();\n    // Ensure that when the list is force updated we update the pages first before render.\n    this._updateRenderRects(this.props, this.state, true);\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n    _super.prototype.forceUpdate.call(this);\n  };\n  /**\n   * Get the current height the list and it's pages.\n   */\n  List.prototype.getTotalListHeight = function () {\n    return this._surfaceRect.height;\n  };\n  List.prototype.render = function () {\n    var _a = this.props,\n      className = _a.className,\n      _b = _a.role,\n      role = _b === void 0 ? 'list' : _b,\n      onRenderSurface = _a.onRenderSurface,\n      onRenderRoot = _a.onRenderRoot;\n    var _c = this.state.pages,\n      pages = _c === void 0 ? [] : _c;\n    var pageElements = [];\n    var divProps = getNativeProps(this.props, divProperties);\n    for (var _i = 0, pages_2 = pages; _i < pages_2.length; _i++) {\n      var page = pages_2[_i];\n      pageElements.push(this._renderPage(page));\n    }\n    var finalOnRenderSurface = onRenderSurface ? composeRenderFunction(onRenderSurface, this._onRenderSurface) : this._onRenderSurface;\n    var finalOnRenderRoot = onRenderRoot ? composeRenderFunction(onRenderRoot, this._onRenderRoot) : this._onRenderRoot;\n    return finalOnRenderRoot({\n      rootRef: this._root,\n      pages: pages,\n      surfaceElement: finalOnRenderSurface({\n        surfaceRef: this._surface,\n        pages: pages,\n        pageElements: pageElements,\n        divProps: {\n          role: 'presentation',\n          className: 'ms-List-surface'\n        }\n      }),\n      divProps: __assign(__assign({}, divProps), {\n        className: css('ms-List', className),\n        role: pageElements.length > 0 ? role : undefined,\n        'aria-label': pageElements.length > 0 ? divProps['aria-label'] : undefined\n      })\n    });\n  };\n  List.prototype._shouldVirtualize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    var onShouldVirtualize = props.onShouldVirtualize;\n    return !onShouldVirtualize || onShouldVirtualize(props);\n  };\n  /**\n   * when props.items change or forceUpdate called, throw away cached pages\n   */\n  List.prototype._invalidatePageCache = function () {\n    this._pageCache = {};\n  };\n  List.prototype._renderPage = function (page) {\n    var _this = this;\n    var usePageCache = this.props.usePageCache;\n    var cachedPage;\n    // if usePageCache is set and cached page element can be found, just return cached page\n    if (usePageCache) {\n      cachedPage = this._pageCache[page.key];\n      if (cachedPage && cachedPage.pageElement) {\n        return cachedPage.pageElement;\n      }\n    }\n    var pageStyle = this._getPageStyle(page);\n    var _a = this.props.onRenderPage,\n      onRenderPage = _a === void 0 ? this._onRenderPage : _a;\n    var pageElement = onRenderPage({\n      page: page,\n      className: 'ms-List-page',\n      key: page.key,\n      ref: function (newRef) {\n        _this._pageRefs[page.key] = newRef;\n      },\n      style: pageStyle,\n      role: 'presentation'\n    }, this._onRenderPage);\n    // cache the first page for now since it is re-rendered a lot times unnecessarily.\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\n    if (usePageCache && page.startIndex === 0) {\n      this._pageCache[page.key] = {\n        page: page,\n        pageElement: pageElement\n      };\n    }\n    return pageElement;\n  };\n  /** Generate the style object for the page. */\n  List.prototype._getPageStyle = function (page) {\n    var getPageStyle = this.props.getPageStyle;\n    return __assign(__assign({}, getPageStyle ? getPageStyle(page) : {}), !page.items ? {\n      height: page.height\n    } : {});\n  };\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n  List.prototype._onFocus = function (ev) {\n    var target = ev.target;\n    while (target !== this._surface.current) {\n      var indexString = target.getAttribute('data-list-index');\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n      target = getParent(target);\n    }\n  };\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n  List.prototype._onScroll = function () {\n    if (!this.state.isScrolling && !this.props.ignoreScrollingState) {\n      this.setState({\n        isScrolling: true\n      });\n    }\n    this._resetRequiredWindows();\n    this._onScrollingDoneDebounced();\n  };\n  List.prototype._resetRequiredWindows = function () {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  };\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n  List.prototype._onAsyncScroll = function () {\n    this._updateRenderRects(this.props, this.state);\n    // Only update pages when the visible rect falls outside of the materialized rect.\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {\n      this.setState(this._updatePages(this.props, this.state));\n    } else {\n      // console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  };\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n  List.prototype._onAsyncIdle = function () {\n    var _a = this.props,\n      renderedWindowsAhead = _a.renderedWindowsAhead,\n      renderedWindowsBehind = _a.renderedWindowsBehind;\n    var _b = this,\n      requiredWindowsAhead = _b._requiredWindowsAhead,\n      requiredWindowsBehind = _b._requiredWindowsBehind;\n    var windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);\n    var windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n      // console.log('idling', windowsBehind, windowsAhead);\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n      this._updateRenderRects(this.props, this.state);\n      this.setState(this._updatePages(this.props, this.state));\n    }\n    if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdleDebounced();\n    }\n  };\n  /**\n   * Function to call when the list is done scrolling.\n   * This function is debounced.\n   */\n  List.prototype._onScrollingDone = function () {\n    if (!this.props.ignoreScrollingState) {\n      this.setState({\n        isScrolling: false\n      });\n      this._onAsyncIdle();\n    }\n  };\n  List.prototype._onAsyncResize = function () {\n    this.forceUpdate();\n  };\n  List.prototype._updatePages = function (nextProps, previousState) {\n    // console.log('updating pages');\n    if (!this._requiredRect) {\n      this._updateRenderRects(nextProps, previousState);\n    }\n    var newListState = this._buildPages(nextProps, previousState);\n    var oldListPages = previousState.pages;\n    this._notifyPageChanges(oldListPages, newListState.pages, this.props);\n    return __assign(__assign(__assign({}, previousState), newListState), {\n      pagesVersion: {}\n    });\n  };\n  /**\n   * Notify consumers that the rendered pages have changed\n   * @param oldPages - The old pages\n   * @param newPages - The new pages\n   * @param props - The props to use\n   */\n  List.prototype._notifyPageChanges = function (oldPages, newPages, props) {\n    var onPageAdded = props.onPageAdded,\n      onPageRemoved = props.onPageRemoved;\n    if (onPageAdded || onPageRemoved) {\n      var renderedIndexes = {};\n      for (var _i = 0, oldPages_1 = oldPages; _i < oldPages_1.length; _i++) {\n        var page = oldPages_1[_i];\n        if (page.items) {\n          renderedIndexes[page.startIndex] = page;\n        }\n      }\n      for (var _a = 0, newPages_1 = newPages; _a < newPages_1.length; _a++) {\n        var page = newPages_1[_a];\n        if (page.items) {\n          if (!renderedIndexes[page.startIndex]) {\n            this._onPageAdded(page);\n          } else {\n            delete renderedIndexes[page.startIndex];\n          }\n        }\n      }\n      for (var index in renderedIndexes) {\n        if (renderedIndexes.hasOwnProperty(index)) {\n          this._onPageRemoved(renderedIndexes[index]);\n        }\n      }\n    }\n  };\n  List.prototype._updatePageMeasurements = function (pages) {\n    var heightChanged = false;\n    // when not in virtualize mode, we render all the items without page measurement\n    if (!this._shouldVirtualize()) {\n      return heightChanged;\n    }\n    for (var i = 0; i < pages.length; i++) {\n      var page = pages[i];\n      if (page.items) {\n        heightChanged = this._measurePage(page) || heightChanged;\n      }\n    }\n    return heightChanged;\n  };\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n  List.prototype._measurePage = function (page) {\n    var hasChangedHeight = false;\n    var pageElement = this._pageRefs[page.key];\n    var cachedHeight = this._cachedPageHeights[page.startIndex];\n    // console.log('   * measure attempt', page.startIndex, cachedHeight);\n    if (pageElement && this._shouldVirtualize() && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {\n      var newClientRect = {\n        width: pageElement.clientWidth,\n        height: pageElement.clientHeight\n      };\n      if (newClientRect.height || newClientRect.width) {\n        hasChangedHeight = page.height !== newClientRect.height;\n        // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n        page.height = newClientRect.height;\n        this._cachedPageHeights[page.startIndex] = {\n          height: newClientRect.height,\n          measureVersion: this._measureVersion\n        };\n        this._estimatedPageHeight = Math.round((this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1));\n        this._totalEstimates++;\n      }\n    }\n    return hasChangedHeight;\n  };\n  /** Called when a page has been added to the DOM. */\n  List.prototype._onPageAdded = function (page) {\n    var onPageAdded = this.props.onPageAdded;\n    // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  };\n  /** Called when a page has been removed from the DOM. */\n  List.prototype._onPageRemoved = function (page) {\n    var onPageRemoved = this.props.onPageRemoved;\n    // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  };\n  /** Build up the pages that should be rendered. */\n  List.prototype._buildPages = function (props, state) {\n    var renderCount = props.renderCount;\n    var items = props.items,\n      startIndex = props.startIndex,\n      getPageHeight = props.getPageHeight;\n    renderCount = this._getRenderCount(props);\n    var materializedRect = __assign({}, EMPTY_RECT);\n    var pages = [];\n    var itemsPerPage = 1;\n    var pageTop = 0;\n    var currentSpacer = null;\n    var focusedIndex = this._focusedIndex;\n    var endIndex = startIndex + renderCount;\n    var shouldVirtualize = this._shouldVirtualize(props);\n    // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n    var isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\n    var allowedRect = this._allowedRect;\n    var _loop_1 = function (itemIndex) {\n      var pageSpecification = this_1._getPageSpecification(props, itemIndex, allowedRect);\n      var pageHeight = pageSpecification.height;\n      var pageData = pageSpecification.data;\n      var key = pageSpecification.key;\n      itemsPerPage = pageSpecification.itemCount;\n      var pageBottom = pageTop + pageHeight - 1;\n      var isPageRendered = findIndex(state.pages, function (page) {\n        return !!page.items && page.startIndex === itemIndex;\n      }) > -1;\n      var isPageInAllowedRange = !allowedRect || pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom;\n      var isPageInRequiredRange = !this_1._requiredRect || pageBottom >= this_1._requiredRect.top && pageTop <= this_1._requiredRect.bottom;\n      var isPageVisible = !isFirstRender && (isPageInRequiredRange || isPageInAllowedRange && isPageRendered) || !shouldVirtualize;\n      var isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\n      var isFirstPage = itemIndex === startIndex;\n      // Only render whats visible, focused, or first page,\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n        var itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n        var newPage = this_1._createPage(key, items.slice(itemIndex, itemIndex + itemsInPage), itemIndex, undefined, undefined, pageData);\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n        if (this_1._visibleRect && this_1._visibleRect.bottom) {\n          newPage.isVisible = pageBottom >= this_1._visibleRect.top && pageTop <= this_1._visibleRect.bottom;\n        }\n        pages.push(newPage);\n        if (isPageInRequiredRange && this_1._allowedRect) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: allowedRect.left,\n            right: allowedRect.right,\n            width: allowedRect.width\n          });\n        }\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this_1._createPage(SPACER_KEY_PREFIX + itemIndex, undefined, itemIndex, 0, undefined, pageData, true /*isSpacer*/);\n        }\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n      pageTop += pageBottom - pageTop + 1;\n      // in virtualized mode, we render need to render first page then break and measure,\n      // otherwise, we render all items without measurement to make rendering fast\n      if (isFirstRender && shouldVirtualize) {\n        return \"break\";\n      }\n    };\n    var this_1 = this;\n    for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      var state_1 = _loop_1(itemIndex);\n      if (state_1 === \"break\") break;\n    }\n    if (currentSpacer) {\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\n      pages.push(currentSpacer);\n    }\n    this._materializedRect = materializedRect;\n    // console.log('materialized: ', materializedRect);\n    return __assign(__assign({}, state), {\n      pages: pages,\n      measureVersion: this._measureVersion\n    });\n  };\n  List.prototype._getPageSpecification = function (props, itemIndex, visibleRect) {\n    var getPageSpecification = props.getPageSpecification;\n    if (getPageSpecification) {\n      var pageData = getPageSpecification(itemIndex, visibleRect, props.items);\n      var _a = pageData.itemCount,\n        itemCount = _a === void 0 ? this._getItemCountForPage(itemIndex, visibleRect) : _a;\n      var _b = pageData.height,\n        height = _b === void 0 ? this._getPageHeight(itemIndex, visibleRect, itemCount) : _b;\n      return {\n        itemCount: itemCount,\n        height: height,\n        data: pageData.data,\n        key: pageData.key\n      };\n    } else {\n      var itemCount = this._getItemCountForPage(itemIndex, visibleRect);\n      return {\n        itemCount: itemCount,\n        height: this._getPageHeight(itemIndex, visibleRect, itemCount)\n      };\n    }\n  };\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n  List.prototype._getPageHeight = function (itemIndex, visibleRect, itemsPerPage) {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage, this.props.items);\n    } else {\n      var cachedHeight = this._cachedPageHeights[itemIndex];\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\n    }\n  };\n  List.prototype._getItemCountForPage = function (itemIndex, visibileRect) {\n    var itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  };\n  List.prototype._createPage = function (pageKey, items, startIndex, count, style, data, isSpacer) {\n    if (startIndex === void 0) {\n      startIndex = -1;\n    }\n    if (count === void 0) {\n      count = items ? items.length : 0;\n    }\n    if (style === void 0) {\n      style = {};\n    }\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\n    var cachedPage = this._pageCache[pageKey];\n    if (cachedPage && cachedPage.page) {\n      return cachedPage.page;\n    }\n    return {\n      key: pageKey,\n      startIndex: startIndex,\n      itemCount: count,\n      items: items,\n      style: style,\n      top: 0,\n      height: 0,\n      data: data,\n      isSpacer: isSpacer || false\n    };\n  };\n  List.prototype._getRenderCount = function (props) {\n    var _a = props || this.props,\n      items = _a.items,\n      startIndex = _a.startIndex,\n      renderCount = _a.renderCount;\n    return renderCount === undefined ? items ? items.length - startIndex : 0 : renderCount;\n  };\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n  List.prototype._updateRenderRects = function (props, state, forceUpdate) {\n    var renderedWindowsAhead = props.renderedWindowsAhead,\n      renderedWindowsBehind = props.renderedWindowsBehind;\n    var pages = state.pages;\n    // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\n    if (!this._shouldVirtualize(props)) {\n      return;\n    }\n    var surfaceRect = this._surfaceRect || __assign({}, EMPTY_RECT);\n    var scrollHeight = getScrollHeight(this._scrollElement);\n    var scrollTop = getScrollYPosition(this._scrollElement);\n    // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    // This needs to be called to recalculate when new pages should be loaded.\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\n    if (this._surface.current && (forceUpdate || !pages || !this._surfaceRect || !scrollHeight || scrollHeight !== this._scrollHeight || Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight * SCROLL_RATIO)) {\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\n      this._scrollTop = scrollTop;\n    }\n    // If the scroll height has changed, something in the container likely resized and\n    // we should redo the page heights incase their content resized.\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\n      this._measureVersion++;\n    }\n    this._scrollHeight = scrollHeight || 0;\n    // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n    var visibleTop = Math.max(0, -surfaceRect.top);\n    var win = getWindow(this._root.current);\n    var visibleRect = {\n      top: visibleTop,\n      left: surfaceRect.left,\n      bottom: visibleTop + win.innerHeight,\n      right: surfaceRect.right,\n      width: surfaceRect.width,\n      height: win.innerHeight\n    };\n    // The required/allowed rects are adjusted versions of the visible rect.\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead);\n    // store the visible rect for later use.\n    this._visibleRect = visibleRect;\n  };\n  List.defaultProps = {\n    startIndex: 0,\n    onRenderCell: function (item, index, containsFocus) {\n      return React.createElement(React.Fragment, null, item && item.name || '');\n    },\n    onRenderCellConditional: undefined,\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND\n  };\n  List.contextType = WindowContext;\n  return List;\n}(React.Component);\nexport { List };\nfunction _expandRect(rect, pagesBefore, pagesAfter) {\n  var top = rect.top - pagesBefore * rect.height;\n  var height = rect.height + (pagesBefore + pagesAfter) * rect.height;\n  return {\n    top: top,\n    bottom: top + height,\n    height: height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width\n  };\n}\nfunction _isContainedWithin(innerRect, outerRect) {\n  return innerRect.top >= outerRect.top && innerRect.left >= outerRect.left && innerRect.bottom <= outerRect.bottom && innerRect.right <= outerRect.right;\n}\nfunction _mergeRect(targetRect, newRect) {\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\n  targetRect.bottom = newRect.bottom > targetRect.bottom || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\n  targetRect.right = newRect.right > targetRect.right || targetRect.right === -1 ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right - targetRect.left + 1;\n  targetRect.height = targetRect.bottom - targetRect.top + 1;\n  return targetRect;\n}","map":{"version":3,"names":["React","Async","EventGroup","canUseDOM","css","divProperties","findIndex","findScrollableParent","getNativeProps","getParent","getWindow","initializeComponentRef","ScrollToMode","composeRenderFunction","getScrollHeight","getScrollYPosition","setScrollYPosition","WindowContext","getWindowEx","RESIZE_DELAY","MIN_SCROLL_UPDATE_DELAY","MAX_SCROLL_UPDATE_DELAY","IDLE_DEBOUNCE_DELAY","DONE_SCROLLING_WAIT","DEFAULT_ITEMS_PER_PAGE","DEFAULT_PAGE_HEIGHT","DEFAULT_RENDERED_WINDOWS_BEHIND","DEFAULT_RENDERED_WINDOWS_AHEAD","PAGE_KEY_PREFIX","SPACER_KEY_PREFIX","SCROLL_RATIO","EMPTY_RECT","top","bottom","left","right","width","height","_measurePageRect","element","getBoundingClientRect","_measureSurfaceRect","_measureScrollRect","List","_super","__extends","props","_this","call","_root","createRef","_surface","_pageRefs","_getDerivedStateFromProps","nextProps","previousState","items","renderCount","startIndex","version","hasMounted","renderEarly","_resetRequiredWindows","_requiredRect","_measureVersion","_invalidatePageCache","_updatePages","_onRenderRoot","rootRef","surfaceElement","divProps","createElement","__assign","ref","_onRenderSurface","surfaceRef","pageElements","_onRenderPage","pageProps","defaultRender","_b","onRenderCell","onRenderCellConditional","role","_c","page","_d","__rest","cellRole","undefined","cells","i","length","index","item","itemKey","getKey","key","renderCell","cell","_a","ignoreScrollingState","state","isScrolling","push","className","pages","getDerivedStateFromProps","_estimatedPageHeight","_totalEstimates","_requiredWindowsAhead","_requiredWindowsBehind","_cachedPageHeights","_focusedIndex","_pageCache","Object","defineProperty","prototype","get","scrollToIndex","measureItem","scrollToMode","auto","_getRenderCount","endIndex","allowedRect","_allowedRect","scrollTop","itemsPerPage","itemIndex","pageSpecification","_getPageSpecification","pageHeight","itemCount","requestedIndexIsInPage","_scrollElement","scrollRect","scrollPosition","scrollWindow","itemPositionWithinPage","itemIndexInPage","scrollBottom","center","itemIsFullyVisible","itemIsPartiallyAbove","itemIsPartiallyBelow","getStartItemIndexInView","_i","pages_1","isPageVisible","isSpacer","_scrollTop","rowHeight","Math","floor","totalRowHeight","componentDidMount","_async","_events","_onAsyncScrollDebounced","debounce","_onAsyncScroll","leading","maxWait","_onAsyncIdleDebounced","_onAsyncIdle","_onAsyncResizeDebounced","_onAsyncResize","_onScrollingDoneDebounced","_onScrollingDone","current","setState","win","context","on","_onFocus","_onScroll","componentDidUpdate","previousProps","finalProps","finalState","pagesVersion","getPageHeight","heightsChanged","_updatePageMeasurements","_materializedRect","_hasCompletedFirstRender","onPagesUpdated","componentWillUnmount","dispose","shouldComponentUpdate","newProps","newState","oldPages","newPages","oldPage","newPage","forceUpdate","_updateRenderRects","getTotalListHeight","_surfaceRect","render","onRenderSurface","onRenderRoot","pages_2","_renderPage","finalOnRenderSurface","finalOnRenderRoot","_shouldVirtualize","onShouldVirtualize","usePageCache","cachedPage","pageElement","pageStyle","_getPageStyle","onRenderPage","newRef","style","getPageStyle","ev","target","indexString","getAttribute","Number","_isContainedWithin","renderedWindowsAhead","renderedWindowsBehind","requiredWindowsAhead","requiredWindowsBehind","windowsAhead","min","windowsBehind","newListState","_buildPages","oldListPages","_notifyPageChanges","onPageAdded","onPageRemoved","renderedIndexes","oldPages_1","newPages_1","_onPageAdded","hasOwnProperty","_onPageRemoved","heightChanged","_measurePage","hasChangedHeight","cachedHeight","measureVersion","newClientRect","clientWidth","clientHeight","round","materializedRect","pageTop","currentSpacer","focusedIndex","shouldVirtualize","isFirstRender","this_1","pageData","data","pageBottom","isPageRendered","isPageInAllowedRange","isPageInRequiredRange","isPageFocused","isFirstPage","itemsInPage","_createPage","slice","_visibleRect","isVisible","_mergeRect","visibleRect","getPageSpecification","_getItemCountForPage","_getPageHeight","visibileRect","getItemCountForPage","pageKey","count","surfaceRect","scrollHeight","_scrollHeight","abs","visibleTop","max","innerHeight","_expandRect","defaultProps","containsFocus","Fragment","name","contextType","Component","rect","pagesBefore","pagesAfter","innerRect","outerRect","targetRect","newRect"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\List\\List.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  canUseDOM,\n  css,\n  divProperties,\n  findIndex,\n  findScrollableParent,\n  getNativeProps,\n  getParent,\n  getWindow,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { ScrollToMode } from './List.types';\nimport { composeRenderFunction } from '../../Utilities';\nimport { getScrollHeight, getScrollYPosition, setScrollYPosition } from './utils/scroll';\nimport type { IRectangle, IRenderFunction } from '../../Utilities';\nimport type {\n  IList,\n  IListProps,\n  IPage,\n  IPageProps,\n  IListOnRenderSurfaceProps,\n  IListOnRenderRootProps,\n} from './List.types';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getWindowEx } from '../../utilities/dom';\n// import { ListDebugRenderer } from './utils/ListDebugRenderer';\n\nconst RESIZE_DELAY = 16;\nconst MIN_SCROLL_UPDATE_DELAY = 100;\nconst MAX_SCROLL_UPDATE_DELAY = 500;\nconst IDLE_DEBOUNCE_DELAY = 200;\n// The amount of time to wait before declaring that the list isn't scrolling\nconst DONE_SCROLLING_WAIT = 500;\nconst DEFAULT_ITEMS_PER_PAGE = 10;\nconst DEFAULT_PAGE_HEIGHT = 30;\nconst DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nconst DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nconst PAGE_KEY_PREFIX = 'page-';\nconst SPACER_KEY_PREFIX = 'spacer-';\n// Fraction of a page to have been scrolled before re-running expensive calculations\nconst SCROLL_RATIO = 1 / 3;\n\nexport interface IListState<T = any> {\n  pages?: IPage<T>[];\n\n  /** The last versionstamp for  */\n  measureVersion?: number;\n  isScrolling?: boolean;\n  getDerivedStateFromProps(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T>;\n\n  pagesVersion?: {};\n  hasMounted: boolean;\n}\n\ninterface IPageCacheItem<T> {\n  page: IPage<T>;\n  pageElement?: JSX.Element;\n}\n\ninterface IPageCache<T> {\n  [key: string]: IPageCacheItem<T>;\n}\n\nconst EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0,\n};\n\n// Naming expensive measures so that they're named in profiles.\nconst _measurePageRect = (element: HTMLElement) => element.getBoundingClientRect();\nconst _measureSurfaceRect = _measurePageRect;\nconst _measureScrollRect = _measurePageRect;\n\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback\n * if provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if\n * provided by the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time.\n * And we start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\nexport class List<T = any> extends React.Component<IListProps<T>, IListState<T>> implements IList {\n  public static defaultProps = {\n    startIndex: 0,\n    onRenderCell: (item: any, index: number, containsFocus: boolean) => <>{(item && item.name) || ''}</>,\n    onRenderCellConditional: undefined,\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND,\n  };\n\n  public static contextType = WindowContext;\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _surface = React.createRef<HTMLDivElement>();\n  private _pageRefs: Record<string, unknown> = {};\n  private _async: Async;\n  private _events: EventGroup;\n  private _onAsyncScrollDebounced: () => void;\n  private _onAsyncIdleDebounced: () => void;\n  private _onScrollingDoneDebounced: () => void;\n  private _onAsyncResizeDebounced: () => void;\n  private _estimatedPageHeight: number;\n  private _totalEstimates: number;\n  private _cachedPageHeights: {\n    [key: string]: {\n      height: number;\n      measureVersion: number;\n    };\n  };\n  private _focusedIndex: number;\n  private _scrollElement?: HTMLElement;\n  private _hasCompletedFirstRender: boolean;\n\n  // surface rect relative to window\n  private _surfaceRect: IRectangle | undefined;\n\n  // The visible rect that we're required to render given the current list state.\n  private _requiredRect: IRectangle | null;\n\n  // The visible rect that we're allowed to keep rendered. Pages outside of this rect will be removed.\n  private _allowedRect: IRectangle;\n\n  // The rect that is visible to the user\n  private _visibleRect: IRectangle | undefined;\n\n  // materialized rect around visible items, relative to surface\n  private _materializedRect: IRectangle | null;\n\n  private _requiredWindowsAhead: number;\n  private _requiredWindowsBehind: number;\n\n  private _measureVersion: number;\n  private _scrollHeight?: number;\n  private _scrollTop: number;\n  private _pageCache: IPageCache<T>;\n\n  // private _debugRenderer: ListDebugRenderer;\n  // private _debugRafId: number | undefined = undefined;\n\n  public static getDerivedStateFromProps<U = any>(\n    nextProps: IListProps<U>,\n    previousState: IListState<U>,\n  ): IListState<U> {\n    return previousState.getDerivedStateFromProps(nextProps, previousState);\n  }\n\n  constructor(props: IListProps<T>) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      pages: [],\n      isScrolling: false,\n      getDerivedStateFromProps: this._getDerivedStateFromProps,\n      hasMounted: false,\n    };\n\n    this._estimatedPageHeight = 0;\n    this._totalEstimates = 0;\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n\n    // Track the measure version for everything.\n    this._measureVersion = 0;\n\n    this._cachedPageHeights = {};\n    this._estimatedPageHeight = 0;\n    this._focusedIndex = -1;\n    this._pageCache = {};\n  }\n\n  public get pageRefs(): Readonly<Record<string, unknown>> {\n    return this._pageRefs;\n  }\n\n  /**\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\n   *\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\n   *\n   * @param index - Index of item to scroll to\n   * @param measureItem - Optional callback to measure the height of an individual item\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\n   */\n  public scrollToIndex(\n    index: number,\n    measureItem?: (itemIndex: number) => number,\n    scrollToMode: ScrollToMode = ScrollToMode.auto,\n  ): void {\n    const startIndex = this.props.startIndex as number;\n    const renderCount = this._getRenderCount();\n    const endIndex = startIndex + renderCount;\n\n    const allowedRect = this._allowedRect;\n\n    let scrollTop = 0;\n\n    let itemsPerPage = 1;\n    for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      const pageSpecification = this._getPageSpecification(this.props, itemIndex, allowedRect);\n\n      const pageHeight = pageSpecification.height;\n      itemsPerPage = pageSpecification.itemCount;\n\n      const requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\n      if (requestedIndexIsInPage) {\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in\n        // just the given item, otherwise we'll only bring the page into view\n        if (measureItem && this._scrollElement) {\n          const scrollRect = _measureScrollRect(this._scrollElement);\n          const scrollPosition = getScrollYPosition(this._scrollElement);\n          const scrollWindow = {\n            top: scrollPosition,\n            bottom: scrollPosition + scrollRect.height,\n          };\n\n          // Adjust for actual item position within page\n          const itemPositionWithinPage = index - itemIndex;\n          for (let itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\n          }\n          const scrollBottom = scrollTop + measureItem(index);\n\n          // If scrollToMode is set to something other than auto, we always want to\n          // scroll the item into a specific position on the page.\n          switch (scrollToMode) {\n            case ScrollToMode.top:\n              setScrollYPosition(this._scrollElement, scrollTop);\n              return;\n            case ScrollToMode.bottom:\n              setScrollYPosition(this._scrollElement, scrollBottom - scrollRect.height);\n              return;\n            case ScrollToMode.center:\n              setScrollYPosition(this._scrollElement, (scrollTop + scrollBottom - scrollRect.height) / 2);\n              return;\n            case ScrollToMode.auto:\n            default:\n              break;\n          }\n\n          const itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\n          if (itemIsFullyVisible) {\n            // Item is already visible, do nothing.\n            return;\n          }\n\n          const itemIsPartiallyAbove = scrollTop < scrollWindow.top;\n          const itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\n\n          if (itemIsPartiallyAbove) {\n            //  We will just scroll to 'scrollTop'\n            //  .------.   - scrollTop\n            //  |Item  |\n            //  | .----|-. - scrollWindow.top\n            //  '------' |\n            //    |      |\n            //    '------'\n          } else if (itemIsPartiallyBelow) {\n            //  Adjust scrollTop position to just bring in the element\n            // .------.  - scrollTop\n            // |      |\n            // | .------.\n            // '-|----' | - scrollWindow.bottom\n            //   | Item |\n            //   '------' - scrollBottom\n            scrollTop = scrollBottom - scrollRect.height;\n          }\n        }\n\n        if (this._scrollElement) {\n          setScrollYPosition(this._scrollElement, scrollTop);\n        }\n        return;\n      }\n\n      scrollTop += pageHeight;\n    }\n  }\n\n  public getStartItemIndexInView(measureItem?: (itemIndex: number) => number): number {\n    const pages = this.state.pages || [];\n    for (const page of pages) {\n      const isPageVisible =\n        !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\n      if (isPageVisible) {\n        if (!measureItem) {\n          const rowHeight = Math.floor(page.height / page.itemCount);\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\n        } else {\n          let totalRowHeight = 0;\n          for (let itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\n            const rowHeight = measureItem(itemIndex);\n            if (\n              page.top + totalRowHeight <= this._scrollTop &&\n              this._scrollTop < page.top + totalRowHeight + rowHeight\n            ) {\n              return itemIndex;\n            } else {\n              totalRowHeight += rowHeight;\n            }\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n  public componentDidMount(): void {\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    // Ensure that scrolls are lazy updated.\n    this._onAsyncScrollDebounced = this._async.debounce(this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\n      leading: false,\n      maxWait: MAX_SCROLL_UPDATE_DELAY,\n    });\n\n    this._onAsyncIdleDebounced = this._async.debounce(this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\n      leading: false,\n    });\n\n    this._onAsyncResizeDebounced = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n      leading: false,\n    });\n\n    this._onScrollingDoneDebounced = this._async.debounce(this._onScrollingDone, DONE_SCROLLING_WAIT, {\n      leading: false,\n    });\n\n    this._scrollElement = findScrollableParent(this._root.current) as HTMLElement;\n    this._scrollTop = 0;\n    this.setState({ ...this._updatePages(this.props, this.state), hasMounted: true });\n    this._measureVersion++;\n\n    const win = getWindowEx(this.context);\n\n    this._events.on(win, 'resize', this._onAsyncResizeDebounced);\n    if (this._root.current) {\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\n    }\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScrollDebounced);\n    }\n\n    // this._debugRenderer = new ListDebugRenderer();\n\n    // const debugRender = () => {\n    //   this._debugRenderer.render({\n    //     visibleRect: this._visibleRect,\n    //     allowedRect: this._allowedRect,\n    //     requiredRect: this._requiredRect,\n    //     materializedRect: this._materializedRect,\n    //     surfaceRect: this._surfaceRect,\n    //     totalListHeight: this.getTotalListHeight(),\n    //     pages: this.state.pages,\n    //     scrollTop: Math.abs(this._scrollTop - getScrollYPosition(this._scrollElement)),\n    //     estimatedLine: this._estimatedPageHeight * SCROLL_RATIO,\n    //     scrollY: getScrollYPosition(this._scrollElement),\n    //   });\n    //   this._debugRafId = requestAnimationFrame(debugRender);\n    // };\n    // debugRender();\n  }\n\n  public componentDidUpdate(previousProps: IListProps, previousState: IListState<T>): void {\n    // Multiple updates may have been queued, so the callback will reflect all of them.\n    // Re-fetch the current props and states to avoid using a stale props or state captured in the closure.\n    const finalProps = this.props;\n    const finalState = this.state;\n\n    if (this.state.pagesVersion !== previousState.pagesVersion) {\n      // If we weren't provided with the page height, measure the pages\n      if (!finalProps.getPageHeight) {\n        // If measured version is invalid since we've updated the DOM\n        const heightsChanged = this._updatePageMeasurements(finalState.pages!);\n\n        // On first render, we should re-measure so that we don't get a visual glitch.\n        if (heightsChanged) {\n          this._materializedRect = null;\n          if (!this._hasCompletedFirstRender) {\n            this._hasCompletedFirstRender = true;\n            this.setState(this._updatePages(finalProps, finalState));\n          } else {\n            this._onAsyncScrollDebounced();\n          }\n        } else {\n          // Enqueue an idle bump.\n          this._onAsyncIdleDebounced();\n        }\n      } else {\n        // Enqueue an idle bump\n        this._onAsyncIdleDebounced();\n      }\n\n      // Notify the caller that rendering the new pages has completed\n      if (finalProps.onPagesUpdated) {\n        finalProps.onPagesUpdated(finalState.pages as IPage<T>[]);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async?.dispose();\n    this._events?.dispose();\n\n    delete this._scrollElement;\n\n    // this._debugRenderer.dispose();\n    // if (this._debugRafId) {\n    //   cancelAnimationFrame(this._debugRafId);\n    //   this._debugRafId = undefined;\n    // }\n  }\n\n  public shouldComponentUpdate(newProps: IListProps<T>, newState: IListState<T>): boolean {\n    const { pages: oldPages } = this.state;\n    const { pages: newPages } = newState;\n    let shouldComponentUpdate = false;\n\n    // Update if the page stops scrolling\n    if (!newState.isScrolling && this.state.isScrolling) {\n      return true;\n    }\n\n    if (newProps.version !== this.props.version) {\n      return true;\n    }\n\n    if (newProps.className !== this.props.className) {\n      return true;\n    }\n\n    if (newProps.items === this.props.items && oldPages!.length === newPages!.length) {\n      for (let i = 0; i < oldPages!.length; i++) {\n        const oldPage = oldPages![i];\n        const newPage = newPages![i];\n\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n\n    return shouldComponentUpdate;\n  }\n\n  public forceUpdate(): void {\n    this._invalidatePageCache();\n    // Ensure that when the list is force updated we update the pages first before render.\n    this._updateRenderRects(this.props, this.state, true);\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n\n    super.forceUpdate();\n  }\n\n  /**\n   * Get the current height the list and it's pages.\n   */\n  public getTotalListHeight(): number {\n    return this._surfaceRect!.height;\n  }\n\n  public render(): JSX.Element | null {\n    const { className, role = 'list', onRenderSurface, onRenderRoot } = this.props;\n    const { pages = [] } = this.state;\n    const pageElements: JSX.Element[] = [];\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    for (const page of pages) {\n      pageElements.push(this._renderPage(page));\n    }\n\n    const finalOnRenderSurface = onRenderSurface\n      ? composeRenderFunction(onRenderSurface, this._onRenderSurface)\n      : this._onRenderSurface;\n\n    const finalOnRenderRoot = onRenderRoot\n      ? composeRenderFunction(onRenderRoot, this._onRenderRoot)\n      : this._onRenderRoot;\n\n    return finalOnRenderRoot({\n      rootRef: this._root,\n      pages,\n      surfaceElement: finalOnRenderSurface({\n        surfaceRef: this._surface,\n        pages,\n        pageElements,\n        divProps: {\n          role: 'presentation',\n          className: 'ms-List-surface',\n        },\n      }),\n      divProps: {\n        ...divProps,\n        className: css('ms-List', className),\n        role: pageElements.length > 0 ? role : undefined,\n        'aria-label': pageElements.length > 0 ? divProps['aria-label'] : undefined,\n      },\n    });\n  }\n\n  private _getDerivedStateFromProps = (nextProps: IListProps<T>, previousState: IListState<T>): IListState<T> => {\n    if (\n      nextProps.items !== this.props.items ||\n      nextProps.renderCount !== this.props.renderCount ||\n      nextProps.startIndex !== this.props.startIndex ||\n      nextProps.version !== this.props.version ||\n      (!previousState.hasMounted && this.props.renderEarly && canUseDOM())\n    ) {\n      // We have received new items so we want to make sure that initially we only render a single window to\n      // fill the currently visible rect, and then later render additional windows.\n      this._resetRequiredWindows();\n      this._requiredRect = null;\n\n      this._measureVersion++;\n      this._invalidatePageCache();\n\n      return this._updatePages(nextProps, previousState);\n    }\n\n    return previousState;\n  };\n\n  private _shouldVirtualize(props: IListProps<T> = this.props): boolean {\n    const { onShouldVirtualize } = props;\n    return !onShouldVirtualize || onShouldVirtualize(props);\n  }\n\n  /**\n   * when props.items change or forceUpdate called, throw away cached pages\n   */\n  private _invalidatePageCache(): void {\n    this._pageCache = {};\n  }\n\n  private _renderPage(page: IPage<T>): JSX.Element {\n    const { usePageCache } = this.props;\n    let cachedPage;\n    // if usePageCache is set and cached page element can be found, just return cached page\n    if (usePageCache) {\n      cachedPage = this._pageCache[page.key];\n      if (cachedPage && cachedPage.pageElement) {\n        return cachedPage.pageElement;\n      }\n    }\n\n    const pageStyle = this._getPageStyle(page);\n\n    const { onRenderPage = this._onRenderPage } = this.props;\n\n    const pageElement = onRenderPage(\n      {\n        page,\n        className: 'ms-List-page',\n        key: page.key,\n        ref: (newRef: unknown) => {\n          this._pageRefs[page.key] = newRef;\n        },\n        style: pageStyle,\n        role: 'presentation',\n      },\n      this._onRenderPage,\n    );\n\n    // cache the first page for now since it is re-rendered a lot times unnecessarily.\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\n    if (usePageCache && page.startIndex === 0) {\n      this._pageCache[page.key] = {\n        page,\n        pageElement,\n      };\n    }\n    return pageElement;\n  }\n\n  private _onRenderRoot = (props: IListOnRenderRootProps<T>): JSX.Element => {\n    const { rootRef, surfaceElement, divProps } = props;\n\n    return (\n      <div ref={rootRef} {...divProps}>\n        {surfaceElement}\n      </div>\n    );\n  };\n\n  private _onRenderSurface = (props: IListOnRenderSurfaceProps<T>): JSX.Element => {\n    const { surfaceRef, pageElements, divProps } = props;\n\n    return (\n      <div ref={surfaceRef} {...divProps}>\n        {pageElements}\n      </div>\n    );\n  };\n\n  /** Generate the style object for the page. */\n  private _getPageStyle(page: IPage<T>): React.StyleHTMLAttributes<HTMLDivElement> {\n    const { getPageStyle } = this.props;\n\n    return {\n      ...(getPageStyle ? getPageStyle(page) : {}),\n      ...(!page.items\n        ? {\n            height: page.height,\n          }\n        : {}),\n    };\n  }\n\n  private _onRenderPage = (pageProps: IPageProps<T>, defaultRender?: IRenderFunction<IPageProps<T>>): any => {\n    const { onRenderCell, onRenderCellConditional, role } = this.props;\n\n    const {\n      page: { items = [], startIndex },\n      ...divProps\n    } = pageProps;\n\n    // only assign list item role if no role is assigned\n    const cellRole = role === undefined ? 'listitem' : 'presentation';\n    const cells: React.ReactNode[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const index = startIndex + i;\n      const item = items[i];\n\n      let itemKey = this.props.getKey ? this.props.getKey(item, index) : item && (item as any).key;\n\n      if (itemKey === null || itemKey === undefined) {\n        itemKey = index;\n      }\n\n      const renderCell = onRenderCellConditional ?? onRenderCell;\n\n      const cell =\n        renderCell?.(item, index, !this.props.ignoreScrollingState ? this.state.isScrolling : undefined) ?? null;\n\n      if (!onRenderCellConditional || cell) {\n        cells.push(\n          <div\n            role={cellRole}\n            className={'ms-List-cell'}\n            key={itemKey}\n            data-list-index={index}\n            data-automationid=\"ListCell\"\n          >\n            {cell}\n          </div>,\n        );\n      }\n    }\n\n    return <div {...divProps}>{cells}</div>;\n  };\n\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n  private _onFocus(ev: any): void {\n    let target = ev.target as HTMLElement;\n\n    while (target !== this._surface.current) {\n      const indexString = target.getAttribute('data-list-index');\n\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  }\n\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n  private _onScroll(): void {\n    if (!this.state.isScrolling && !this.props.ignoreScrollingState) {\n      this.setState({ isScrolling: true });\n    }\n    this._resetRequiredWindows();\n    this._onScrollingDoneDebounced();\n  }\n\n  private _resetRequiredWindows(): void {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  }\n\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n  private _onAsyncScroll(): void {\n    this._updateRenderRects(this.props, this.state);\n\n    // Only update pages when the visible rect falls outside of the materialized rect.\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect as IRectangle, this._materializedRect)) {\n      this.setState(this._updatePages(this.props, this.state));\n    } else {\n      // console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  }\n\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n  private _onAsyncIdle(): void {\n    const { renderedWindowsAhead, renderedWindowsBehind } = this.props;\n    const { _requiredWindowsAhead: requiredWindowsAhead, _requiredWindowsBehind: requiredWindowsBehind } = this;\n    const windowsAhead = Math.min(renderedWindowsAhead as number, requiredWindowsAhead + 1);\n    const windowsBehind = Math.min(renderedWindowsBehind as number, requiredWindowsBehind + 1);\n\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n      // console.log('idling', windowsBehind, windowsAhead);\n\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n      this._updateRenderRects(this.props, this.state);\n      this.setState(this._updatePages(this.props, this.state));\n    }\n\n    if (renderedWindowsAhead! > windowsAhead || renderedWindowsBehind! > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdleDebounced();\n    }\n  }\n\n  /**\n   * Function to call when the list is done scrolling.\n   * This function is debounced.\n   */\n  private _onScrollingDone(): void {\n    if (!this.props.ignoreScrollingState) {\n      this.setState({ isScrolling: false });\n      this._onAsyncIdle();\n    }\n  }\n\n  private _onAsyncResize(): void {\n    this.forceUpdate();\n  }\n\n  private _updatePages(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T> {\n    // console.log('updating pages');\n\n    if (!this._requiredRect) {\n      this._updateRenderRects(nextProps, previousState);\n    }\n\n    const newListState = this._buildPages(nextProps, previousState);\n    const oldListPages = previousState.pages!;\n\n    this._notifyPageChanges(oldListPages, newListState.pages!, this.props);\n\n    return {\n      ...previousState,\n      ...newListState,\n      pagesVersion: {},\n    };\n  }\n\n  /**\n   * Notify consumers that the rendered pages have changed\n   * @param oldPages - The old pages\n   * @param newPages - The new pages\n   * @param props - The props to use\n   */\n  private _notifyPageChanges(oldPages: IPage<T>[], newPages: IPage<T>[], props: IListProps<T>): void {\n    const { onPageAdded, onPageRemoved } = props;\n\n    if (onPageAdded || onPageRemoved) {\n      const renderedIndexes: {\n        [index: number]: IPage<T>;\n      } = {};\n\n      for (const page of oldPages) {\n        if (page.items) {\n          renderedIndexes[page.startIndex] = page;\n        }\n      }\n\n      for (const page of newPages) {\n        if (page.items) {\n          if (!renderedIndexes[page.startIndex]) {\n            this._onPageAdded(page);\n          } else {\n            delete renderedIndexes[page.startIndex];\n          }\n        }\n      }\n\n      for (const index in renderedIndexes) {\n        if (renderedIndexes.hasOwnProperty(index)) {\n          this._onPageRemoved(renderedIndexes[index]);\n        }\n      }\n    }\n  }\n\n  private _updatePageMeasurements(pages: IPage<T>[]): boolean {\n    let heightChanged = false;\n\n    // when not in virtualize mode, we render all the items without page measurement\n    if (!this._shouldVirtualize()) {\n      return heightChanged;\n    }\n\n    for (let i = 0; i < pages.length; i++) {\n      const page = pages[i];\n\n      if (page.items) {\n        heightChanged = this._measurePage(page) || heightChanged;\n      }\n    }\n\n    return heightChanged;\n  }\n\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n  private _measurePage(page: IPage<T>): boolean {\n    let hasChangedHeight = false;\n    const pageElement = this._pageRefs[page.key] as HTMLElement;\n    const cachedHeight = this._cachedPageHeights[page.startIndex];\n\n    // console.log('   * measure attempt', page.startIndex, cachedHeight);\n\n    if (\n      pageElement &&\n      this._shouldVirtualize() &&\n      (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)\n    ) {\n      const newClientRect = {\n        width: pageElement.clientWidth,\n        height: pageElement.clientHeight,\n      };\n\n      if (newClientRect.height || newClientRect.width) {\n        hasChangedHeight = page.height !== newClientRect.height;\n\n        // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n\n        page.height = newClientRect.height;\n\n        this._cachedPageHeights[page.startIndex] = {\n          height: newClientRect.height,\n          measureVersion: this._measureVersion,\n        };\n\n        this._estimatedPageHeight = Math.round(\n          (this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1),\n        );\n\n        this._totalEstimates++;\n      }\n    }\n\n    return hasChangedHeight;\n  }\n\n  /** Called when a page has been added to the DOM. */\n  private _onPageAdded(page: IPage<T>): void {\n    const { onPageAdded } = this.props;\n\n    // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  }\n\n  /** Called when a page has been removed from the DOM. */\n  private _onPageRemoved(page: IPage<T>): void {\n    const { onPageRemoved } = this.props;\n\n    // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  }\n\n  /** Build up the pages that should be rendered. */\n  private _buildPages(props: IListProps<T>, state: IListState<T>): IListState<T> {\n    let { renderCount } = props;\n    const { items, startIndex, getPageHeight } = props;\n\n    renderCount = this._getRenderCount(props);\n\n    const materializedRect = { ...EMPTY_RECT };\n    const pages: IPage<T>[] = [];\n\n    let itemsPerPage = 1;\n    let pageTop = 0;\n    let currentSpacer = null;\n    const focusedIndex = this._focusedIndex;\n    const endIndex = startIndex! + renderCount;\n    const shouldVirtualize = this._shouldVirtualize(props);\n\n    // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n    const isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\n\n    const allowedRect = this._allowedRect;\n\n    for (let itemIndex = startIndex!; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      const pageSpecification = this._getPageSpecification(props, itemIndex, allowedRect);\n      const pageHeight = pageSpecification.height;\n      const pageData = pageSpecification.data;\n      const key = pageSpecification.key;\n\n      itemsPerPage = pageSpecification.itemCount;\n\n      const pageBottom = pageTop + pageHeight - 1;\n\n      const isPageRendered =\n        findIndex(state.pages as IPage<T>[], (page: IPage<T>) => !!page.items && page.startIndex === itemIndex) > -1;\n      const isPageInAllowedRange = !allowedRect || (pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom!);\n      const isPageInRequiredRange =\n        !this._requiredRect || (pageBottom >= this._requiredRect.top && pageTop <= this._requiredRect.bottom!);\n\n      const isPageVisible =\n        (!isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered))) || !shouldVirtualize;\n      const isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\n      const isFirstPage = itemIndex === startIndex;\n\n      // Only render whats visible, focused, or first page,\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n\n        const itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n        const newPage = this._createPage(\n          key,\n          items!.slice(itemIndex, itemIndex + itemsInPage),\n          itemIndex,\n          undefined,\n          undefined,\n          pageData,\n        );\n\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n        if (this._visibleRect && this._visibleRect.bottom) {\n          newPage.isVisible = pageBottom >= this._visibleRect.top && pageTop <= this._visibleRect.bottom;\n        }\n\n        pages.push(newPage);\n\n        if (isPageInRequiredRange && this._allowedRect) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: allowedRect.left,\n            right: allowedRect.right,\n            width: allowedRect.width,\n          });\n        }\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this._createPage(\n            SPACER_KEY_PREFIX + itemIndex,\n            undefined,\n            itemIndex,\n            0,\n            undefined,\n            pageData,\n            true /*isSpacer*/,\n          );\n        }\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n      pageTop += pageBottom - pageTop + 1;\n\n      // in virtualized mode, we render need to render first page then break and measure,\n      // otherwise, we render all items without measurement to make rendering fast\n      if (isFirstRender && shouldVirtualize) {\n        break;\n      }\n    }\n\n    if (currentSpacer) {\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\n      pages.push(currentSpacer);\n    }\n\n    this._materializedRect = materializedRect;\n\n    // console.log('materialized: ', materializedRect);\n    return {\n      ...state,\n      pages,\n      measureVersion: this._measureVersion,\n    };\n  }\n\n  private _getPageSpecification(\n    props: IListProps,\n    itemIndex: number,\n    visibleRect: IRectangle,\n  ): {\n    // These return values are now no longer optional.\n    itemCount: number;\n    height: number;\n    data?: any;\n    key?: string;\n  } {\n    const { getPageSpecification } = props;\n\n    if (getPageSpecification) {\n      const pageData = getPageSpecification(itemIndex, visibleRect, props.items);\n\n      const { itemCount = this._getItemCountForPage(itemIndex, visibleRect) } = pageData;\n\n      const { height = this._getPageHeight(itemIndex, visibleRect, itemCount) } = pageData;\n\n      return {\n        itemCount,\n        height,\n        data: pageData.data,\n        key: pageData.key,\n      };\n    } else {\n      const itemCount = this._getItemCountForPage(itemIndex, visibleRect);\n\n      return {\n        itemCount,\n        height: this._getPageHeight(itemIndex, visibleRect, itemCount),\n      };\n    }\n  }\n\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n  private _getPageHeight(itemIndex: number, visibleRect: IRectangle, itemsPerPage: number): number {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage, this.props.items);\n    } else {\n      const cachedHeight = this._cachedPageHeights[itemIndex];\n\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\n    }\n  }\n\n  private _getItemCountForPage(itemIndex: number, visibileRect: IRectangle): number {\n    const itemsPerPage = this.props.getItemCountForPage\n      ? this.props.getItemCountForPage(itemIndex, visibileRect)\n      : DEFAULT_ITEMS_PER_PAGE;\n\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  }\n\n  private _createPage(\n    pageKey: string | undefined,\n    items: any[] | undefined,\n    startIndex: number = -1,\n    count: number = items ? items.length : 0,\n    style: React.CSSProperties = {},\n    data?: any,\n    isSpacer?: boolean,\n  ): IPage<T> {\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\n    const cachedPage = this._pageCache[pageKey];\n    if (cachedPage && cachedPage.page) {\n      return cachedPage.page;\n    }\n\n    return {\n      key: pageKey,\n      startIndex,\n      itemCount: count,\n      items,\n      style,\n      top: 0,\n      height: 0,\n      data,\n      isSpacer: isSpacer || false,\n    };\n  }\n\n  private _getRenderCount(props?: IListProps<T>): number {\n    const { items, startIndex, renderCount } = props || this.props;\n\n    return renderCount === undefined ? (items ? items.length - startIndex! : 0) : renderCount;\n  }\n\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n  private _updateRenderRects(props: IListProps<T>, state: IListState<T>, forceUpdate?: boolean): void {\n    const { renderedWindowsAhead, renderedWindowsBehind } = props;\n    const { pages } = state;\n    // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\n    if (!this._shouldVirtualize(props)) {\n      return;\n    }\n\n    let surfaceRect = this._surfaceRect || { ...EMPTY_RECT };\n    const scrollHeight = getScrollHeight(this._scrollElement);\n    const scrollTop = getScrollYPosition(this._scrollElement);\n\n    // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    // This needs to be called to recalculate when new pages should be loaded.\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\n    if (\n      this._surface.current &&\n      (forceUpdate ||\n        !pages ||\n        !this._surfaceRect ||\n        !scrollHeight ||\n        scrollHeight !== this._scrollHeight ||\n        Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight * SCROLL_RATIO)\n    ) {\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\n      this._scrollTop = scrollTop;\n    }\n\n    // If the scroll height has changed, something in the container likely resized and\n    // we should redo the page heights incase their content resized.\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\n      this._measureVersion++;\n    }\n\n    this._scrollHeight = scrollHeight || 0;\n\n    // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n    const visibleTop = Math.max(0, -surfaceRect.top);\n    const win = getWindow(this._root.current);\n    const visibleRect = {\n      top: visibleTop,\n      left: surfaceRect.left,\n      bottom: visibleTop + win!.innerHeight,\n      right: surfaceRect.right,\n      width: surfaceRect.width,\n      height: win!.innerHeight,\n    };\n\n    // The required/allowed rects are adjusted versions of the visible rect.\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind!, renderedWindowsAhead!);\n\n    // store the visible rect for later use.\n    this._visibleRect = visibleRect;\n  }\n}\n\nfunction _expandRect(rect: IRectangle, pagesBefore: number, pagesAfter: number): IRectangle {\n  const top = rect.top - pagesBefore * rect.height;\n  const height = rect.height + (pagesBefore + pagesAfter) * rect.height;\n\n  return {\n    top,\n    bottom: top + height,\n    height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width,\n  };\n}\n\nfunction _isContainedWithin(innerRect: IRectangle, outerRect: IRectangle): boolean {\n  return (\n    innerRect.top >= outerRect.top &&\n    innerRect.left >= outerRect.left &&\n    innerRect.bottom! <= outerRect.bottom! &&\n    innerRect.right! <= outerRect.right!\n  );\n}\n\nfunction _mergeRect(targetRect: IRectangle, newRect: IRectangle): IRectangle {\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\n  targetRect.bottom =\n    newRect.bottom! > targetRect.bottom! || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\n  targetRect.right = newRect.right! > targetRect.right! || targetRect.right === -1 ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right! - targetRect.left + 1;\n  targetRect.height = targetRect.bottom! - targetRect.top + 1;\n\n  return targetRect;\n}\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SACEC,KAAK,EACLC,UAAU,EACVC,SAAS,EACTC,GAAG,EACHC,aAAa,EACbC,SAAS,EACTC,oBAAoB,EACpBC,cAAc,EACdC,SAAS,EACTC,SAAS,EACTC,sBAAsB,QACjB,iBAAiB;AACxB,SAASC,YAAY,QAAQ,cAAc;AAC3C,SAASC,qBAAqB,QAAQ,iBAAiB;AACvD,SAASC,eAAe,EAAEC,kBAAkB,EAAEC,kBAAkB,QAAQ,gBAAgB;AAUxF,SAASC,aAAa,QAAQ,iCAAiC;AAC/D,SAASC,WAAW,QAAQ,qBAAqB;AACjD;AAEA,IAAMC,YAAY,GAAG,EAAE;AACvB,IAAMC,uBAAuB,GAAG,GAAG;AACnC,IAAMC,uBAAuB,GAAG,GAAG;AACnC,IAAMC,mBAAmB,GAAG,GAAG;AAC/B;AACA,IAAMC,mBAAmB,GAAG,GAAG;AAC/B,IAAMC,sBAAsB,GAAG,EAAE;AACjC,IAAMC,mBAAmB,GAAG,EAAE;AAC9B,IAAMC,+BAA+B,GAAG,CAAC;AACzC,IAAMC,8BAA8B,GAAG,CAAC;AACxC,IAAMC,eAAe,GAAG,OAAO;AAC/B,IAAMC,iBAAiB,GAAG,SAAS;AACnC;AACA,IAAMC,YAAY,GAAG,CAAC,GAAG,CAAC;AAuB1B,IAAMC,UAAU,GAAG;EACjBC,GAAG,EAAE,CAAC,CAAC;EACPC,MAAM,EAAE,CAAC,CAAC;EACVC,IAAI,EAAE,CAAC,CAAC;EACRC,KAAK,EAAE,CAAC,CAAC;EACTC,KAAK,EAAE,CAAC;EACRC,MAAM,EAAE;CACT;AAED;AACA,IAAMC,gBAAgB,GAAG,SAAAA,CAACC,OAAoB;EAAK,OAAAA,OAAO,CAACC,qBAAqB,EAAE;AAA/B,CAA+B;AAClF,IAAMC,mBAAmB,GAAGH,gBAAgB;AAC5C,IAAMI,kBAAkB,GAAGJ,gBAAgB;AAE3C;;;;;;;;;;;;;;;;;;;;;;;AAuBA,IAAAK,IAAA,0BAAAC,MAAA;EAAmCC,SAAA,CAAAF,IAAA,EAAAC,MAAA;EAiEjC,SAAAD,KAAYG,KAAoB;IAAhC,IAAAC,KAAA,GACEH,MAAA,CAAAI,IAAA,OAAMF,KAAK,CAAC;IAvDNC,KAAA,CAAAE,KAAK,GAAGjD,KAAK,CAACkD,SAAS,EAAkB;IACzCH,KAAA,CAAAI,QAAQ,GAAGnD,KAAK,CAACkD,SAAS,EAAkB;IAC5CH,KAAA,CAAAK,SAAS,GAA4B,EAAE;IA+ZvCL,KAAA,CAAAM,yBAAyB,GAAG,UAACC,SAAwB,EAAEC,aAA4B;MACzF,IACED,SAAS,CAACE,KAAK,KAAKT,KAAI,CAACD,KAAK,CAACU,KAAK,IACpCF,SAAS,CAACG,WAAW,KAAKV,KAAI,CAACD,KAAK,CAACW,WAAW,IAChDH,SAAS,CAACI,UAAU,KAAKX,KAAI,CAACD,KAAK,CAACY,UAAU,IAC9CJ,SAAS,CAACK,OAAO,KAAKZ,KAAI,CAACD,KAAK,CAACa,OAAO,IACvC,CAACJ,aAAa,CAACK,UAAU,IAAIb,KAAI,CAACD,KAAK,CAACe,WAAW,IAAI1D,SAAS,EAAG,EACpE;QACA;QACA;QACA4C,KAAI,CAACe,qBAAqB,EAAE;QAC5Bf,KAAI,CAACgB,aAAa,GAAG,IAAI;QAEzBhB,KAAI,CAACiB,eAAe,EAAE;QACtBjB,KAAI,CAACkB,oBAAoB,EAAE;QAE3B,OAAOlB,KAAI,CAACmB,YAAY,CAACZ,SAAS,EAAEC,aAAa,CAAC;;MAGpD,OAAOA,aAAa;IACtB,CAAC;IAwDOR,KAAA,CAAAoB,aAAa,GAAG,UAACrB,KAAgC;MAC/C,IAAAsB,OAAO,GAA+BtB,KAAK,CAAAsB,OAApC;QAAEC,cAAc,GAAevB,KAAK,CAAAuB,cAApB;QAAEC,QAAQ,GAAKxB,KAAK,CAAAwB,QAAV;MAEzC,OACEtE,KAAA,CAAAuE,aAAA,QAAAC,QAAA;QAAKC,GAAG,EAAEL;MAAO,GAAME,QAAQ,GAC5BD,cAAc,CACX;IAEV,CAAC;IAEOtB,KAAA,CAAA2B,gBAAgB,GAAG,UAAC5B,KAAmC;MACrD,IAAA6B,UAAU,GAA6B7B,KAAK,CAAA6B,UAAlC;QAAEC,YAAY,GAAe9B,KAAK,CAAA8B,YAApB;QAAEN,QAAQ,GAAKxB,KAAK,CAAAwB,QAAV;MAE1C,OACEtE,KAAA,CAAAuE,aAAA,QAAAC,QAAA;QAAKC,GAAG,EAAEE;MAAU,GAAML,QAAQ,GAC/BM,YAAY,CACT;IAEV,CAAC;IAgBO7B,KAAA,CAAA8B,aAAa,GAAG,UAACC,SAAwB,EAAEC,aAA8C;;MACzF,IAAAC,EAAA,GAAkDjC,KAAI,CAACD,KAAK;QAA1DmC,YAAY,GAAAD,EAAA,CAAAC,YAAA;QAAEC,uBAAuB,GAAAF,EAAA,CAAAE,uBAAA;QAAEC,IAAI,GAAAH,EAAA,CAAAG,IAAe;MAGhE,IAAAC,EAAA,GAEEN,SAAS,CAAAO,IAFqB;QAAxBC,EAAA,GAAAF,EAAA,CAAA5B,KAAU;QAAVA,KAAK,GAAA8B,EAAA,cAAG,EAAE,GAAAA,EAAA;QAAE5B,UAAU,GAAA0B,EAAA,CAAA1B,UAAA;QAC3BY,QAAQ,GAAAiB,MAAA,CACTT,SAAS,EAHP,QAGL,CADY;MAGb;MACA,IAAMU,QAAQ,GAAGL,IAAI,KAAKM,SAAS,GAAG,UAAU,GAAG,cAAc;MACjE,IAAMC,KAAK,GAAsB,EAAE;MAEnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnC,KAAK,CAACoC,MAAM,EAAED,CAAC,EAAE,EAAE;QACrC,IAAME,KAAK,GAAGnC,UAAU,GAAGiC,CAAC;QAC5B,IAAMG,IAAI,GAAGtC,KAAK,CAACmC,CAAC,CAAC;QAErB,IAAII,OAAO,GAAGhD,KAAI,CAACD,KAAK,CAACkD,MAAM,GAAGjD,KAAI,CAACD,KAAK,CAACkD,MAAM,CAACF,IAAI,EAAED,KAAK,CAAC,GAAGC,IAAI,IAAKA,IAAY,CAACG,GAAG;QAE5F,IAAIF,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAKN,SAAS,EAAE;UAC7CM,OAAO,GAAGF,KAAK;;QAGjB,IAAMK,UAAU,GAAGhB,uBAAuB,aAAvBA,uBAAuB,cAAvBA,uBAAuB,GAAID,YAAY;QAE1D,IAAMkB,IAAI,GACR,CAAAC,EAAA,GAAAF,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAGJ,IAAI,EAAED,KAAK,EAAE,CAAC9C,KAAI,CAACD,KAAK,CAACuD,oBAAoB,GAAGtD,KAAI,CAACuD,KAAK,CAACC,WAAW,GAAGd,SAAS,CAAC,cAAAW,EAAA,cAAAA,EAAA,GAAI,IAAI;QAE1G,IAAI,CAAClB,uBAAuB,IAAIiB,IAAI,EAAE;UACpCT,KAAK,CAACc,IAAI,CACRxG,KAAA,CAAAuE,aAAA;YACEY,IAAI,EAAEK,QAAQ;YACdiB,SAAS,EAAE,cAAc;YACzBR,GAAG,EAAEF,OAAO;YAAA,mBACKF,KAAK;YAAA,qBACJ;UAAU,GAE3BM,IAAI,CACD,CACP;;;MAIL,OAAOnG,KAAA,CAAAuE,aAAA,QAAAC,QAAA,KAASF,QAAQ,GAAGoB,KAAK,CAAO;IACzC,CAAC;IAjgBC/E,sBAAsB,CAACoC,KAAI,CAAC;IAE5BA,KAAI,CAACuD,KAAK,GAAG;MACXI,KAAK,EAAE,EAAE;MACTH,WAAW,EAAE,KAAK;MAClBI,wBAAwB,EAAE5D,KAAI,CAACM,yBAAyB;MACxDO,UAAU,EAAE;KACb;IAEDb,KAAI,CAAC6D,oBAAoB,GAAG,CAAC;IAC7B7D,KAAI,CAAC8D,eAAe,GAAG,CAAC;IACxB9D,KAAI,CAAC+D,qBAAqB,GAAG,CAAC;IAC9B/D,KAAI,CAACgE,sBAAsB,GAAG,CAAC;IAE/B;IACAhE,KAAI,CAACiB,eAAe,GAAG,CAAC;IAExBjB,KAAI,CAACiE,kBAAkB,GAAG,EAAE;IAC5BjE,KAAI,CAAC6D,oBAAoB,GAAG,CAAC;IAC7B7D,KAAI,CAACkE,aAAa,GAAG,CAAC,CAAC;IACvBlE,KAAI,CAACmE,UAAU,GAAG,EAAE;;EACtB;EAlCA;EACA;EAEcvE,IAAA,CAAAgE,wBAAwB,GAAtC,UACErD,SAAwB,EACxBC,aAA4B;IAE5B,OAAOA,aAAa,CAACoD,wBAAwB,CAACrD,SAAS,EAAEC,aAAa,CAAC;EACzE,CAAC;EA4BD4D,MAAA,CAAAC,cAAA,CAAWzE,IAAA,CAAA0E,SAAA,YAAQ;SAAnB,SAAAC,CAAA;MACE,OAAO,IAAI,CAAClE,SAAS;IACvB,CAAC;;;;EAED;;;;;;;;;;;EAWOT,IAAA,CAAA0E,SAAA,CAAAE,aAAa,GAApB,UACE1B,KAAa,EACb2B,WAA2C,EAC3CC,YAA8C;IAA9C,IAAAA,YAAA;MAAAA,YAAA,GAA6B7G,YAAY,CAAC8G,IAAI;IAAA;IAE9C,IAAMhE,UAAU,GAAG,IAAI,CAACZ,KAAK,CAACY,UAAoB;IAClD,IAAMD,WAAW,GAAG,IAAI,CAACkE,eAAe,EAAE;IAC1C,IAAMC,QAAQ,GAAGlE,UAAU,GAAGD,WAAW;IAEzC,IAAMoE,WAAW,GAAG,IAAI,CAACC,YAAY;IAErC,IAAIC,SAAS,GAAG,CAAC;IAEjB,IAAIC,YAAY,GAAG,CAAC;IACpB,KAAK,IAAIC,SAAS,GAAGvE,UAAU,EAAEuE,SAAS,GAAGL,QAAQ,EAAEK,SAAS,IAAID,YAAY,EAAE;MAChF,IAAME,iBAAiB,GAAG,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAACrF,KAAK,EAAEmF,SAAS,EAAEJ,WAAW,CAAC;MAExF,IAAMO,UAAU,GAAGF,iBAAiB,CAAC7F,MAAM;MAC3C2F,YAAY,GAAGE,iBAAiB,CAACG,SAAS;MAE1C,IAAMC,sBAAsB,GAAGL,SAAS,IAAIpC,KAAK,IAAIoC,SAAS,GAAGD,YAAY,GAAGnC,KAAK;MACrF,IAAIyC,sBAAsB,EAAE;QAC1B;QACA;QACA,IAAId,WAAW,IAAI,IAAI,CAACe,cAAc,EAAE;UACtC,IAAMC,UAAU,GAAG9F,kBAAkB,CAAC,IAAI,CAAC6F,cAAc,CAAC;UAC1D,IAAME,cAAc,GAAG1H,kBAAkB,CAAC,IAAI,CAACwH,cAAc,CAAC;UAC9D,IAAMG,YAAY,GAAG;YACnB1G,GAAG,EAAEyG,cAAc;YACnBxG,MAAM,EAAEwG,cAAc,GAAGD,UAAU,CAACnG;WACrC;UAED;UACA,IAAMsG,sBAAsB,GAAG9C,KAAK,GAAGoC,SAAS;UAChD,KAAK,IAAIW,eAAe,GAAG,CAAC,EAAEA,eAAe,GAAGD,sBAAsB,EAAE,EAAEC,eAAe,EAAE;YACzFb,SAAS,IAAIP,WAAW,CAACS,SAAS,GAAGW,eAAe,CAAC;;UAEvD,IAAMC,YAAY,GAAGd,SAAS,GAAGP,WAAW,CAAC3B,KAAK,CAAC;UAEnD;UACA;UACA,QAAQ4B,YAAY;YAClB,KAAK7G,YAAY,CAACoB,GAAG;cACnBhB,kBAAkB,CAAC,IAAI,CAACuH,cAAc,EAAER,SAAS,CAAC;cAClD;YACF,KAAKnH,YAAY,CAACqB,MAAM;cACtBjB,kBAAkB,CAAC,IAAI,CAACuH,cAAc,EAAEM,YAAY,GAAGL,UAAU,CAACnG,MAAM,CAAC;cACzE;YACF,KAAKzB,YAAY,CAACkI,MAAM;cACtB9H,kBAAkB,CAAC,IAAI,CAACuH,cAAc,EAAE,CAACR,SAAS,GAAGc,YAAY,GAAGL,UAAU,CAACnG,MAAM,IAAI,CAAC,CAAC;cAC3F;YACF,KAAKzB,YAAY,CAAC8G,IAAI;YACtB;cACE;;UAGJ,IAAMqB,kBAAkB,GAAGhB,SAAS,IAAIW,YAAY,CAAC1G,GAAG,IAAI6G,YAAY,IAAIH,YAAY,CAACzG,MAAM;UAC/F,IAAI8G,kBAAkB,EAAE;YACtB;YACA;;UAGF,IAAMC,oBAAoB,GAAGjB,SAAS,GAAGW,YAAY,CAAC1G,GAAG;UACzD,IAAMiH,oBAAoB,GAAGJ,YAAY,GAAGH,YAAY,CAACzG,MAAM;UAE/D,IAAI+G,oBAAoB,EAAE;YACxB;YACA;YACA;YACA;YACA;YACA;YACA;UAAA,CACD,MAAM,IAAIC,oBAAoB,EAAE;YAC/B;YACA;YACA;YACA;YACA;YACA;YACA;YACAlB,SAAS,GAAGc,YAAY,GAAGL,UAAU,CAACnG,MAAM;;;QAIhD,IAAI,IAAI,CAACkG,cAAc,EAAE;UACvBvH,kBAAkB,CAAC,IAAI,CAACuH,cAAc,EAAER,SAAS,CAAC;;QAEpD;;MAGFA,SAAS,IAAIK,UAAU;;EAE3B,CAAC;EAEMzF,IAAA,CAAA0E,SAAA,CAAA6B,uBAAuB,GAA9B,UAA+B1B,WAA2C;IACxE,IAAMd,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACI,KAAK,IAAI,EAAE;IACpC,KAAmB,IAAAyC,EAAA,IAAK,EAALC,OAAA,GAAA1C,KAAK,EAALyC,EAAA,GAAAC,OAAA,CAAAxD,MAAK,EAALuD,EAAA,EAAK,EAAE;MAArB,IAAM9D,IAAI,GAAA+D,OAAA,CAAAD,EAAA;MACb,IAAME,aAAa,GACjB,CAAChE,IAAI,CAACiE,QAAQ,IAAI,CAAC,IAAI,CAACC,UAAU,IAAI,CAAC,KAAKlE,IAAI,CAACrD,GAAG,IAAI,CAAC,IAAI,CAACuH,UAAU,IAAI,CAAC,KAAKlE,IAAI,CAACrD,GAAG,GAAGqD,IAAI,CAAChD,MAAM;MAC1G,IAAIgH,aAAa,EAAE;QACjB,IAAI,CAAC7B,WAAW,EAAE;UAChB,IAAMgC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACrE,IAAI,CAAChD,MAAM,GAAGgD,IAAI,CAACgD,SAAS,CAAC;UAC1D,OAAOhD,IAAI,CAAC3B,UAAU,GAAG+F,IAAI,CAACC,KAAK,CAAC,CAAC,IAAI,CAACH,UAAU,GAAGlE,IAAI,CAACrD,GAAG,IAAIwH,SAAS,CAAC;SAC9E,MAAM;UACL,IAAIG,cAAc,GAAG,CAAC;UACtB,KAAK,IAAI1B,SAAS,GAAG5C,IAAI,CAAC3B,UAAU,EAAEuE,SAAS,GAAG5C,IAAI,CAAC3B,UAAU,GAAG2B,IAAI,CAACgD,SAAS,EAAEJ,SAAS,EAAE,EAAE;YAC/F,IAAMuB,SAAS,GAAGhC,WAAW,CAACS,SAAS,CAAC;YACxC,IACE5C,IAAI,CAACrD,GAAG,GAAG2H,cAAc,IAAI,IAAI,CAACJ,UAAU,IAC5C,IAAI,CAACA,UAAU,GAAGlE,IAAI,CAACrD,GAAG,GAAG2H,cAAc,GAAGH,SAAS,EACvD;cACA,OAAOvB,SAAS;aACjB,MAAM;cACL0B,cAAc,IAAIH,SAAS;;;;;;IAMrC,OAAO,CAAC;EACV,CAAC;EAEM7G,IAAA,CAAA0E,SAAA,CAAAuC,iBAAiB,GAAxB;IACE,IAAI,CAACC,MAAM,GAAG,IAAI5J,KAAK,CAAC,IAAI,CAAC;IAC7B,IAAI,CAAC6J,OAAO,GAAG,IAAI5J,UAAU,CAAC,IAAI,CAAC;IAEnC;IACA,IAAI,CAAC6J,uBAAuB,GAAG,IAAI,CAACF,MAAM,CAACG,QAAQ,CAAC,IAAI,CAACC,cAAc,EAAE7I,uBAAuB,EAAE;MAChG8I,OAAO,EAAE,KAAK;MACdC,OAAO,EAAE9I;KACV,CAAC;IAEF,IAAI,CAAC+I,qBAAqB,GAAG,IAAI,CAACP,MAAM,CAACG,QAAQ,CAAC,IAAI,CAACK,YAAY,EAAE/I,mBAAmB,EAAE;MACxF4I,OAAO,EAAE;KACV,CAAC;IAEF,IAAI,CAACI,uBAAuB,GAAG,IAAI,CAACT,MAAM,CAACG,QAAQ,CAAC,IAAI,CAACO,cAAc,EAAEpJ,YAAY,EAAE;MACrF+I,OAAO,EAAE;KACV,CAAC;IAEF,IAAI,CAACM,yBAAyB,GAAG,IAAI,CAACX,MAAM,CAACG,QAAQ,CAAC,IAAI,CAACS,gBAAgB,EAAElJ,mBAAmB,EAAE;MAChG2I,OAAO,EAAE;KACV,CAAC;IAEF,IAAI,CAAC3B,cAAc,GAAGhI,oBAAoB,CAAC,IAAI,CAAC0C,KAAK,CAACyH,OAAO,CAAgB;IAC7E,IAAI,CAACnB,UAAU,GAAG,CAAC;IACnB,IAAI,CAACoB,QAAQ,CAAAnG,QAAA,CAAAA,QAAA,KAAM,IAAI,CAACN,YAAY,CAAC,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACwD,KAAK,CAAC;MAAE1C,UAAU,EAAE;IAAI,GAAG;IACjF,IAAI,CAACI,eAAe,EAAE;IAEtB,IAAM4G,GAAG,GAAG1J,WAAW,CAAC,IAAI,CAAC2J,OAAO,CAAC;IAErC,IAAI,CAACf,OAAO,CAACgB,EAAE,CAACF,GAAG,EAAE,QAAQ,EAAE,IAAI,CAACN,uBAAuB,CAAC;IAC5D,IAAI,IAAI,CAACrH,KAAK,CAACyH,OAAO,EAAE;MACtB,IAAI,CAACZ,OAAO,CAACgB,EAAE,CAAC,IAAI,CAAC7H,KAAK,CAACyH,OAAO,EAAE,OAAO,EAAE,IAAI,CAACK,QAAQ,EAAE,IAAI,CAAC;;IAEnE,IAAI,IAAI,CAACxC,cAAc,EAAE;MACvB,IAAI,CAACuB,OAAO,CAACgB,EAAE,CAAC,IAAI,CAACvC,cAAc,EAAE,QAAQ,EAAE,IAAI,CAACyC,SAAS,CAAC;MAC9D,IAAI,CAAClB,OAAO,CAACgB,EAAE,CAAC,IAAI,CAACvC,cAAc,EAAE,QAAQ,EAAE,IAAI,CAACwB,uBAAuB,CAAC;;IAG9E;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACF,CAAC;EAEMpH,IAAA,CAAA0E,SAAA,CAAA4D,kBAAkB,GAAzB,UAA0BC,aAAyB,EAAE3H,aAA4B;IAC/E;IACA;IACA,IAAM4H,UAAU,GAAG,IAAI,CAACrI,KAAK;IAC7B,IAAMsI,UAAU,GAAG,IAAI,CAAC9E,KAAK;IAE7B,IAAI,IAAI,CAACA,KAAK,CAAC+E,YAAY,KAAK9H,aAAa,CAAC8H,YAAY,EAAE;MAC1D;MACA,IAAI,CAACF,UAAU,CAACG,aAAa,EAAE;QAC7B;QACA,IAAMC,cAAc,GAAG,IAAI,CAACC,uBAAuB,CAACJ,UAAU,CAAC1E,KAAM,CAAC;QAEtE;QACA,IAAI6E,cAAc,EAAE;UAClB,IAAI,CAACE,iBAAiB,GAAG,IAAI;UAC7B,IAAI,CAAC,IAAI,CAACC,wBAAwB,EAAE;YAClC,IAAI,CAACA,wBAAwB,GAAG,IAAI;YACpC,IAAI,CAACf,QAAQ,CAAC,IAAI,CAACzG,YAAY,CAACiH,UAAU,EAAEC,UAAU,CAAC,CAAC;WACzD,MAAM;YACL,IAAI,CAACrB,uBAAuB,EAAE;;SAEjC,MAAM;UACL;UACA,IAAI,CAACK,qBAAqB,EAAE;;OAE/B,MAAM;QACL;QACA,IAAI,CAACA,qBAAqB,EAAE;;MAG9B;MACA,IAAIe,UAAU,CAACQ,cAAc,EAAE;QAC7BR,UAAU,CAACQ,cAAc,CAACP,UAAU,CAAC1E,KAAmB,CAAC;;;EAG/D,CAAC;EAEM/D,IAAA,CAAA0E,SAAA,CAAAuE,oBAAoB,GAA3B;;IACE,CAAAxF,EAAA,OAAI,CAACyD,MAAM,cAAAzD,EAAA,uBAAAA,EAAA,CAAEyF,OAAO,EAAE;IACtB,CAAA7G,EAAA,OAAI,CAAC8E,OAAO,cAAA9E,EAAA,uBAAAA,EAAA,CAAE6G,OAAO,EAAE;IAEvB,OAAO,IAAI,CAACtD,cAAc;IAE1B;IACA;IACA;IACA;IACA;EACF,CAAC;EAEM5F,IAAA,CAAA0E,SAAA,CAAAyE,qBAAqB,GAA5B,UAA6BC,QAAuB,EAAEC,QAAuB;IACnE,IAAOC,QAAQ,GAAK,IAAI,CAAC3F,KAAK,CAAAI,KAAf;IACf,IAAOwF,QAAQ,GAAKF,QAAQ,CAAAtF,KAAb;IACvB,IAAIoF,qBAAqB,GAAG,KAAK;IAEjC;IACA,IAAI,CAACE,QAAQ,CAACzF,WAAW,IAAI,IAAI,CAACD,KAAK,CAACC,WAAW,EAAE;MACnD,OAAO,IAAI;;IAGb,IAAIwF,QAAQ,CAACpI,OAAO,KAAK,IAAI,CAACb,KAAK,CAACa,OAAO,EAAE;MAC3C,OAAO,IAAI;;IAGb,IAAIoI,QAAQ,CAACtF,SAAS,KAAK,IAAI,CAAC3D,KAAK,CAAC2D,SAAS,EAAE;MAC/C,OAAO,IAAI;;IAGb,IAAIsF,QAAQ,CAACvI,KAAK,KAAK,IAAI,CAACV,KAAK,CAACU,KAAK,IAAIyI,QAAS,CAACrG,MAAM,KAAKsG,QAAS,CAACtG,MAAM,EAAE;MAChF,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsG,QAAS,CAACrG,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC,IAAMwG,OAAO,GAAGF,QAAS,CAACtG,CAAC,CAAC;QAC5B,IAAMyG,OAAO,GAAGF,QAAS,CAACvG,CAAC,CAAC;QAE5B,IAAIwG,OAAO,CAAClG,GAAG,KAAKmG,OAAO,CAACnG,GAAG,IAAIkG,OAAO,CAAC9D,SAAS,KAAK+D,OAAO,CAAC/D,SAAS,EAAE;UAC1EyD,qBAAqB,GAAG,IAAI;UAC5B;;;KAGL,MAAM;MACLA,qBAAqB,GAAG,IAAI;;IAG9B,OAAOA,qBAAqB;EAC9B,CAAC;EAEMnJ,IAAA,CAAA0E,SAAA,CAAAgF,WAAW,GAAlB;IACE,IAAI,CAACpI,oBAAoB,EAAE;IAC3B;IACA,IAAI,CAACqI,kBAAkB,CAAC,IAAI,CAACxJ,KAAK,EAAE,IAAI,CAACwD,KAAK,EAAE,IAAI,CAAC;IACrD,IAAI,CAACqE,QAAQ,CAAC,IAAI,CAACzG,YAAY,CAAC,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACwD,KAAK,CAAC,CAAC;IACxD,IAAI,CAACtC,eAAe,EAAE;IAEtBpB,MAAA,CAAAyE,SAAA,CAAMgF,WAAW,CAAArJ,IAAA,MAAE;EACrB,CAAC;EAED;;;EAGOL,IAAA,CAAA0E,SAAA,CAAAkF,kBAAkB,GAAzB;IACE,OAAO,IAAI,CAACC,YAAa,CAACnK,MAAM;EAClC,CAAC;EAEMM,IAAA,CAAA0E,SAAA,CAAAoF,MAAM,GAAb;IACQ,IAAArG,EAAA,GAA8D,IAAI,CAACtD,KAAK;MAAtE2D,SAAS,GAAAL,EAAA,CAAAK,SAAA;MAAEzB,EAAA,GAAAoB,EAAA,CAAAjB,IAAa;MAAbA,IAAI,GAAAH,EAAA,cAAG,MAAM,GAAAA,EAAA;MAAE0H,eAAe,GAAAtG,EAAA,CAAAsG,eAAA;MAAEC,YAAY,GAAAvG,EAAA,CAAAuG,YAAe;IACtE,IAAAvH,EAAA,GAAe,IAAI,CAACkB,KAAK,CAAAI,KAAf;MAAVA,KAAK,GAAAtB,EAAA,cAAG,EAAE,GAAAA,EAAA;IAClB,IAAMR,YAAY,GAAkB,EAAE;IACtC,IAAMN,QAAQ,GAAG9D,cAAc,CAAuC,IAAI,CAACsC,KAAK,EAAEzC,aAAa,CAAC;IAEhG,KAAmB,IAAA8I,EAAA,IAAK,EAALyD,OAAA,GAAAlG,KAAK,EAALyC,EAAA,GAAAyD,OAAA,CAAAhH,MAAK,EAALuD,EAAA,EAAK,EAAE;MAArB,IAAM9D,IAAI,GAAAuH,OAAA,CAAAzD,EAAA;MACbvE,YAAY,CAAC4B,IAAI,CAAC,IAAI,CAACqG,WAAW,CAACxH,IAAI,CAAC,CAAC;;IAG3C,IAAMyH,oBAAoB,GAAGJ,eAAe,GACxC7L,qBAAqB,CAAC6L,eAAe,EAAE,IAAI,CAAChI,gBAAgB,CAAC,GAC7D,IAAI,CAACA,gBAAgB;IAEzB,IAAMqI,iBAAiB,GAAGJ,YAAY,GAClC9L,qBAAqB,CAAC8L,YAAY,EAAE,IAAI,CAACxI,aAAa,CAAC,GACvD,IAAI,CAACA,aAAa;IAEtB,OAAO4I,iBAAiB,CAAC;MACvB3I,OAAO,EAAE,IAAI,CAACnB,KAAK;MACnByD,KAAK,EAAAA,KAAA;MACLrC,cAAc,EAAEyI,oBAAoB,CAAC;QACnCnI,UAAU,EAAE,IAAI,CAACxB,QAAQ;QACzBuD,KAAK,EAAAA,KAAA;QACL9B,YAAY,EAAAA,YAAA;QACZN,QAAQ,EAAE;UACRa,IAAI,EAAE,cAAc;UACpBsB,SAAS,EAAE;;OAEd,CAAC;MACFnC,QAAQ,EAAAE,QAAA,CAAAA,QAAA,KACHF,QAAQ;QACXmC,SAAS,EAAErG,GAAG,CAAC,SAAS,EAAEqG,SAAS,CAAC;QACpCtB,IAAI,EAAEP,YAAY,CAACgB,MAAM,GAAG,CAAC,GAAGT,IAAI,GAAGM,SAAS;QAChD,YAAY,EAAEb,YAAY,CAACgB,MAAM,GAAG,CAAC,GAAGtB,QAAQ,CAAC,YAAY,CAAC,GAAGmB;MAAS;KAE7E,CAAC;EACJ,CAAC;EAwBO9C,IAAA,CAAA0E,SAAA,CAAA2F,iBAAiB,GAAzB,UAA0BlK,KAAiC;IAAjC,IAAAA,KAAA;MAAAA,KAAA,GAAuB,IAAI,CAACA,KAAK;IAAA;IACjD,IAAAmK,kBAAkB,GAAKnK,KAAK,CAAAmK,kBAAV;IAC1B,OAAO,CAACA,kBAAkB,IAAIA,kBAAkB,CAACnK,KAAK,CAAC;EACzD,CAAC;EAED;;;EAGQH,IAAA,CAAA0E,SAAA,CAAApD,oBAAoB,GAA5B;IACE,IAAI,CAACiD,UAAU,GAAG,EAAE;EACtB,CAAC;EAEOvE,IAAA,CAAA0E,SAAA,CAAAwF,WAAW,GAAnB,UAAoBxH,IAAc;IAAlC,IAAAtC,KAAA;IACU,IAAAmK,YAAY,GAAK,IAAI,CAACpK,KAAK,CAAAoK,YAAf;IACpB,IAAIC,UAAU;IACd;IACA,IAAID,YAAY,EAAE;MAChBC,UAAU,GAAG,IAAI,CAACjG,UAAU,CAAC7B,IAAI,CAACY,GAAG,CAAC;MACtC,IAAIkH,UAAU,IAAIA,UAAU,CAACC,WAAW,EAAE;QACxC,OAAOD,UAAU,CAACC,WAAW;;;IAIjC,IAAMC,SAAS,GAAG,IAAI,CAACC,aAAa,CAACjI,IAAI,CAAC;IAElC,IAAAe,EAAA,GAAsC,IAAI,CAACtD,KAAK,CAAAyK,YAAf;MAAjCA,YAAY,GAAAnH,EAAA,cAAG,IAAI,CAACvB,aAAa,GAAAuB,EAAA;IAEzC,IAAMgH,WAAW,GAAGG,YAAY,CAC9B;MACElI,IAAI,EAAAA,IAAA;MACJoB,SAAS,EAAE,cAAc;MACzBR,GAAG,EAAEZ,IAAI,CAACY,GAAG;MACbxB,GAAG,EAAE,SAAAA,CAAC+I,MAAe;QACnBzK,KAAI,CAACK,SAAS,CAACiC,IAAI,CAACY,GAAG,CAAC,GAAGuH,MAAM;MACnC,CAAC;MACDC,KAAK,EAAEJ,SAAS;MAChBlI,IAAI,EAAE;KACP,EACD,IAAI,CAACN,aAAa,CACnB;IAED;IACA;IACA;IACA;IACA,IAAIqI,YAAY,IAAI7H,IAAI,CAAC3B,UAAU,KAAK,CAAC,EAAE;MACzC,IAAI,CAACwD,UAAU,CAAC7B,IAAI,CAACY,GAAG,CAAC,GAAG;QAC1BZ,IAAI,EAAAA,IAAA;QACJ+H,WAAW,EAAAA;OACZ;;IAEH,OAAOA,WAAW;EACpB,CAAC;EAsBD;EACQzK,IAAA,CAAA0E,SAAA,CAAAiG,aAAa,GAArB,UAAsBjI,IAAc;IAC1B,IAAAqI,YAAY,GAAK,IAAI,CAAC5K,KAAK,CAAA4K,YAAf;IAEpB,OAAAlJ,QAAA,CAAAA,QAAA,KACMkJ,YAAY,GAAGA,YAAY,CAACrI,IAAI,CAAC,GAAG,EAAG,GACvC,CAACA,IAAI,CAAC7B,KAAK,GACX;MACEnB,MAAM,EAAEgD,IAAI,CAAChD;KACd,GACD,EAAG;EAEX,CAAC;EA+CD;EACQM,IAAA,CAAA0E,SAAA,CAAA0D,QAAQ,GAAhB,UAAiB4C,EAAO;IACtB,IAAIC,MAAM,GAAGD,EAAE,CAACC,MAAqB;IAErC,OAAOA,MAAM,KAAK,IAAI,CAACzK,QAAQ,CAACuH,OAAO,EAAE;MACvC,IAAMmD,WAAW,GAAGD,MAAM,CAACE,YAAY,CAAC,iBAAiB,CAAC;MAE1D,IAAID,WAAW,EAAE;QACf,IAAI,CAAC5G,aAAa,GAAG8G,MAAM,CAACF,WAAW,CAAC;QACxC;;MAGFD,MAAM,GAAGnN,SAAS,CAACmN,MAAM,CAAgB;;EAE7C,CAAC;EAED;;;;EAIQjL,IAAA,CAAA0E,SAAA,CAAA2D,SAAS,GAAjB;IACE,IAAI,CAAC,IAAI,CAAC1E,KAAK,CAACC,WAAW,IAAI,CAAC,IAAI,CAACzD,KAAK,CAACuD,oBAAoB,EAAE;MAC/D,IAAI,CAACsE,QAAQ,CAAC;QAAEpE,WAAW,EAAE;MAAI,CAAE,CAAC;;IAEtC,IAAI,CAACzC,qBAAqB,EAAE;IAC5B,IAAI,CAAC0G,yBAAyB,EAAE;EAClC,CAAC;EAEO7H,IAAA,CAAA0E,SAAA,CAAAvD,qBAAqB,GAA7B;IACE,IAAI,CAACgD,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,sBAAsB,GAAG,CAAC;EACjC,CAAC;EAED;;;EAGQpE,IAAA,CAAA0E,SAAA,CAAA4C,cAAc,GAAtB;IACE,IAAI,CAACqC,kBAAkB,CAAC,IAAI,CAACxJ,KAAK,EAAE,IAAI,CAACwD,KAAK,CAAC;IAE/C;IACA,IAAI,CAAC,IAAI,CAACmF,iBAAiB,IAAI,CAACuC,kBAAkB,CAAC,IAAI,CAACjK,aAA2B,EAAE,IAAI,CAAC0H,iBAAiB,CAAC,EAAE;MAC5G,IAAI,CAACd,QAAQ,CAAC,IAAI,CAACzG,YAAY,CAAC,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACwD,KAAK,CAAC,CAAC;KACzD,MAAM;MACL;IAAA;EAEJ,CAAC;EAED;;;;EAIQ3D,IAAA,CAAA0E,SAAA,CAAAgD,YAAY,GAApB;IACQ,IAAAjE,EAAA,GAAkD,IAAI,CAACtD,KAAK;MAA1DmL,oBAAoB,GAAA7H,EAAA,CAAA6H,oBAAA;MAAEC,qBAAqB,GAAA9H,EAAA,CAAA8H,qBAAe;IAC5D,IAAAlJ,EAAA,GAAiG,IAAI;MAA5EmJ,oBAAoB,GAAAnJ,EAAA,CAAA8B,qBAAA;MAA0BsH,qBAAqB,GAAApJ,EAAA,CAAA+B,sBAAS;IAC3G,IAAMsH,YAAY,GAAG5E,IAAI,CAAC6E,GAAG,CAACL,oBAA8B,EAAEE,oBAAoB,GAAG,CAAC,CAAC;IACvF,IAAMI,aAAa,GAAG9E,IAAI,CAAC6E,GAAG,CAACJ,qBAA+B,EAAEE,qBAAqB,GAAG,CAAC,CAAC;IAE1F,IAAIC,YAAY,KAAKF,oBAAoB,IAAII,aAAa,KAAKH,qBAAqB,EAAE;MACpF;MAEA,IAAI,CAACtH,qBAAqB,GAAGuH,YAAY;MACzC,IAAI,CAACtH,sBAAsB,GAAGwH,aAAa;MAC3C,IAAI,CAACjC,kBAAkB,CAAC,IAAI,CAACxJ,KAAK,EAAE,IAAI,CAACwD,KAAK,CAAC;MAC/C,IAAI,CAACqE,QAAQ,CAAC,IAAI,CAACzG,YAAY,CAAC,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACwD,KAAK,CAAC,CAAC;;IAG1D,IAAI2H,oBAAqB,GAAGI,YAAY,IAAIH,qBAAsB,GAAGK,aAAa,EAAE;MAClF;MACA,IAAI,CAACnE,qBAAqB,EAAE;;EAEhC,CAAC;EAED;;;;EAIQzH,IAAA,CAAA0E,SAAA,CAAAoD,gBAAgB,GAAxB;IACE,IAAI,CAAC,IAAI,CAAC3H,KAAK,CAACuD,oBAAoB,EAAE;MACpC,IAAI,CAACsE,QAAQ,CAAC;QAAEpE,WAAW,EAAE;MAAK,CAAE,CAAC;MACrC,IAAI,CAAC8D,YAAY,EAAE;;EAEvB,CAAC;EAEO1H,IAAA,CAAA0E,SAAA,CAAAkD,cAAc,GAAtB;IACE,IAAI,CAAC8B,WAAW,EAAE;EACpB,CAAC;EAEO1J,IAAA,CAAA0E,SAAA,CAAAnD,YAAY,GAApB,UAAqBZ,SAAwB,EAAEC,aAA4B;IACzE;IAEA,IAAI,CAAC,IAAI,CAACQ,aAAa,EAAE;MACvB,IAAI,CAACuI,kBAAkB,CAAChJ,SAAS,EAAEC,aAAa,CAAC;;IAGnD,IAAMiL,YAAY,GAAG,IAAI,CAACC,WAAW,CAACnL,SAAS,EAAEC,aAAa,CAAC;IAC/D,IAAMmL,YAAY,GAAGnL,aAAa,CAACmD,KAAM;IAEzC,IAAI,CAACiI,kBAAkB,CAACD,YAAY,EAAEF,YAAY,CAAC9H,KAAM,EAAE,IAAI,CAAC5D,KAAK,CAAC;IAEtE,OAAA0B,QAAA,CAAAA,QAAA,CAAAA,QAAA,KACKjB,aAAa,GACbiL,YAAY;MACfnD,YAAY,EAAE;IAAE;EAEpB,CAAC;EAED;;;;;;EAMQ1I,IAAA,CAAA0E,SAAA,CAAAsH,kBAAkB,GAA1B,UAA2B1C,QAAoB,EAAEC,QAAoB,EAAEpJ,KAAoB;IACjF,IAAA8L,WAAW,GAAoB9L,KAAK,CAAA8L,WAAzB;MAAEC,aAAa,GAAK/L,KAAK,CAAA+L,aAAV;IAElC,IAAID,WAAW,IAAIC,aAAa,EAAE;MAChC,IAAMC,eAAe,GAEjB,EAAE;MAEN,KAAmB,IAAA3F,EAAA,IAAQ,EAAR4F,UAAA,GAAA9C,QAAQ,EAAR9C,EAAA,GAAA4F,UAAA,CAAAnJ,MAAQ,EAARuD,EAAA,EAAQ,EAAE;QAAxB,IAAM9D,IAAI,GAAA0J,UAAA,CAAA5F,EAAA;QACb,IAAI9D,IAAI,CAAC7B,KAAK,EAAE;UACdsL,eAAe,CAACzJ,IAAI,CAAC3B,UAAU,CAAC,GAAG2B,IAAI;;;MAI3C,KAAmB,IAAAe,EAAA,IAAQ,EAAR4I,UAAA,GAAA9C,QAAQ,EAAR9F,EAAA,GAAA4I,UAAA,CAAApJ,MAAQ,EAARQ,EAAA,EAAQ,EAAE;QAAxB,IAAMf,IAAI,GAAA2J,UAAA,CAAA5I,EAAA;QACb,IAAIf,IAAI,CAAC7B,KAAK,EAAE;UACd,IAAI,CAACsL,eAAe,CAACzJ,IAAI,CAAC3B,UAAU,CAAC,EAAE;YACrC,IAAI,CAACuL,YAAY,CAAC5J,IAAI,CAAC;WACxB,MAAM;YACL,OAAOyJ,eAAe,CAACzJ,IAAI,CAAC3B,UAAU,CAAC;;;;MAK7C,KAAK,IAAMmC,KAAK,IAAIiJ,eAAe,EAAE;QACnC,IAAIA,eAAe,CAACI,cAAc,CAACrJ,KAAK,CAAC,EAAE;UACzC,IAAI,CAACsJ,cAAc,CAACL,eAAe,CAACjJ,KAAK,CAAC,CAAC;;;;EAInD,CAAC;EAEOlD,IAAA,CAAA0E,SAAA,CAAAmE,uBAAuB,GAA/B,UAAgC9E,KAAiB;IAC/C,IAAI0I,aAAa,GAAG,KAAK;IAEzB;IACA,IAAI,CAAC,IAAI,CAACpC,iBAAiB,EAAE,EAAE;MAC7B,OAAOoC,aAAa;;IAGtB,KAAK,IAAIzJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,KAAK,CAACd,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,IAAMN,IAAI,GAAGqB,KAAK,CAACf,CAAC,CAAC;MAErB,IAAIN,IAAI,CAAC7B,KAAK,EAAE;QACd4L,aAAa,GAAG,IAAI,CAACC,YAAY,CAAChK,IAAI,CAAC,IAAI+J,aAAa;;;IAI5D,OAAOA,aAAa;EACtB,CAAC;EAED;;;;EAIQzM,IAAA,CAAA0E,SAAA,CAAAgI,YAAY,GAApB,UAAqBhK,IAAc;IACjC,IAAIiK,gBAAgB,GAAG,KAAK;IAC5B,IAAMlC,WAAW,GAAG,IAAI,CAAChK,SAAS,CAACiC,IAAI,CAACY,GAAG,CAAgB;IAC3D,IAAMsJ,YAAY,GAAG,IAAI,CAACvI,kBAAkB,CAAC3B,IAAI,CAAC3B,UAAU,CAAC;IAE7D;IAEA,IACE0J,WAAW,IACX,IAAI,CAACJ,iBAAiB,EAAE,KACvB,CAACuC,YAAY,IAAIA,YAAY,CAACC,cAAc,KAAK,IAAI,CAACxL,eAAe,CAAC,EACvE;MACA,IAAMyL,aAAa,GAAG;QACpBrN,KAAK,EAAEgL,WAAW,CAACsC,WAAW;QAC9BrN,MAAM,EAAE+K,WAAW,CAACuC;OACrB;MAED,IAAIF,aAAa,CAACpN,MAAM,IAAIoN,aAAa,CAACrN,KAAK,EAAE;QAC/CkN,gBAAgB,GAAGjK,IAAI,CAAChD,MAAM,KAAKoN,aAAa,CAACpN,MAAM;QAEvD;QAEAgD,IAAI,CAAChD,MAAM,GAAGoN,aAAa,CAACpN,MAAM;QAElC,IAAI,CAAC2E,kBAAkB,CAAC3B,IAAI,CAAC3B,UAAU,CAAC,GAAG;UACzCrB,MAAM,EAAEoN,aAAa,CAACpN,MAAM;UAC5BmN,cAAc,EAAE,IAAI,CAACxL;SACtB;QAED,IAAI,CAAC4C,oBAAoB,GAAG6C,IAAI,CAACmG,KAAK,CACpC,CAAC,IAAI,CAAChJ,oBAAoB,GAAG,IAAI,CAACC,eAAe,GAAG4I,aAAa,CAACpN,MAAM,KAAK,IAAI,CAACwE,eAAe,GAAG,CAAC,CAAC,CACvG;QAED,IAAI,CAACA,eAAe,EAAE;;;IAI1B,OAAOyI,gBAAgB;EACzB,CAAC;EAED;EACQ3M,IAAA,CAAA0E,SAAA,CAAA4H,YAAY,GAApB,UAAqB5J,IAAc;IACzB,IAAAuJ,WAAW,GAAK,IAAI,CAAC9L,KAAK,CAAA8L,WAAf;IAEnB;IAEA,IAAIA,WAAW,EAAE;MACfA,WAAW,CAACvJ,IAAI,CAAC;;EAErB,CAAC;EAED;EACQ1C,IAAA,CAAA0E,SAAA,CAAA8H,cAAc,GAAtB,UAAuB9J,IAAc;IAC3B,IAAAwJ,aAAa,GAAK,IAAI,CAAC/L,KAAK,CAAA+L,aAAf;IAErB;IAEA,IAAIA,aAAa,EAAE;MACjBA,aAAa,CAACxJ,IAAI,CAAC;;EAEvB,CAAC;EAED;EACQ1C,IAAA,CAAA0E,SAAA,CAAAoH,WAAW,GAAnB,UAAoB3L,KAAoB,EAAEwD,KAAoB;IACtD,IAAA7C,WAAW,GAAKX,KAAK,CAAAW,WAAV;IACT,IAAAD,KAAK,GAAgCV,KAAK,CAAAU,KAArC;MAAEE,UAAU,GAAoBZ,KAAK,CAAAY,UAAzB;MAAE4H,aAAa,GAAKxI,KAAK,CAAAwI,aAAV;IAExC7H,WAAW,GAAG,IAAI,CAACkE,eAAe,CAAC7E,KAAK,CAAC;IAEzC,IAAM+M,gBAAgB,GAAArL,QAAA,KAAQzC,UAAU,CAAE;IAC1C,IAAM2E,KAAK,GAAe,EAAE;IAE5B,IAAIsB,YAAY,GAAG,CAAC;IACpB,IAAI8H,OAAO,GAAG,CAAC;IACf,IAAIC,aAAa,GAAG,IAAI;IACxB,IAAMC,YAAY,GAAG,IAAI,CAAC/I,aAAa;IACvC,IAAMW,QAAQ,GAAGlE,UAAW,GAAGD,WAAW;IAC1C,IAAMwM,gBAAgB,GAAG,IAAI,CAACjD,iBAAiB,CAAClK,KAAK,CAAC;IAEtD;IACA;IACA;IACA,IAAMoN,aAAa,GAAG,IAAI,CAACtJ,oBAAoB,KAAK,CAAC,IAAI,CAAC0E,aAAa;IAEvE,IAAMzD,WAAW,GAAG,IAAI,CAACC,YAAY;4BAE5BG,SAAS;MAChB,IAAMC,iBAAiB,GAAGiI,MAAA,CAAKhI,qBAAqB,CAACrF,KAAK,EAAEmF,SAAS,EAAEJ,WAAW,CAAC;MACnF,IAAMO,UAAU,GAAGF,iBAAiB,CAAC7F,MAAM;MAC3C,IAAM+N,QAAQ,GAAGlI,iBAAiB,CAACmI,IAAI;MACvC,IAAMpK,GAAG,GAAGiC,iBAAiB,CAACjC,GAAG;MAEjC+B,YAAY,GAAGE,iBAAiB,CAACG,SAAS;MAE1C,IAAMiI,UAAU,GAAGR,OAAO,GAAG1H,UAAU,GAAG,CAAC;MAE3C,IAAMmI,cAAc,GAClBjQ,SAAS,CAACgG,KAAK,CAACI,KAAmB,EAAE,UAACrB,IAAc;QAAK,QAAC,CAACA,IAAI,CAAC7B,KAAK,IAAI6B,IAAI,CAAC3B,UAAU,KAAKuE,SAAS;MAA7C,CAA6C,CAAC,GAAG,CAAC,CAAC;MAC9G,IAAMuI,oBAAoB,GAAG,CAAC3I,WAAW,IAAKyI,UAAU,IAAIzI,WAAW,CAAC7F,GAAG,IAAI8N,OAAO,IAAIjI,WAAW,CAAC5F,MAAQ;MAC9G,IAAMwO,qBAAqB,GACzB,CAACN,MAAA,CAAKpM,aAAa,IAAKuM,UAAU,IAAIH,MAAA,CAAKpM,aAAa,CAAC/B,GAAG,IAAI8N,OAAO,IAAIK,MAAA,CAAKpM,aAAa,CAAC9B,MAAQ;MAExG,IAAMoH,aAAa,GAChB,CAAC6G,aAAa,KAAKO,qBAAqB,IAAKD,oBAAoB,IAAID,cAAe,CAAC,IAAK,CAACN,gBAAgB;MAC9G,IAAMS,aAAa,GAAGV,YAAY,IAAI/H,SAAS,IAAI+H,YAAY,GAAG/H,SAAS,GAAGD,YAAY;MAC1F,IAAM2I,WAAW,GAAG1I,SAAS,KAAKvE,UAAU;MAE5C;MACA;MACA,IAAI2F,aAAa,IAAIqH,aAAa,IAAIC,WAAW,EAAE;QACjD,IAAIZ,aAAa,EAAE;UACjBrJ,KAAK,CAACF,IAAI,CAACuJ,aAAa,CAAC;UACzBA,aAAa,GAAG,IAAI;;QAGtB,IAAMa,WAAW,GAAGnH,IAAI,CAAC6E,GAAG,CAACtG,YAAY,EAAEJ,QAAQ,GAAGK,SAAS,CAAC;QAChE,IAAMmE,OAAO,GAAG+D,MAAA,CAAKU,WAAW,CAC9B5K,GAAG,EACHzC,KAAM,CAACsN,KAAK,CAAC7I,SAAS,EAAEA,SAAS,GAAG2I,WAAW,CAAC,EAChD3I,SAAS,EACTxC,SAAS,EACTA,SAAS,EACT2K,QAAQ,CACT;QAEDhE,OAAO,CAACpK,GAAG,GAAG8N,OAAO;QACrB1D,OAAO,CAAC/J,MAAM,GAAG+F,UAAU;QAC3B,IAAI+H,MAAA,CAAKY,YAAY,IAAIZ,MAAA,CAAKY,YAAY,CAAC9O,MAAM,EAAE;UACjDmK,OAAO,CAAC4E,SAAS,GAAGV,UAAU,IAAIH,MAAA,CAAKY,YAAY,CAAC/O,GAAG,IAAI8N,OAAO,IAAIK,MAAA,CAAKY,YAAY,CAAC9O,MAAM;;QAGhGyE,KAAK,CAACF,IAAI,CAAC4F,OAAO,CAAC;QAEnB,IAAIqE,qBAAqB,IAAIN,MAAA,CAAKrI,YAAY,EAAE;UAC9CmJ,UAAU,CAACpB,gBAAgB,EAAE;YAC3B7N,GAAG,EAAE8N,OAAO;YACZ7N,MAAM,EAAEqO,UAAU;YAClBjO,MAAM,EAAE+F,UAAU;YAClBlG,IAAI,EAAE2F,WAAW,CAAC3F,IAAI;YACtBC,KAAK,EAAE0F,WAAW,CAAC1F,KAAK;YACxBC,KAAK,EAAEyF,WAAW,CAACzF;WACpB,CAAC;;OAEL,MAAM;QACL,IAAI,CAAC2N,aAAa,EAAE;UAClBA,aAAa,GAAGI,MAAA,CAAKU,WAAW,CAC9BhP,iBAAiB,GAAGoG,SAAS,EAC7BxC,SAAS,EACTwC,SAAS,EACT,CAAC,EACDxC,SAAS,EACT2K,QAAQ,EACR,IAAI,CAAC,YAAY,CAClB;;QAEHL,aAAa,CAAC1N,MAAM,GAAG,CAAC0N,aAAa,CAAC1N,MAAM,IAAI,CAAC,KAAKiO,UAAU,GAAGR,OAAO,CAAC,GAAG,CAAC;QAC/EC,aAAa,CAAC1H,SAAS,IAAIL,YAAY;;MAEzC8H,OAAO,IAAIQ,UAAU,GAAGR,OAAO,GAAG,CAAC;MAEnC;MACA;MACA,IAAII,aAAa,IAAID,gBAAgB,EAAE;;;;;IA5EzC,KAAK,IAAIhI,SAAS,GAAGvE,UAAW,EAAEuE,SAAS,GAAGL,QAAQ,EAAEK,SAAS,IAAID,YAAY;4BAAxEC,SAAS;;;IAiFlB,IAAI8H,aAAa,EAAE;MACjBA,aAAa,CAAC9J,GAAG,GAAGpE,iBAAiB,GAAG,KAAK;MAC7C6E,KAAK,CAACF,IAAI,CAACuJ,aAAa,CAAC;;IAG3B,IAAI,CAACtE,iBAAiB,GAAGoE,gBAAgB;IAEzC;IACA,OAAArL,QAAA,CAAAA,QAAA,KACK8B,KAAK;MACRI,KAAK,EAAAA,KAAA;MACL8I,cAAc,EAAE,IAAI,CAACxL;IAAe;EAExC,CAAC;EAEOrB,IAAA,CAAA0E,SAAA,CAAAc,qBAAqB,GAA7B,UACErF,KAAiB,EACjBmF,SAAiB,EACjBiJ,WAAuB;IAQf,IAAAC,oBAAoB,GAAKrO,KAAK,CAAAqO,oBAAV;IAE5B,IAAIA,oBAAoB,EAAE;MACxB,IAAMf,QAAQ,GAAGe,oBAAoB,CAAClJ,SAAS,EAAEiJ,WAAW,EAAEpO,KAAK,CAACU,KAAK,CAAC;MAElE,IAAA4C,EAAA,GAAkEgK,QAAQ,CAAA/H,SAAb;QAA7DA,SAAS,GAAAjC,EAAA,cAAG,IAAI,CAACgL,oBAAoB,CAACnJ,SAAS,EAAEiJ,WAAW,CAAC,GAAA9K,EAAA;MAE7D,IAAApB,EAAA,GAAoEoL,QAAQ,CAAA/N,MAAb;QAA/DA,MAAM,GAAA2C,EAAA,cAAG,IAAI,CAACqM,cAAc,CAACpJ,SAAS,EAAEiJ,WAAW,EAAE7I,SAAS,CAAC,GAAArD,EAAA;MAEvE,OAAO;QACLqD,SAAS,EAAAA,SAAA;QACThG,MAAM,EAAAA,MAAA;QACNgO,IAAI,EAAED,QAAQ,CAACC,IAAI;QACnBpK,GAAG,EAAEmK,QAAQ,CAACnK;OACf;KACF,MAAM;MACL,IAAMoC,SAAS,GAAG,IAAI,CAAC+I,oBAAoB,CAACnJ,SAAS,EAAEiJ,WAAW,CAAC;MAEnE,OAAO;QACL7I,SAAS,EAAAA,SAAA;QACThG,MAAM,EAAE,IAAI,CAACgP,cAAc,CAACpJ,SAAS,EAAEiJ,WAAW,EAAE7I,SAAS;OAC9D;;EAEL,CAAC;EAED;;;;EAIQ1F,IAAA,CAAA0E,SAAA,CAAAgK,cAAc,GAAtB,UAAuBpJ,SAAiB,EAAEiJ,WAAuB,EAAElJ,YAAoB;IACrF,IAAI,IAAI,CAAClF,KAAK,CAACwI,aAAa,EAAE;MAC5B,OAAO,IAAI,CAACxI,KAAK,CAACwI,aAAa,CAACrD,SAAS,EAAEiJ,WAAW,EAAElJ,YAAY,EAAE,IAAI,CAAClF,KAAK,CAACU,KAAK,CAAC;KACxF,MAAM;MACL,IAAM+L,YAAY,GAAG,IAAI,CAACvI,kBAAkB,CAACiB,SAAS,CAAC;MAEvD,OAAOsH,YAAY,GAAGA,YAAY,CAAClN,MAAM,GAAG,IAAI,CAACuE,oBAAoB,IAAInF,mBAAmB;;EAEhG,CAAC;EAEOkB,IAAA,CAAA0E,SAAA,CAAA+J,oBAAoB,GAA5B,UAA6BnJ,SAAiB,EAAEqJ,YAAwB;IACtE,IAAMtJ,YAAY,GAAG,IAAI,CAAClF,KAAK,CAACyO,mBAAmB,GAC/C,IAAI,CAACzO,KAAK,CAACyO,mBAAmB,CAACtJ,SAAS,EAAEqJ,YAAY,CAAC,GACvD9P,sBAAsB;IAE1B,OAAOwG,YAAY,GAAGA,YAAY,GAAGxG,sBAAsB;EAC7D,CAAC;EAEOmB,IAAA,CAAA0E,SAAA,CAAAwJ,WAAW,GAAnB,UACEW,OAA2B,EAC3BhO,KAAwB,EACxBE,UAAuB,EACvB+N,KAAwC,EACxChE,KAA+B,EAC/B4C,IAAU,EACV/G,QAAkB;IAJlB,IAAA5F,UAAA;MAAAA,UAAA,IAAsB,CAAC;IAAA;IACvB,IAAA+N,KAAA;MAAAA,KAAA,GAAgBjO,KAAK,GAAGA,KAAK,CAACoC,MAAM,GAAG,CAAC;IAAA;IACxC,IAAA6H,KAAA;MAAAA,KAAA,KAA+B;IAAA;IAI/B+D,OAAO,GAAGA,OAAO,IAAI5P,eAAe,GAAG8B,UAAU;IACjD,IAAMyJ,UAAU,GAAG,IAAI,CAACjG,UAAU,CAACsK,OAAO,CAAC;IAC3C,IAAIrE,UAAU,IAAIA,UAAU,CAAC9H,IAAI,EAAE;MACjC,OAAO8H,UAAU,CAAC9H,IAAI;;IAGxB,OAAO;MACLY,GAAG,EAAEuL,OAAO;MACZ9N,UAAU,EAAAA,UAAA;MACV2E,SAAS,EAAEoJ,KAAK;MAChBjO,KAAK,EAAAA,KAAA;MACLiK,KAAK,EAAAA,KAAA;MACLzL,GAAG,EAAE,CAAC;MACNK,MAAM,EAAE,CAAC;MACTgO,IAAI,EAAAA,IAAA;MACJ/G,QAAQ,EAAEA,QAAQ,IAAI;KACvB;EACH,CAAC;EAEO3G,IAAA,CAAA0E,SAAA,CAAAM,eAAe,GAAvB,UAAwB7E,KAAqB;IACrC,IAAAsD,EAAA,GAAqCtD,KAAK,IAAI,IAAI,CAACA,KAAK;MAAtDU,KAAK,GAAA4C,EAAA,CAAA5C,KAAA;MAAEE,UAAU,GAAA0C,EAAA,CAAA1C,UAAA;MAAED,WAAW,GAAA2C,EAAA,CAAA3C,WAAwB;IAE9D,OAAOA,WAAW,KAAKgC,SAAS,GAAIjC,KAAK,GAAGA,KAAK,CAACoC,MAAM,GAAGlC,UAAW,GAAG,CAAC,GAAID,WAAW;EAC3F,CAAC;EAED;EACQd,IAAA,CAAA0E,SAAA,CAAAiF,kBAAkB,GAA1B,UAA2BxJ,KAAoB,EAAEwD,KAAoB,EAAE+F,WAAqB;IAClF,IAAA4B,oBAAoB,GAA4BnL,KAAK,CAAAmL,oBAAjC;MAAEC,qBAAqB,GAAKpL,KAAK,CAAAoL,qBAAV;IAC3C,IAAAxH,KAAK,GAAKJ,KAAK,CAAAI,KAAV;IACb;IACA,IAAI,CAAC,IAAI,CAACsG,iBAAiB,CAAClK,KAAK,CAAC,EAAE;MAClC;;IAGF,IAAI4O,WAAW,GAAG,IAAI,CAAClF,YAAY,IAAAhI,QAAA,KAASzC,UAAU,CAAE;IACxD,IAAM4P,YAAY,GAAG7Q,eAAe,CAAC,IAAI,CAACyH,cAAc,CAAC;IACzD,IAAMR,SAAS,GAAGhH,kBAAkB,CAAC,IAAI,CAACwH,cAAc,CAAC;IAEzD;IACA;IACA;IACA,IACE,IAAI,CAACpF,QAAQ,CAACuH,OAAO,KACpB2B,WAAW,IACV,CAAC3F,KAAK,IACN,CAAC,IAAI,CAAC8F,YAAY,IAClB,CAACmF,YAAY,IACbA,YAAY,KAAK,IAAI,CAACC,aAAa,IACnCnI,IAAI,CAACoI,GAAG,CAAC,IAAI,CAACtI,UAAU,GAAGxB,SAAS,CAAC,GAAG,IAAI,CAACnB,oBAAoB,GAAG9E,YAAY,CAAC,EACnF;MACA4P,WAAW,GAAG,IAAI,CAAClF,YAAY,GAAG/J,mBAAmB,CAAC,IAAI,CAACU,QAAQ,CAACuH,OAAO,CAAC;MAC5E,IAAI,CAACnB,UAAU,GAAGxB,SAAS;;IAG7B;IACA;IACA,IAAIsE,WAAW,IAAI,CAACsF,YAAY,IAAIA,YAAY,KAAK,IAAI,CAACC,aAAa,EAAE;MACvE,IAAI,CAAC5N,eAAe,EAAE;;IAGxB,IAAI,CAAC4N,aAAa,GAAGD,YAAY,IAAI,CAAC;IAEtC;IACA;IACA;IACA;IACA,IAAMG,UAAU,GAAGrI,IAAI,CAACsI,GAAG,CAAC,CAAC,EAAE,CAACL,WAAW,CAAC1P,GAAG,CAAC;IAChD,IAAM4I,GAAG,GAAGlK,SAAS,CAAC,IAAI,CAACuC,KAAK,CAACyH,OAAO,CAAC;IACzC,IAAMwG,WAAW,GAAG;MAClBlP,GAAG,EAAE8P,UAAU;MACf5P,IAAI,EAAEwP,WAAW,CAACxP,IAAI;MACtBD,MAAM,EAAE6P,UAAU,GAAGlH,GAAI,CAACoH,WAAW;MACrC7P,KAAK,EAAEuP,WAAW,CAACvP,KAAK;MACxBC,KAAK,EAAEsP,WAAW,CAACtP,KAAK;MACxBC,MAAM,EAAEuI,GAAI,CAACoH;KACd;IAED;IACA,IAAI,CAACjO,aAAa,GAAGkO,WAAW,CAACf,WAAW,EAAE,IAAI,CAACnK,sBAAsB,EAAE,IAAI,CAACD,qBAAqB,CAAC;IACtG,IAAI,CAACgB,YAAY,GAAGmK,WAAW,CAACf,WAAW,EAAEhD,qBAAsB,EAAED,oBAAqB,CAAC;IAE3F;IACA,IAAI,CAAC8C,YAAY,GAAGG,WAAW;EACjC,CAAC;EAzjCavO,IAAA,CAAAuP,YAAY,GAAG;IAC3BxO,UAAU,EAAE,CAAC;IACbuB,YAAY,EAAE,SAAAA,CAACa,IAAS,EAAED,KAAa,EAAEsM,aAAsB;MAAK,OAAAnS,KAAA,CAAAuE,aAAA,CAAAvE,KAAA,CAAAoS,QAAA,QAAItM,IAAI,IAAIA,IAAI,CAACuM,IAAI,IAAK,EAAE,CAAI;IAAhC,CAAgC;IACpGnN,uBAAuB,EAAEO,SAAS;IAClCwI,oBAAoB,EAAEtM,8BAA8B;IACpDuM,qBAAqB,EAAExM;GACxB;EAEaiB,IAAA,CAAA2P,WAAW,GAAGrR,aAAa;EAkjC3C,OAAA0B,IAAC;CAAA,CA3jCkC3C,KAAK,CAACuS,SAAS;SAArC5P,IAAI;AA6jCjB,SAASsP,WAAWA,CAACO,IAAgB,EAAEC,WAAmB,EAAEC,UAAkB;EAC5E,IAAM1Q,GAAG,GAAGwQ,IAAI,CAACxQ,GAAG,GAAGyQ,WAAW,GAAGD,IAAI,CAACnQ,MAAM;EAChD,IAAMA,MAAM,GAAGmQ,IAAI,CAACnQ,MAAM,GAAG,CAACoQ,WAAW,GAAGC,UAAU,IAAIF,IAAI,CAACnQ,MAAM;EAErE,OAAO;IACLL,GAAG,EAAAA,GAAA;IACHC,MAAM,EAAED,GAAG,GAAGK,MAAM;IACpBA,MAAM,EAAAA,MAAA;IACNH,IAAI,EAAEsQ,IAAI,CAACtQ,IAAI;IACfC,KAAK,EAAEqQ,IAAI,CAACrQ,KAAK;IACjBC,KAAK,EAAEoQ,IAAI,CAACpQ;GACb;AACH;AAEA,SAAS4L,kBAAkBA,CAAC2E,SAAqB,EAAEC,SAAqB;EACtE,OACED,SAAS,CAAC3Q,GAAG,IAAI4Q,SAAS,CAAC5Q,GAAG,IAC9B2Q,SAAS,CAACzQ,IAAI,IAAI0Q,SAAS,CAAC1Q,IAAI,IAChCyQ,SAAS,CAAC1Q,MAAO,IAAI2Q,SAAS,CAAC3Q,MAAO,IACtC0Q,SAAS,CAACxQ,KAAM,IAAIyQ,SAAS,CAACzQ,KAAM;AAExC;AAEA,SAAS8O,UAAUA,CAAC4B,UAAsB,EAAEC,OAAmB;EAC7DD,UAAU,CAAC7Q,GAAG,GAAG8Q,OAAO,CAAC9Q,GAAG,GAAG6Q,UAAU,CAAC7Q,GAAG,IAAI6Q,UAAU,CAAC7Q,GAAG,KAAK,CAAC,CAAC,GAAG8Q,OAAO,CAAC9Q,GAAG,GAAG6Q,UAAU,CAAC7Q,GAAG;EACrG6Q,UAAU,CAAC3Q,IAAI,GAAG4Q,OAAO,CAAC5Q,IAAI,GAAG2Q,UAAU,CAAC3Q,IAAI,IAAI2Q,UAAU,CAAC3Q,IAAI,KAAK,CAAC,CAAC,GAAG4Q,OAAO,CAAC5Q,IAAI,GAAG2Q,UAAU,CAAC3Q,IAAI;EAC3G2Q,UAAU,CAAC5Q,MAAM,GACf6Q,OAAO,CAAC7Q,MAAO,GAAG4Q,UAAU,CAAC5Q,MAAO,IAAI4Q,UAAU,CAAC5Q,MAAM,KAAK,CAAC,CAAC,GAAG6Q,OAAO,CAAC7Q,MAAM,GAAG4Q,UAAU,CAAC5Q,MAAM;EACvG4Q,UAAU,CAAC1Q,KAAK,GAAG2Q,OAAO,CAAC3Q,KAAM,GAAG0Q,UAAU,CAAC1Q,KAAM,IAAI0Q,UAAU,CAAC1Q,KAAK,KAAK,CAAC,CAAC,GAAG2Q,OAAO,CAAC3Q,KAAK,GAAG0Q,UAAU,CAAC1Q,KAAK;EACnH0Q,UAAU,CAACzQ,KAAK,GAAGyQ,UAAU,CAAC1Q,KAAM,GAAG0Q,UAAU,CAAC3Q,IAAI,GAAG,CAAC;EAC1D2Q,UAAU,CAACxQ,MAAM,GAAGwQ,UAAU,CAAC5Q,MAAO,GAAG4Q,UAAU,CAAC7Q,GAAG,GAAG,CAAC;EAE3D,OAAO6Q,UAAU;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}