{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\nimport { isShadowConfig } from './shadowConfig';\nimport { Stylesheet } from './Stylesheet';\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets() {\n  var styleSets = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styleSets[_i] = arguments[_i];\n  }\n  return mergeCssSets(styleSets, getStyleOptions());\n}\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(styleSets, options) {\n  var classNameSet = {\n    subComponentStyles: {}\n  };\n  var shadowConfig = undefined;\n  var styleSet;\n  if (isShadowConfig(styleSets[0])) {\n    shadowConfig = styleSets[0];\n    styleSet = styleSets[1];\n  } else {\n    styleSet = styleSets[0];\n  }\n  shadowConfig !== null && shadowConfig !== void 0 ? shadowConfig : shadowConfig = options === null || options === void 0 ? void 0 : options.shadowConfig;\n  var opts = __assign(__assign({}, options), {\n    shadowConfig: shadowConfig\n  });\n  if (!styleSet && styleSets.length <= 1) {\n    return {\n      subComponentStyles: {}\n    };\n  }\n  var sheet = Stylesheet.getInstance(shadowConfig);\n  opts.stylesheet = sheet;\n  var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);\n  var registrations = [];\n  for (var styleSetArea in concatenatedStyleSet) {\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n      if (styleSetArea === 'subComponentStyles') {\n        classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};\n        continue;\n      } else if (styleSetArea === '__shadowConfig__') {\n        continue;\n      }\n      var styles = concatenatedStyleSet[styleSetArea];\n      var _a = extractStyleParts(sheet, styles),\n        classes = _a.classes,\n        objects = _a.objects;\n      if (objects === null || objects === void 0 ? void 0 : objects.length) {\n        var registration = styleToRegistration(opts || {}, {\n          displayName: styleSetArea\n        }, objects);\n        if (registration) {\n          registrations.push(registration);\n          classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n        }\n      } else {\n        classNameSet[styleSetArea] = classes.join(' ');\n      }\n    }\n  }\n  for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {\n    var registration = registrations_1[_i];\n    if (registration) {\n      applyRegistration(registration, options === null || options === void 0 ? void 0 : options.specificityMultiplier, shadowConfig);\n    }\n  }\n  return classNameSet;\n}","map":{"version":3,"names":["concatStyleSets","extractStyleParts","getStyleOptions","applyRegistration","styleToRegistration","isShadowConfig","Stylesheet","mergeStyleSets","styleSets","_i","arguments","length","mergeCssSets","options","classNameSet","subComponentStyles","shadowConfig","undefined","styleSet","opts","__assign","sheet","getInstance","stylesheet","concatenatedStyleSet","apply","registrations","styleSetArea","hasOwnProperty","styles","_a","classes","objects","registration","displayName","push","concat","className","join","registrations_1","specificityMultiplier"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\merge-styles\\src\\mergeStyleSets.ts"],"sourcesContent":["import { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { IStyle } from './IStyle';\nimport { IStyleOptions } from './IStyleOptions';\nimport { IConcatenatedStyleSet, IProcessedStyleSet, IStyleSet } from './IStyleSet';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\nimport { ObjectOnly } from './ObjectOnly';\nimport { isShadowConfig, ShadowConfig } from './shadowConfig';\nimport { Stylesheet } from './Stylesheet';\n\ntype Missing = false | null | undefined;\ntype MissingOrShadowConfig = Missing | ShadowConfig;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet - The first style set to be merged and reigstered.\n */\nexport function mergeStyleSets<TStyleSet>(styleSet: TStyleSet | Missing): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2>(\n  styleSet1: TStyleSet1 | Missing,\n  styleSet2: TStyleSet2 | Missing,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSet1: TStyleSet1 | Missing,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n * @param styleSet4 - The fourth style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSet1: TStyleSet1 | Missing,\n  styleSet2: TStyleSet2 | Missing,\n  styleSet3: TStyleSet3 | Missing,\n  styleSet4: TStyleSet4 | Missing,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(...styleSets: Array<IStyleSet | MissingOrShadowConfig>): IProcessedStyleSet<any>;\n\nexport function mergeStyleSets(\n  shadowConfig: ShadowConfig,\n  ...styleSets: Array<IStyleSet | Missing>\n): IProcessedStyleSet<any>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(...styleSets: any[]): IProcessedStyleSet<any> {\n  return mergeCssSets(styleSets as any, getStyleOptions());\n}\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSets: [TStyleSet | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2>(\n  styleSets: [TStyleSet1 | MissingOrShadowConfig, TStyleSet2 | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSets: [TStyleSet1 | MissingOrShadowConfig, TStyleSet2 | Missing, TStyleSet3 | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSets: [TStyleSet1 | MissingOrShadowConfig, TStyleSet2 | Missing, TStyleSet3 | Missing, TStyleSet4 | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSet: [TStyleSet | Missing],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(styleSets: any[], options?: IStyleOptions): IProcessedStyleSet<any> {\n  const classNameSet: IProcessedStyleSet<any> & Record<string, unknown> = { subComponentStyles: {} };\n\n  let shadowConfig: ShadowConfig | undefined = undefined;\n  let styleSet;\n  if (isShadowConfig(styleSets[0])) {\n    shadowConfig = styleSets[0];\n    styleSet = styleSets[1];\n  } else {\n    styleSet = styleSets[0];\n  }\n\n  shadowConfig ??= options?.shadowConfig;\n\n  const opts = { ...options, shadowConfig };\n\n  if (!styleSet && styleSets.length <= 1) {\n    return { subComponentStyles: {} } as any;\n  }\n\n  const sheet = Stylesheet.getInstance(shadowConfig);\n  opts.stylesheet = sheet;\n  const concatenatedStyleSet = concatStyleSets(...styleSets);\n\n  const registrations = [];\n\n  for (const styleSetArea in concatenatedStyleSet) {\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n      if (styleSetArea === 'subComponentStyles') {\n        classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};\n        continue;\n      } else if (styleSetArea === '__shadowConfig__') {\n        continue;\n      }\n\n      const styles: IStyle = (concatenatedStyleSet as any)[styleSetArea];\n\n      const { classes, objects } = extractStyleParts(sheet, styles);\n\n      if (objects?.length) {\n        const registration = styleToRegistration(opts || {}, { displayName: styleSetArea }, objects);\n\n        if (registration) {\n          registrations.push(registration);\n          classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n        }\n      } else {\n        classNameSet[styleSetArea] = classes.join(' ');\n      }\n    }\n  }\n\n  for (const registration of registrations) {\n    if (registration) {\n      applyRegistration(registration, options?.specificityMultiplier, shadowConfig);\n    }\n  }\n\n  return classNameSet;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}