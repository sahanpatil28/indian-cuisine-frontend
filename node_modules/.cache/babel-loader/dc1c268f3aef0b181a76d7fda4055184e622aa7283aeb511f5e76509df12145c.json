{"ast":null,"code":"import { mergeCssSets, Stylesheet } from '@fluentui/merge-styles';\nimport { getRTL } from './rtl';\nimport { getWindow } from './dom';\nvar MAX_CACHE_COUNT = 50;\nvar DEFAULT_SPECIFICITY_MULTIPLIER = 5;\nvar _memoizedClassNames = 0;\nvar stylesheet = Stylesheet.getInstance();\nif (stylesheet && stylesheet.onReset) {\n  stylesheet.onReset(function () {\n    return _memoizedClassNames++;\n  });\n}\n// Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\nvar retVal = '__retval__';\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\nexport function classNamesFunction(options) {\n  // We build a trie where each node is a Map. The map entry key represents an argument\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\n  // property which is used to hold the cached response.\n  if (options === void 0) {\n    options = {};\n  }\n  // To derive the response, we can simply ensure the arguments are added or already\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\n  // let map: IRecursiveMemoNode = new Map();\n  var windowMap = new Map();\n  var styleCalcCount = 0;\n  var getClassNamesCount = 0;\n  var currentMemoizedClassNames = _memoizedClassNames;\n  var getClassNames = function (styleFunctionOrObject, styleProps) {\n    var _a;\n    if (styleProps === void 0) {\n      styleProps = {};\n    }\n    // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.\n    // If there is also no style overrides, we can skip merge styles completely and\n    // simply return the result from the style funcion.\n    if (options.useStaticStyles && typeof styleFunctionOrObject === 'function' && styleFunctionOrObject.__noStyleOverride__) {\n      return styleFunctionOrObject(styleProps);\n    }\n    getClassNamesCount++;\n    var shadowConfig = styleFunctionOrObject ? styleFunctionOrObject.__shadowConfig__ : undefined;\n    var key = shadowConfig && shadowConfig.window ? shadowConfig.window : '__default__';\n    if (!windowMap.has(key)) {\n      windowMap.set(key, new Map());\n    }\n    var current = windowMap.get(key);\n    // let current: Map<any, any> = map;\n    var theme = styleProps.theme;\n    var rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();\n    var disableCaching = options.disableCaching;\n    // On reset of our stylesheet, reset memoized cache.\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\n      currentMemoizedClassNames = _memoizedClassNames;\n      // map = new Map();\n      windowMap.set(key, new Map());\n      current = windowMap.get(key);\n      styleCalcCount = 0;\n    }\n    if (!options.disableCaching) {\n      current = _traverseMap(windowMap.get(key), styleFunctionOrObject);\n      current = _traverseMap(current, styleProps);\n    }\n    if (disableCaching || !current[retVal]) {\n      if (styleFunctionOrObject === undefined) {\n        current[retVal] = {};\n      } else {\n        current[retVal] = mergeCssSets([typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject], {\n          shadowConfig: styleFunctionOrObject.__shadowConfig__,\n          rtl: !!rtl,\n          specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined\n        });\n      }\n      if (!disableCaching) {\n        styleCalcCount++;\n      }\n    }\n    if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {\n      var win = getWindow();\n      if ((_a = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a === void 0 ? void 0 : _a.enableClassNameCacheFullWarning) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Styles are being recalculated too frequently. Cache miss rate is \".concat(styleCalcCount, \"/\").concat(getClassNamesCount, \".\"));\n        // eslint-disable-next-line no-console\n        console.trace();\n      }\n      windowMap.get(key).clear();\n      styleCalcCount = 0;\n      // Mutate the options passed in, that's all we can do.\n      options.disableCaching = true;\n    }\n    // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to\n    // cache the return value for this branch of the graph.\n    return current[retVal];\n  };\n  return getClassNames;\n}\nfunction _traverseEdge(current, value) {\n  value = _normalizeValue(value);\n  if (!current.has(value)) {\n    current.set(value, new Map());\n  }\n  return current.get(value);\n}\nfunction _traverseMap(current, inputs) {\n  if (typeof inputs === 'function') {\n    var cachedInputsFromStyled = inputs.__cachedInputs__;\n    if (cachedInputsFromStyled) {\n      // The styled helper will generate the styles function and will attach the cached\n      // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n      // These should be used as cache keys for deriving the memoized value.\n      for (var _i = 0, _a = inputs.__cachedInputs__; _i < _a.length; _i++) {\n        var input = _a[_i];\n        current = _traverseEdge(current, input);\n      }\n    } else {\n      current = _traverseEdge(current, inputs);\n    }\n  } else if (typeof inputs === 'object') {\n    for (var propName in inputs) {\n      if (inputs.hasOwnProperty(propName)) {\n        current = _traverseEdge(current, inputs[propName]);\n      }\n    }\n  }\n  return current;\n}\nfunction _normalizeValue(value) {\n  switch (value) {\n    case undefined:\n      return '__undefined__';\n    case null:\n      return '__null__';\n    default:\n      return value;\n  }\n}","map":{"version":3,"names":["mergeCssSets","Stylesheet","getRTL","getWindow","MAX_CACHE_COUNT","DEFAULT_SPECIFICITY_MULTIPLIER","_memoizedClassNames","stylesheet","getInstance","onReset","retVal","classNamesFunction","options","windowMap","Map","styleCalcCount","getClassNamesCount","currentMemoizedClassNames","getClassNames","styleFunctionOrObject","styleProps","useStaticStyles","__noStyleOverride__","shadowConfig","__shadowConfig__","undefined","key","window","has","set","current","get","theme","rtl","disableCaching","_traverseMap","specificityMultiplier","cacheSize","win","_a","FabricConfig","enableClassNameCacheFullWarning","console","warn","concat","trace","clear","_traverseEdge","value","_normalizeValue","inputs","cachedInputsFromStyled","__cachedInputs__","_i","length","input","propName","hasOwnProperty"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\utilities\\src\\classNamesFunction.ts"],"sourcesContent":["import { mergeCssSets, Stylesheet } from '@fluentui/merge-styles';\nimport { getRTL } from './rtl';\nimport { getWindow } from './dom';\nimport type { IStyleSet, IStyleSetBase, IProcessedStyleSet, IStyleFunctionOrObject } from '@fluentui/merge-styles';\nimport type { StyleFunction } from './styled';\n\nconst MAX_CACHE_COUNT = 50;\nconst DEFAULT_SPECIFICITY_MULTIPLIER = 5;\n\nlet _memoizedClassNames = 0;\n\nconst stylesheet = Stylesheet.getInstance();\n\nif (stylesheet && stylesheet.onReset) {\n  stylesheet.onReset(() => _memoizedClassNames++);\n}\n\n// Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\nconst retVal = '__retval__';\n\ninterface IRecursiveMemoNode extends Map<any, IRecursiveMemoNode> {\n  [retVal]?: string;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { enableClassNameCacheFullWarning?: boolean } }) | undefined;\n\nexport interface IClassNamesFunctionOptions {\n  /**\n   * Disables class caching for scenarios where styleProp parts mutate frequently.\n   */\n  disableCaching?: boolean;\n\n  /**\n   * Size of the cache. It overwrites default cache size when defined.\n   */\n  cacheSize?: number;\n\n  /**\n   * Set to true if component base styles are implemented in scss instead of css-in-js.\n   */\n  useStaticStyles?: boolean;\n}\n\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\nexport function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSetBase>(\n  options: IClassNamesFunctionOptions = {},\n): (\n  getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n  styleProps?: TStyleProps,\n) => IProcessedStyleSet<TStyleSet> {\n  // We build a trie where each node is a Map. The map entry key represents an argument\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\n  // property which is used to hold the cached response.\n\n  // To derive the response, we can simply ensure the arguments are added or already\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\n  // let map: IRecursiveMemoNode = new Map();\n  let windowMap: Map<'__default__' | Window, IRecursiveMemoNode> = new Map();\n  let styleCalcCount = 0;\n  let getClassNamesCount = 0;\n  let currentMemoizedClassNames = _memoizedClassNames;\n\n  const getClassNames = (\n    styleFunctionOrObject: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n    styleProps: TStyleProps = {} as TStyleProps,\n  ): IProcessedStyleSet<TStyleSet> => {\n    // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.\n    // If there is also no style overrides, we can skip merge styles completely and\n    // simply return the result from the style funcion.\n    if (\n      options.useStaticStyles &&\n      typeof styleFunctionOrObject === 'function' &&\n      (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__noStyleOverride__\n    ) {\n      return styleFunctionOrObject(styleProps) as IProcessedStyleSet<TStyleSet>;\n    }\n\n    getClassNamesCount++;\n    const shadowConfig = styleFunctionOrObject\n      ? (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__shadowConfig__\n      : undefined;\n    const key = shadowConfig && shadowConfig.window ? shadowConfig.window : '__default__';\n\n    if (!windowMap.has(key)) {\n      windowMap.set(key, new Map());\n    }\n    let current: Map<any, any> = windowMap.get(key)!;\n\n    // let current: Map<any, any> = map;\n    const { theme } = styleProps as any;\n    const rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();\n\n    const disableCaching = options.disableCaching;\n\n    // On reset of our stylesheet, reset memoized cache.\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\n      currentMemoizedClassNames = _memoizedClassNames;\n      // map = new Map();\n      windowMap.set(key, new Map());\n      current = windowMap.get(key)!;\n      styleCalcCount = 0;\n    }\n\n    if (!options.disableCaching) {\n      current = _traverseMap(windowMap.get(key)!, styleFunctionOrObject as any);\n      current = _traverseMap(current, styleProps);\n    }\n\n    if (disableCaching || !(current as any)[retVal]) {\n      if (styleFunctionOrObject === undefined) {\n        (current as any)[retVal] = {} as IProcessedStyleSet<TStyleSet>;\n      } else {\n        (current as any)[retVal] = mergeCssSets(\n          [\n            (typeof styleFunctionOrObject === 'function'\n              ? styleFunctionOrObject(styleProps)\n              : styleFunctionOrObject) as IStyleSet<TStyleSet>,\n          ],\n          {\n            shadowConfig: (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__shadowConfig__,\n            rtl: !!rtl,\n            specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined,\n          },\n        );\n      }\n\n      if (!disableCaching) {\n        styleCalcCount++;\n      }\n    }\n\n    if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {\n      const win = getWindow() as AppWindow;\n      if (win?.FabricConfig?.enableClassNameCacheFullWarning) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Styles are being recalculated too frequently. Cache miss rate is ${styleCalcCount}/${getClassNamesCount}.`,\n        );\n        // eslint-disable-next-line no-console\n        console.trace();\n      }\n\n      windowMap.get(key)!.clear();\n      styleCalcCount = 0;\n\n      // Mutate the options passed in, that's all we can do.\n      options.disableCaching = true;\n    }\n\n    // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to\n    // cache the return value for this branch of the graph.\n    return (current as any)[retVal];\n  };\n\n  return getClassNames;\n}\n\nfunction _traverseEdge(current: Map<any, any>, value: any): Map<any, any> {\n  value = _normalizeValue(value);\n\n  if (!current.has(value)) {\n    current.set(value, new Map<any, any>());\n  }\n\n  return current.get(value);\n}\n\nfunction _traverseMap(current: Map<any, any>, inputs: any[] | Object): Map<any, any> {\n  if (typeof inputs === 'function') {\n    const cachedInputsFromStyled = (inputs as StyleFunction<any, any>).__cachedInputs__;\n    if (cachedInputsFromStyled) {\n      // The styled helper will generate the styles function and will attach the cached\n      // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n      // These should be used as cache keys for deriving the memoized value.\n      for (const input of (inputs as any).__cachedInputs__) {\n        current = _traverseEdge(current, input);\n      }\n    } else {\n      current = _traverseEdge(current, inputs);\n    }\n  } else if (typeof inputs === 'object') {\n    for (const propName in inputs) {\n      if (inputs.hasOwnProperty(propName)) {\n        current = _traverseEdge(current, (inputs as any)[propName]);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction _normalizeValue(value: any): string {\n  switch (value) {\n    case undefined:\n      return '__undefined__';\n    case null:\n      return '__null__';\n    default:\n      return value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}