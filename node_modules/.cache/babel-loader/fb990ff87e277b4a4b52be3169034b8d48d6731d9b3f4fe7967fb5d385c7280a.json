{"ast":null,"code":"import { EventGroup } from './EventGroup';\nimport { findScrollableParent } from './scroll';\nimport { getRect } from './dom/getRect';\nimport { getWindow } from './dom';\nvar SCROLL_ITERATION_DELAY = 16;\nvar SCROLL_GUTTER = 100;\nvar MAX_SCROLL_VELOCITY = 15;\n/**\n * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container\n * up/down depending on how close the mouse is to the top/bottom of the container.\n *\n * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.\n *\n * @public\n * {@docCategory AutoScroll}\n */\nvar AutoScroll = /** @class */function () {\n  function AutoScroll(element, win) {\n    var theWin = win !== null && win !== void 0 ? win : getWindow(element);\n    this._events = new EventGroup(this);\n    this._scrollableParent = findScrollableParent(element);\n    this._incrementScroll = this._incrementScroll.bind(this);\n    this._scrollRect = getRect(this._scrollableParent, theWin);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (this._scrollableParent === theWin) {\n      this._scrollableParent = theWin.document.body;\n    }\n    if (this._scrollableParent) {\n      this._events.on(theWin, 'mousemove', this._onMouseMove, true);\n      this._events.on(theWin, 'touchmove', this._onTouchMove, true);\n    }\n  }\n  AutoScroll.prototype.dispose = function () {\n    this._events.dispose();\n    this._stopScroll();\n  };\n  AutoScroll.prototype._onMouseMove = function (ev) {\n    this._computeScrollVelocity(ev);\n  };\n  AutoScroll.prototype._onTouchMove = function (ev) {\n    if (ev.touches.length > 0) {\n      this._computeScrollVelocity(ev);\n    }\n  };\n  AutoScroll.prototype._computeScrollVelocity = function (ev) {\n    if (!this._scrollRect) {\n      return;\n    }\n    var clientX;\n    var clientY;\n    if ('clientX' in ev) {\n      clientX = ev.clientX;\n      clientY = ev.clientY;\n    } else {\n      clientX = ev.touches[0].clientX;\n      clientY = ev.touches[0].clientY;\n    }\n    var scrollRectTop = this._scrollRect.top;\n    var scrollRectLeft = this._scrollRect.left;\n    var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;\n    var scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;\n    // variables to use for alternating scroll direction\n    var scrollRect;\n    var clientDirection;\n    var scrollClient;\n    // if either of these conditions are met we are scrolling vertically else horizontally\n    if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {\n      clientDirection = clientY;\n      scrollRect = scrollRectTop;\n      scrollClient = scrollClientBottom;\n      this._isVerticalScroll = true;\n    } else {\n      clientDirection = clientX;\n      scrollRect = scrollRectLeft;\n      scrollClient = scrollClientRight;\n      this._isVerticalScroll = false;\n    }\n    // calculate scroll velocity and direction\n    if (clientDirection < scrollRect + SCROLL_GUTTER) {\n      this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER));\n    } else if (clientDirection > scrollClient) {\n      this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER));\n    } else {\n      this._scrollVelocity = 0;\n    }\n    if (this._scrollVelocity) {\n      this._startScroll();\n    } else {\n      this._stopScroll();\n    }\n  };\n  AutoScroll.prototype._startScroll = function () {\n    if (!this._timeoutId) {\n      this._incrementScroll();\n    }\n  };\n  AutoScroll.prototype._incrementScroll = function () {\n    if (this._scrollableParent) {\n      if (this._isVerticalScroll) {\n        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);\n      } else {\n        this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);\n      }\n    }\n    this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);\n  };\n  AutoScroll.prototype._stopScroll = function () {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      delete this._timeoutId;\n    }\n  };\n  return AutoScroll;\n}();\nexport { AutoScroll };","map":{"version":3,"names":["EventGroup","findScrollableParent","getRect","getWindow","SCROLL_ITERATION_DELAY","SCROLL_GUTTER","MAX_SCROLL_VELOCITY","AutoScroll","element","win","theWin","_events","_scrollableParent","_incrementScroll","bind","_scrollRect","document","body","on","_onMouseMove","_onTouchMove","prototype","dispose","_stopScroll","ev","_computeScrollVelocity","touches","length","clientX","clientY","scrollRectTop","top","scrollRectLeft","left","scrollClientBottom","height","scrollClientRight","width","scrollRect","clientDirection","scrollClient","_isVerticalScroll","_scrollVelocity","Math","max","min","_startScroll","_timeoutId","scrollTop","round","scrollLeft","setTimeout","clearTimeout"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\utilities\\src\\AutoScroll.ts"],"sourcesContent":["import { EventGroup } from './EventGroup';\nimport { findScrollableParent } from './scroll';\nimport { getRect } from './dom/getRect';\nimport type { IRectangle } from './IRectangle';\nimport { getWindow } from './dom';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\n\nconst SCROLL_ITERATION_DELAY = 16;\nconst SCROLL_GUTTER = 100;\nconst MAX_SCROLL_VELOCITY = 15;\n\n/**\n * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container\n * up/down depending on how close the mouse is to the top/bottom of the container.\n *\n * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.\n *\n * @public\n * {@docCategory AutoScroll}\n */\nexport class AutoScroll {\n  private _events: EventGroup;\n  private _scrollableParent: HTMLElement | null;\n  private _scrollRect: IRectangle | undefined;\n  private _scrollVelocity!: number;\n  private _isVerticalScroll!: boolean;\n  private _timeoutId?: number;\n\n  constructor(element: HTMLElement, win?: Window) {\n    const theWin = win ?? getWindow(element)!;\n    this._events = new EventGroup(this);\n    this._scrollableParent = findScrollableParent(element) as HTMLElement;\n\n    this._incrementScroll = this._incrementScroll.bind(this);\n    this._scrollRect = getRect(this._scrollableParent, theWin);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (this._scrollableParent === (theWin as any)) {\n      this._scrollableParent = theWin.document.body;\n    }\n\n    if (this._scrollableParent) {\n      this._events.on(theWin, 'mousemove', this._onMouseMove, true);\n      this._events.on(theWin, 'touchmove', this._onTouchMove, true);\n    }\n  }\n\n  public dispose(): void {\n    this._events.dispose();\n    this._stopScroll();\n  }\n\n  private _onMouseMove(ev: MouseEvent): void {\n    this._computeScrollVelocity(ev);\n  }\n\n  private _onTouchMove(ev: TouchEvent): void {\n    if (ev.touches.length > 0) {\n      this._computeScrollVelocity(ev);\n    }\n  }\n\n  private _computeScrollVelocity(ev: MouseEvent | TouchEvent): void {\n    if (!this._scrollRect) {\n      return;\n    }\n\n    let clientX: number;\n    let clientY: number;\n    if ('clientX' in ev) {\n      clientX = ev.clientX;\n      clientY = ev.clientY;\n    } else {\n      clientX = ev.touches[0].clientX;\n      clientY = ev.touches[0].clientY;\n    }\n\n    let scrollRectTop = this._scrollRect.top;\n    let scrollRectLeft = this._scrollRect.left;\n    let scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;\n    let scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;\n\n    // variables to use for alternating scroll direction\n    let scrollRect;\n    let clientDirection;\n    let scrollClient;\n\n    // if either of these conditions are met we are scrolling vertically else horizontally\n    if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {\n      clientDirection = clientY;\n      scrollRect = scrollRectTop;\n      scrollClient = scrollClientBottom;\n      this._isVerticalScroll = true;\n    } else {\n      clientDirection = clientX;\n      scrollRect = scrollRectLeft;\n      scrollClient = scrollClientRight;\n      this._isVerticalScroll = false;\n    }\n\n    // calculate scroll velocity and direction\n    if (clientDirection! < scrollRect + SCROLL_GUTTER) {\n      this._scrollVelocity = Math.max(\n        -MAX_SCROLL_VELOCITY,\n        -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER),\n      );\n    } else if (clientDirection > scrollClient) {\n      this._scrollVelocity = Math.min(\n        MAX_SCROLL_VELOCITY,\n        MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER),\n      );\n    } else {\n      this._scrollVelocity = 0;\n    }\n\n    if (this._scrollVelocity) {\n      this._startScroll();\n    } else {\n      this._stopScroll();\n    }\n  }\n\n  private _startScroll(): void {\n    if (!this._timeoutId) {\n      this._incrementScroll();\n    }\n  }\n\n  private _incrementScroll(): void {\n    if (this._scrollableParent) {\n      if (this._isVerticalScroll) {\n        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);\n      } else {\n        this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);\n      }\n    }\n\n    this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);\n  }\n\n  private _stopScroll(): void {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      delete this._timeoutId;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}