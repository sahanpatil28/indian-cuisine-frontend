{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nimport { tokenizeWithParentheses } from './tokenizeWithParentheses';\nvar DISPLAY_NAME = 'displayName';\nfunction getDisplayName(rules) {\n  var rootStyle = rules && rules['&'];\n  return rootStyle ? rootStyle.displayName : undefined;\n}\nvar globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals) {\n  // We the selector does not have a :global() we can shortcut\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n    return selectorWithGlobals;\n  }\n  var replacementInfo = [];\n  var findGlobal = /\\:global\\((.+?)\\)/g;\n  var match = null;\n  // Create a result list for global selectors so we can replace them.\n  while (match = findGlobal.exec(selectorWithGlobals)) {\n    // Only if the found selector is a comma separated list we'll process it.\n    if (match[1].indexOf(',') > -1) {\n      replacementInfo.push([match.index, match.index + match[0].length,\n      // Wrap each of the found selectors in :global()\n      match[1].split(',').map(function (v) {\n        return \":global(\".concat(v.trim(), \")\");\n      }).join(', ')]);\n    }\n  }\n  // Replace the found selectors with their wrapped variants in reverse order\n  return replacementInfo.reverse().reduce(function (selector, _a) {\n    var matchIndex = _a[0],\n      matchEndIndex = _a[1],\n      replacement = _a[2];\n    var prefix = selector.slice(0, matchIndex);\n    var suffix = selector.slice(matchEndIndex);\n    return prefix + replacement + suffix;\n  }, selectorWithGlobals);\n}\nfunction isSelector(potentialSelector) {\n  return potentialSelector.indexOf(':global(') >= 0 || potentialSelector.indexOf(':') === 0;\n}\nfunction expandSelector(newSelector, currentSelector) {\n  if (newSelector.indexOf(':global(') >= 0) {\n    return newSelector.replace(globalSelectorRegExp, '$1');\n  } else if (newSelector.indexOf(':host(') === 0) {\n    return newSelector;\n  } else if (newSelector.indexOf(':') === 0) {\n    return currentSelector + newSelector;\n  } else if (newSelector.indexOf('&') < 0) {\n    return currentSelector + ' ' + newSelector;\n  }\n  return newSelector;\n}\nfunction extractSelector(currentSelector, rules, selector, value, stylesheet) {\n  if (rules === void 0) {\n    rules = {\n      __order: []\n    };\n  }\n  if (selector.indexOf('@') === 0) {\n    selector = selector + '{' + currentSelector;\n    extractRules([value], rules, selector, stylesheet);\n  } else if (selector.indexOf(',') > -1) {\n    expandCommaSeparatedGlobals(selector).split(',').map(function (s) {\n      return s.trim();\n    }).forEach(function (separatedSelector) {\n      return extractRules([value], rules, expandSelector(separatedSelector, currentSelector), stylesheet);\n    });\n  } else {\n    extractRules([value], rules, expandSelector(selector, currentSelector), stylesheet);\n  }\n}\nfunction extractRules(args, rules, currentSelector, stylesheet) {\n  if (rules === void 0) {\n    rules = {\n      __order: []\n    };\n  }\n  if (currentSelector === void 0) {\n    currentSelector = '&';\n  }\n  var currentRules = rules[currentSelector];\n  if (!currentRules) {\n    currentRules = {};\n    rules[currentSelector] = currentRules;\n    rules.__order.push(currentSelector);\n  }\n  for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n    var arg = args_1[_i];\n    // If the arg is a string, we need to look up the class map and merge.\n    if (typeof arg === 'string') {\n      var expandedRules = stylesheet.argsFromClassName(arg);\n      if (expandedRules) {\n        extractRules(expandedRules, rules, currentSelector, stylesheet);\n      }\n      // Else if the arg is an array, we need to recurse in.\n    } else if (Array.isArray(arg)) {\n      extractRules(arg, rules, currentSelector, stylesheet);\n    } else {\n      for (var prop in arg) {\n        if (arg.hasOwnProperty(prop)) {\n          var propValue = arg[prop];\n          if (prop === 'selectors') {\n            // every child is a selector.\n            var selectors = arg.selectors;\n            for (var newSelector in selectors) {\n              if (selectors.hasOwnProperty(newSelector)) {\n                extractSelector(currentSelector, rules, newSelector, selectors[newSelector], stylesheet);\n              }\n            }\n          } else if (typeof propValue === 'object' || isSelector(prop)) {\n            // prop is a selector.\n            if (propValue !== null && propValue !== undefined) {\n              extractSelector(currentSelector, rules, prop, propValue, stylesheet);\n            }\n          } else {\n            if (propValue !== undefined) {\n              // Else, add the rule to the currentSelector.\n              if (prop === 'margin' || prop === 'padding') {\n                expandQuads(currentRules, prop, propValue);\n              } else {\n                currentRules[prop] = propValue;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return rules;\n}\nfunction expandQuads(currentRules, name, value) {\n  var parts = typeof value === 'string' ? tokenizeWithParentheses(value) : [value];\n  if (parts.length === 0) {\n    parts.push(value);\n  }\n  if (parts[parts.length - 1] === '!important') {\n    // Remove !important from parts, and append it to each part individually\n    parts = parts.slice(0, -1).map(function (p) {\n      return p + ' !important';\n    });\n  }\n  currentRules[name + 'Top'] = parts[0];\n  currentRules[name + 'Right'] = parts[1] || parts[0];\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\nfunction getKeyForRules(options, rules) {\n  var serialized = [options.rtl ? 'rtl' : 'ltr'];\n  var hasProps = false;\n  for (var _i = 0, _a = rules.__order; _i < _a.length; _i++) {\n    var selector = _a[_i];\n    serialized.push(selector);\n    var rulesForSelector = rules[selector];\n    for (var propName in rulesForSelector) {\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n        hasProps = true;\n        serialized.push(propName, rulesForSelector[propName]);\n      }\n    }\n  }\n  return hasProps ? serialized.join('') : undefined;\n}\nfunction repeatString(target, count) {\n  if (count <= 0) {\n    return '';\n  }\n  if (count === 1) {\n    return target;\n  }\n  return target + repeatString(target, count - 1);\n}\nexport function serializeRuleEntries(options, ruleEntries) {\n  if (!ruleEntries) {\n    return '';\n  }\n  var allEntries = [];\n  for (var entry in ruleEntries) {\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n      allEntries.push(entry, ruleEntries[entry]);\n    }\n  }\n  // Apply transforms.\n  for (var i = 0; i < allEntries.length; i += 2) {\n    kebabRules(allEntries, i);\n    provideUnits(allEntries, i);\n    rtlifyRules(options, allEntries, i);\n    prefixRules(allEntries, i);\n  }\n  // Apply punctuation.\n  for (var i = 1; i < allEntries.length; i += 4) {\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\n  }\n  return allEntries.join('');\n}\nexport function styleToRegistration(options) {\n  var _a;\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  var stylesheet = (_a = options.stylesheet) !== null && _a !== void 0 ? _a : Stylesheet.getInstance(options.shadowConfig);\n  var rules = extractRules(args, undefined, undefined, stylesheet);\n  var key = getKeyForRules(options, rules);\n  if (key) {\n    var registration = {\n      className: stylesheet.classNameFromKey(key),\n      key: key,\n      args: args\n    };\n    if (!registration.className) {\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\n      var rulesToInsert = [];\n      for (var _b = 0, _c = rules.__order; _b < _c.length; _b++) {\n        var selector = _c[_b];\n        rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n      }\n      registration.rulesToInsert = rulesToInsert;\n    }\n    return registration;\n  }\n  return undefined;\n}\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\nexport function applyRegistration(registration, specificityMultiplier, shadowConfig, sheet) {\n  if (specificityMultiplier === void 0) {\n    specificityMultiplier = 1;\n  }\n  var stylesheet = sheet !== null && sheet !== void 0 ? sheet : Stylesheet.getInstance(shadowConfig);\n  var className = registration.className,\n    key = registration.key,\n    args = registration.args,\n    rulesToInsert = registration.rulesToInsert;\n  if (rulesToInsert) {\n    // rulesToInsert is an ordered array of selector/rule pairs.\n    for (var i = 0; i < rulesToInsert.length; i += 2) {\n      var rules = rulesToInsert[i + 1];\n      if (rules) {\n        var selector = rulesToInsert[i];\n        selector = selector.replace(/&/g, repeatString(\".\".concat(registration.className), specificityMultiplier));\n        // Insert. Note if a media query, we must close the query with a final bracket.\n        var processedRule = \"\".concat(selector, \"{\").concat(rules, \"}\").concat(selector.indexOf('@') === 0 ? '}' : '');\n        stylesheet.insertRule(processedRule);\n      }\n    }\n    stylesheet.cacheClassName(className, key, args, rulesToInsert);\n  }\n}\nexport function styleToClassName(options) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  var registration = styleToRegistration.apply(void 0, __spreadArray([options], args, false));\n  if (registration) {\n    applyRegistration(registration, options.specificityMultiplier, options.shadowConfig, options.stylesheet);\n    return registration.className;\n  }\n  return '';\n}","map":{"version":3,"names":["Stylesheet","kebabRules","prefixRules","provideUnits","rtlifyRules","tokenizeWithParentheses","DISPLAY_NAME","getDisplayName","rules","rootStyle","displayName","undefined","globalSelectorRegExp","expandCommaSeparatedGlobals","selectorWithGlobals","test","replacementInfo","findGlobal","match","exec","indexOf","push","index","length","split","map","v","concat","trim","join","reverse","reduce","selector","_a","matchIndex","matchEndIndex","replacement","prefix","slice","suffix","isSelector","potentialSelector","expandSelector","newSelector","currentSelector","replace","extractSelector","value","stylesheet","__order","extractRules","s","forEach","separatedSelector","args","currentRules","_i","args_1","arg","expandedRules","argsFromClassName","Array","isArray","prop","hasOwnProperty","propValue","selectors","expandQuads","name","parts","p","getKeyForRules","options","serialized","rtl","hasProps","rulesForSelector","propName","repeatString","target","count","serializeRuleEntries","ruleEntries","allEntries","entry","i","splice","styleToRegistration","arguments","getInstance","shadowConfig","key","registration","className","classNameFromKey","getClassName","rulesToInsert","_b","_c","applyRegistration","specificityMultiplier","sheet","processedRule","insertRule","cacheClassName","styleToClassName","apply","__spreadArray"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\merge-styles\\src\\styleToClassName.ts"],"sourcesContent":["import { IStyle } from './IStyle';\nimport { IRawStyle } from './IRawStyle';\n\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nimport { IStyleOptions } from './IStyleOptions';\nimport { tokenizeWithParentheses } from './tokenizeWithParentheses';\nimport { ShadowConfig } from './shadowConfig';\n\nconst DISPLAY_NAME = 'displayName';\n\ntype IDictionary = { [key: string]: any };\n\ninterface IRuleSet {\n  __order: string[];\n  [key: string]: IDictionary;\n}\n\nfunction getDisplayName(rules?: { [key: string]: IRawStyle }): string | undefined {\n  const rootStyle: IStyle = rules && rules['&'];\n\n  return rootStyle ? (rootStyle as IRawStyle).displayName : undefined;\n}\n\nconst globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n\ntype ReplacementInfo = [number, number, string];\n\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals: string): string {\n  // We the selector does not have a :global() we can shortcut\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n    return selectorWithGlobals;\n  }\n\n  const replacementInfo: ReplacementInfo[] = [];\n\n  const findGlobal = /\\:global\\((.+?)\\)/g;\n  let match = null;\n  // Create a result list for global selectors so we can replace them.\n  while ((match = findGlobal.exec(selectorWithGlobals))) {\n    // Only if the found selector is a comma separated list we'll process it.\n    if (match[1].indexOf(',') > -1) {\n      replacementInfo.push([\n        match.index,\n        match.index + match[0].length,\n        // Wrap each of the found selectors in :global()\n        match[1]\n          .split(',')\n          .map((v: string) => `:global(${v.trim()})`)\n          .join(', '),\n      ]);\n    }\n  }\n\n  // Replace the found selectors with their wrapped variants in reverse order\n  return replacementInfo\n    .reverse()\n    .reduce((selector: string, [matchIndex, matchEndIndex, replacement]: ReplacementInfo) => {\n      const prefix = selector.slice(0, matchIndex);\n      const suffix = selector.slice(matchEndIndex);\n\n      return prefix + replacement + suffix;\n    }, selectorWithGlobals);\n}\n\nfunction isSelector(potentialSelector: string): boolean {\n  return potentialSelector.indexOf(':global(') >= 0 || potentialSelector.indexOf(':') === 0;\n}\n\nfunction expandSelector(newSelector: string, currentSelector: string): string {\n  if (newSelector.indexOf(':global(') >= 0) {\n    return newSelector.replace(globalSelectorRegExp, '$1');\n  } else if (newSelector.indexOf(':host(') === 0) {\n    return newSelector;\n  } else if (newSelector.indexOf(':') === 0) {\n    return currentSelector + newSelector;\n  } else if (newSelector.indexOf('&') < 0) {\n    return currentSelector + ' ' + newSelector;\n  }\n\n  return newSelector;\n}\n\nfunction extractSelector(\n  currentSelector: string,\n  rules: IRuleSet = { __order: [] },\n  selector: string,\n  value: IStyle,\n  stylesheet: Stylesheet,\n) {\n  if (selector.indexOf('@') === 0) {\n    selector = selector + '{' + currentSelector;\n    extractRules([value], rules, selector, stylesheet);\n  } else if (selector.indexOf(',') > -1) {\n    expandCommaSeparatedGlobals(selector)\n      .split(',')\n      .map((s: string) => s.trim())\n      .forEach((separatedSelector: string) =>\n        extractRules([value], rules, expandSelector(separatedSelector, currentSelector), stylesheet),\n      );\n  } else {\n    extractRules([value], rules, expandSelector(selector, currentSelector), stylesheet);\n  }\n}\n\nfunction extractRules(\n  args: IStyle[],\n  rules: IRuleSet = { __order: [] },\n  currentSelector: string = '&',\n  stylesheet: Stylesheet,\n): IRuleSet {\n  let currentRules: IDictionary | undefined = rules[currentSelector] as IDictionary;\n\n  if (!currentRules) {\n    currentRules = {};\n    rules[currentSelector] = currentRules;\n    rules.__order.push(currentSelector);\n  }\n\n  for (const arg of args) {\n    // If the arg is a string, we need to look up the class map and merge.\n    if (typeof arg === 'string') {\n      const expandedRules = stylesheet.argsFromClassName(arg);\n\n      if (expandedRules) {\n        extractRules(expandedRules, rules, currentSelector, stylesheet);\n      }\n      // Else if the arg is an array, we need to recurse in.\n    } else if (Array.isArray(arg)) {\n      extractRules(arg, rules, currentSelector, stylesheet);\n    } else {\n      for (const prop in arg as any) {\n        if ((arg as any).hasOwnProperty(prop)) {\n          const propValue = (arg as any)[prop];\n          if (prop === 'selectors') {\n            // every child is a selector.\n            const selectors: { [key: string]: IStyle } = (arg as any).selectors;\n\n            for (const newSelector in selectors) {\n              if (selectors.hasOwnProperty(newSelector)) {\n                extractSelector(currentSelector, rules, newSelector, selectors[newSelector], stylesheet);\n              }\n            }\n          } else if (typeof propValue === 'object' || isSelector(prop)) {\n            // prop is a selector.\n            if (propValue !== null && propValue !== undefined) {\n              extractSelector(currentSelector, rules, prop, propValue, stylesheet);\n            }\n          } else {\n            if (propValue !== undefined) {\n              // Else, add the rule to the currentSelector.\n              if (prop === 'margin' || prop === 'padding') {\n                expandQuads(currentRules, prop, propValue);\n              } else {\n                (currentRules as any)[prop] = propValue;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return rules;\n}\n\nfunction expandQuads(currentRules: IDictionary, name: string, value: string): void {\n  let parts = typeof value === 'string' ? tokenizeWithParentheses(value) : [value];\n\n  if (parts.length === 0) {\n    parts.push(value);\n  }\n\n  if (parts[parts.length - 1] === '!important') {\n    // Remove !important from parts, and append it to each part individually\n    parts = parts.slice(0, -1).map(p => p + ' !important');\n  }\n\n  currentRules[name + 'Top'] = parts[0];\n  currentRules[name + 'Right'] = parts[1] || parts[0];\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\n\nfunction getKeyForRules(options: IStyleOptions, rules: IRuleSet): string | undefined {\n  const serialized: string[] = [options.rtl ? 'rtl' : 'ltr'];\n  let hasProps = false;\n\n  for (const selector of rules.__order) {\n    serialized.push(selector);\n    const rulesForSelector = rules[selector];\n\n    for (const propName in rulesForSelector) {\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n        hasProps = true;\n        serialized.push(propName, rulesForSelector[propName]);\n      }\n    }\n  }\n\n  return hasProps ? serialized.join('') : undefined;\n}\n\nfunction repeatString(target: string, count: number): string {\n  if (count <= 0) {\n    return '';\n  }\n\n  if (count === 1) {\n    return target;\n  }\n\n  return target + repeatString(target, count - 1);\n}\n\nexport function serializeRuleEntries(options: IStyleOptions, ruleEntries: { [key: string]: string | number }): string {\n  if (!ruleEntries) {\n    return '';\n  }\n\n  const allEntries: (string | number)[] = [];\n\n  for (const entry in ruleEntries) {\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n      allEntries.push(entry, ruleEntries[entry]);\n    }\n  }\n\n  // Apply transforms.\n  for (let i = 0; i < allEntries.length; i += 2) {\n    kebabRules(allEntries, i);\n    provideUnits(allEntries, i);\n    rtlifyRules(options, allEntries, i);\n    prefixRules(allEntries, i);\n  }\n\n  // Apply punctuation.\n  for (let i = 1; i < allEntries.length; i += 4) {\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\n  }\n\n  return allEntries.join('');\n}\n\nexport interface IRegistration {\n  className: string;\n  key: string;\n  args: IStyle[];\n  rulesToInsert: string[];\n}\n\nexport function styleToRegistration(options: IStyleOptions, ...args: IStyle[]): IRegistration | undefined {\n  const stylesheet = options.stylesheet ?? Stylesheet.getInstance(options.shadowConfig);\n  const rules: IRuleSet = extractRules(args, undefined, undefined, stylesheet);\n  const key = getKeyForRules(options, rules);\n\n  if (key) {\n    const registration: Partial<IRegistration> = {\n      className: stylesheet.classNameFromKey(key),\n      key,\n      args,\n    };\n\n    if (!registration.className) {\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\n      const rulesToInsert: string[] = [];\n\n      for (const selector of rules.__order) {\n        rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n      }\n      registration.rulesToInsert = rulesToInsert;\n    }\n\n    return registration as IRegistration;\n  }\n\n  return undefined;\n}\n\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\nexport function applyRegistration(\n  registration: IRegistration,\n  specificityMultiplier: number = 1,\n  shadowConfig?: ShadowConfig,\n  sheet?: Stylesheet,\n): void {\n  const stylesheet = sheet ?? Stylesheet.getInstance(shadowConfig);\n  const { className, key, args, rulesToInsert } = registration;\n\n  if (rulesToInsert) {\n    // rulesToInsert is an ordered array of selector/rule pairs.\n    for (let i = 0; i < rulesToInsert.length; i += 2) {\n      const rules = rulesToInsert[i + 1];\n      if (rules) {\n        let selector = rulesToInsert[i];\n        selector = selector.replace(/&/g, repeatString(`.${registration.className}`, specificityMultiplier));\n\n        // Insert. Note if a media query, we must close the query with a final bracket.\n        const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;\n        stylesheet.insertRule(processedRule);\n      }\n    }\n    stylesheet.cacheClassName(className!, key!, args!, rulesToInsert);\n  }\n}\n\nexport function styleToClassName(options: IStyleOptions, ...args: IStyle[]): string {\n  const registration = styleToRegistration(options, ...args);\n  if (registration) {\n    applyRegistration(registration, options.specificityMultiplier, options.shadowConfig, options.stylesheet);\n\n    return registration.className;\n  }\n\n  return '';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}