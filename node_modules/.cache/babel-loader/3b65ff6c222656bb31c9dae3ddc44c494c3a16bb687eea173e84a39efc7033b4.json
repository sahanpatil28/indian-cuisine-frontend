{"ast":null,"code":"var _a;\nimport { __assign } from \"tslib\";\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL, getWindow } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\nfunction _createPositionData(targetEdge, alignmentEdge, isAuto) {\n  return {\n    targetEdge: targetEdge,\n    alignmentEdge: alignmentEdge,\n    isAuto: isAuto\n  };\n}\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nvar DirectionalDictionary = (_a = {}, _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, undefined, true), _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, undefined, true), _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a);\nfunction _isRectangleWithinBounds(rect, boundingRect) {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n  return true;\n}\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect, boundingRect) {\n  var outOfBounds = [];\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n  return outOfBounds;\n}\nfunction _getEdgeValue(rect, edge) {\n  return rect[RectangleEdge[edge]];\n}\nfunction _setEdgeValue(rect, edge, value) {\n  rect[RectangleEdge[edge]] = value;\n  return rect;\n}\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect, edge) {\n  var edges = _getFlankingEdges(edge);\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge, value) {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\nfunction _getRelativeRectEdgeValue(edge, rect) {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\nfunction _getRelativeEdgeDifference(rect, hostRect, edge) {\n  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\nfunction _moveEdge(rect, edge, newValue, maintainSize) {\n  if (maintainSize === void 0) {\n    maintainSize = true;\n  }\n  var difference = _getEdgeValue(rect, edge) - newValue;\n  var returnRect = _setEdgeValue(rect, edge, newValue);\n  if (maintainSize) {\n    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  }\n  return returnRect;\n}\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect, target, edge, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(rect, target, targetEdge, gap) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n  var oppositeEdge = targetEdge * -1;\n  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect, bounds, edge) {\n  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\nfunction _getOutOfBoundsDegree(rect, bounds) {\n  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n  var total = 0;\n  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {\n    var edge = breakingEdges_1[_i];\n    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);\n  }\n  return total;\n}\n/**\n * Returns true if scroll-resizing will move the target edge within the bounding rectangle,\n * and there is room between the target edge and the bounding edge for scrolled content.\n * Returns false otherwise.\n */\nfunction _canScrollResizeToFitEdge(target, bounding, targetEdge, minimumScrollResizeHeight) {\n  if (minimumScrollResizeHeight === void 0) {\n    minimumScrollResizeHeight = 200;\n  }\n  // Only scroll vertically to fit - cannot scroll to fit right or left edges\n  if (targetEdge !== RectangleEdge.bottom && targetEdge !== RectangleEdge.top) {\n    return false;\n  }\n  return _getRelativeEdgeDifference(target, bounding, targetEdge) >= minimumScrollResizeHeight;\n}\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\nfunction _flipToFit(rect, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap) {\n  if (shouldScroll === void 0) {\n    shouldScroll = false;\n  }\n  if (gap === void 0) {\n    gap = 0;\n  }\n  var directions = [RectangleEdge.left, RectangleEdge.right, RectangleEdge.bottom, RectangleEdge.top];\n  // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n  var currentEstimate = rect;\n  var currentEdge = positionData.targetEdge;\n  var currentAlignment = positionData.alignmentEdge;\n  // keep track of least bad option, in case no sides fit\n  var oobDegree;\n  var bestEdge = currentEdge;\n  var bestAlignment = currentAlignment;\n  // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n  for (var i = 0; i < 4; i++) {\n    if (_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      // Edge is in bounds, return current estimate\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment\n      };\n    } else if (shouldScroll && _canScrollResizeToFitEdge(target, bounding, currentEdge, minimumScrollResizeHeight)) {\n      // Scrolling will allow edge to fit, move the estimate currentEdge inside the bounds and return\n      switch (currentEdge) {\n        case RectangleEdge.bottom:\n          currentEstimate.bottom = bounding.bottom;\n          break;\n        case RectangleEdge.top:\n          currentEstimate.top = bounding.top;\n          break;\n      }\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n        forcedInBounds: true\n      };\n    } else {\n      // update least-bad edges\n      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n      if (!oobDegree || currentOOBDegree < oobDegree) {\n        oobDegree = currentOOBDegree;\n        bestEdge = currentEdge;\n        bestAlignment = currentAlignment;\n      }\n      directions.splice(directions.indexOf(currentEdge), 1);\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n        currentEstimate = _estimatePosition(rect, target, {\n          targetEdge: currentEdge,\n          alignmentEdge: currentAlignment\n        }, gap);\n      }\n    }\n  }\n  // nothing fits, use least-bad option\n  currentEstimate = _estimatePosition(rect, target, {\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment\n  }, gap);\n  return {\n    elementRectangle: currentEstimate,\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment\n  };\n}\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\nfunction _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {\n  var alignmentEdge = elementEstimate.alignmentEdge,\n    targetEdge = elementEstimate.targetEdge,\n    elementRectangle = elementEstimate.elementRectangle;\n  var oppositeEdge = alignmentEdge * -1;\n  var newEstimate = _estimatePosition(elementRectangle, target, {\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge\n  }, gap, coverTarget);\n  return {\n    elementRectangle: newEstimate,\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge\n  };\n}\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap, directionalHintFixed, coverTarget) {\n  if (shouldScroll === void 0) {\n    shouldScroll = false;\n  }\n  if (gap === void 0) {\n    gap = 0;\n  }\n  var alignmentEdge = positionData.alignmentEdge,\n    alignTargetEdge = positionData.alignTargetEdge;\n  var elementEstimate = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: alignmentEdge\n  };\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap);\n  }\n  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);\n  // if directionalHintFixed is specified, we need to force the target edge to not change\n  // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n  if (outOfBounds.length > 0) {\n    if (alignTargetEdge) {\n      // The edge opposite to the alignment edge might be out of bounds.\n      // Flip alignment to see if we can get it within bounds.\n      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n          return flippedElementEstimate;\n        } else {\n          // If the flipped elements edges are still out of bounds, try nudging it.\n          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);\n        }\n      } else {\n        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n      }\n    } else {\n      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n    }\n  }\n  return elementEstimate;\n}\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\nfunction _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {\n  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {\n    var direction = outOfBoundsEdges_1[_i];\n    var edgeAttempt = void 0;\n    // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n    // this is because _alignEdges will move the opposite edge\n    if (preserveEdge && preserveEdge === direction * -1) {\n      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n      elementEstimate.forcedInBounds = true;\n    } else {\n      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);\n      // only update estimate if the attempt didn't break out of the opposite bounding edge\n      if (!inBounds) {\n        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n        elementEstimate.forcedInBounds = true;\n      }\n    }\n    elementEstimate.elementRectangle = edgeAttempt;\n  }\n  return elementEstimate;\n}\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect, edge, point) {\n  var positiveEdge = _getFlankingEdges(edge).positiveEdge;\n  var elementMiddle = _getCenterValue(rect, edge);\n  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {\n  if (gap === void 0) {\n    gap = 0;\n  }\n  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);\n  var alignmentEdge = positionData.alignmentEdge,\n    targetEdge = positionData.targetEdge;\n  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);\n  // if no alignment edge is provided it's supposed to be centered.\n  if (!alignmentEdge) {\n    var targetMiddlePoint = _getCenterValue(target, targetEdge);\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n  return estimatedElementPosition;\n}\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge) {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom\n    };\n  }\n}\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {\n  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {\n    return returnEdge * -1;\n  }\n  return returnEdge;\n}\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\nfunction _isEdgeOnBounds(elementRectangle, edge, bounds) {\n  return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {\n  var returnValue = {};\n  var hostRect = _getRectangleFromElement(hostElement);\n  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n  // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n  // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n  // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n  // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n  // in the usual direction\n  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n  // if the positioned element will still overflow, return all four edges with in-bounds values\n  if (forceWithinBounds) {\n    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);\n    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);\n  }\n  return returnValue;\n}\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth) {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {\n  if (directionalHint === void 0) {\n    directionalHint = DirectionalHint.bottomAutoEdge;\n  }\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge\n    };\n  }\n  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n  return positionInformation;\n}\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\nfunction getClosestEdge(targetEdge, target, boundingRect) {\n  var targetCenter = _getCenterValue(target, targetEdge);\n  var boundingCenter = _getCenterValue(boundingRect, targetEdge);\n  var _a = _getFlankingEdges(targetEdge),\n    positiveEdge = _a.positiveEdge,\n    negativeEdge = _a.negativeEdge;\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\nfunction _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, shouldScroll, minimumScrollResizeHeight, directionalHintFixed, coverTarget) {\n  if (shouldScroll === void 0) {\n    shouldScroll = false;\n  }\n  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge\n    };\n  } else {\n    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap, directionalHintFixed, coverTarget);\n  }\n}\nfunction _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {\n  var targetEdge = elementPosition.targetEdge * -1;\n  // The \"host\" element that we will use to help position the beak.\n  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);\n  var returnValue = {};\n  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);\n  // only show the beak if the callout is not fully covering the target\n  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);\n  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n  return {\n    elementPosition: __assign({}, returnValue),\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge: targetEdge,\n    hideBeak: !showBeak\n  };\n}\nfunction _positionBeak(beakWidth, elementPosition) {\n  var target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n  var _a = _getFlankingEdges(elementPosition.targetEdge),\n    positiveEdge = _a.positiveEdge,\n    negativeEdge = _a.negativeEdge;\n  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);\n  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n  return beakPosition;\n}\nfunction _getRectangleFromElement(element) {\n  // eslint-disable-next-line deprecation/deprecation\n  var clientRect = element.getBoundingClientRect();\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\nfunction _getRectangleFromIRect(rect) {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\nfunction _getTargetRect(bounds, target) {\n  var targetRectangle;\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!target.preventDefault) {\n      var ev = target;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n      // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!target.getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target);\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      var rectOrPoint = target;\n      // eslint-disable-next-line deprecation/deprecation\n      var left = rectOrPoint.left || rectOrPoint.x;\n      // eslint-disable-next-line deprecation/deprecation\n      var top_1 = rectOrPoint.top || rectOrPoint.y;\n      var right = rectOrPoint.right || left;\n      var bottom = rectOrPoint.bottom || top_1;\n      targetRectangle = new Rectangle(left, right, top_1, bottom);\n    }\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);\n      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {\n        var direction = outOfBounds_1[_i];\n        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n  return targetRectangle;\n}\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {\n  var maxHeight = 0;\n  var directionalHint = DirectionalDictionary[targetEdge];\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n  var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\nfunction _positionElementRelative(props, elementToPosition, boundingRect, previousPositions, shouldScroll, minimumScrollResizeHeight) {\n  if (shouldScroll === void 0) {\n    shouldScroll = false;\n  }\n  var gap = props.gapSpace ? props.gapSpace : 0;\n  var targetRect = _getTargetRect(boundingRect, props.target);\n  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);\n  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, shouldScroll, minimumScrollResizeHeight, props.directionalHintFixed, props.coverTarget);\n  return __assign(__assign({}, positionedElement), {\n    targetRectangle: targetRect\n  });\n}\nfunction _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {\n  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge\n  };\n}\nfunction _positionElement(props, hostElement, elementToPosition, previousPositions, win) {\n  var theWin = win !== null && win !== void 0 ? win : getWindow();\n  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n  var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\nfunction _calculateGapSpace(isBeakVisible, beakWidth, gapSpace) {\n  if (beakWidth === void 0) {\n    beakWidth = 0;\n  }\n  if (gapSpace === void 0) {\n    gapSpace = 0;\n  }\n  return _calculateActualBeakWidthInPixels(isBeakVisible ? beakWidth : 0) / 2 + gapSpace;\n}\nfunction _positionCallout(props, hostElement, callout, previousPositions, shouldScroll, minimumScrollResizeHeight, doNotFinalizeReturnEdge, win) {\n  if (shouldScroll === void 0) {\n    shouldScroll = false;\n  }\n  var theWin = win !== null && win !== void 0 ? win : getWindow();\n  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  var gap = _calculateGapSpace(props.isBeakVisible, props.beakWidth, props.gapSpace);\n  var positionProps = props;\n  positionProps.gapSpace = gap;\n  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions, shouldScroll, minimumScrollResizeHeight);\n  var beakPositioned = _positionBeak(beakWidth, positionedElement);\n  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);\n  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), {\n    beakPosition: finalizedBeakPosition\n  });\n}\nfunction _positionCard(props, hostElement, callout, previousPositions, win) {\n  var theWin = win !== null && win !== void 0 ? win : getWindow();\n  return _positionCallout(props, hostElement, callout, previousPositions, false, undefined, true, theWin);\n}\nfunction _getRectangleFromTarget(target) {\n  var _a, _b, _c, _d;\n  var mouseTarget = target;\n  var elementTarget = target;\n  var rectOrPointTarget = target;\n  var targetRect;\n  // eslint-disable-next-line deprecation/deprecation\n  var left = (_a = rectOrPointTarget.left) !== null && _a !== void 0 ? _a : rectOrPointTarget.x;\n  // eslint-disable-next-line deprecation/deprecation\n  var top = (_b = rectOrPointTarget.top) !== null && _b !== void 0 ? _b : rectOrPointTarget.y;\n  var right = (_c = rectOrPointTarget.right) !== null && _c !== void 0 ? _c : left;\n  var bottom = (_d = rectOrPointTarget.bottom) !== null && _d !== void 0 ? _d : top;\n  // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, right, top, bottom);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n  return targetRect;\n}\n// END PRIVATE FUNCTIONS\nexport var __positioningTestPackage = {\n  _finalizePositionData: _finalizePositionData,\n  _finalizeBeakPosition: _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels: _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds: _positionElementWithinBounds,\n  _positionBeak: _positionBeak,\n  _getPositionData: _getPositionData,\n  _getMaxHeightFromTargetRectangle: _getMaxHeightFromTargetRectangle\n};\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(props, hostElement, elementToPosition, previousPositions, win) {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions, win);\n}\nexport function positionCallout(props, hostElement, elementToPosition, previousPositions, shouldScroll, minimumScrollResizeHeight, win) {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions, shouldScroll, minimumScrollResizeHeight, undefined, win);\n}\nexport function positionCard(props, hostElement, elementToPosition, previousPositions, win) {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions, win);\n}\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget, win) {\n  if (gapSpace === void 0) {\n    gapSpace = 0;\n  }\n  var theWin = win !== null && win !== void 0 ? win : getWindow();\n  var targetRect = _getRectangleFromTarget(target);\n  var boundingRectangle = bounds ? _getRectangleFromIRect(bounds) : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge) {\n  return edge * -1;\n}\nfunction _getBoundsFromTargetWindow(target, targetWindow) {\n  var segments = undefined;\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  }\n  // Identify if we're dealing with single screen scenarios.\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight\n    };\n  }\n  // Logic for determining dual screen scenarios.\n  var x = 0;\n  var y = 0;\n  // If the target is an Element get coordinates for its center.\n  if (target !== null && !!target.getBoundingClientRect) {\n    var clientRect = target.getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  }\n  // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = target.left || target.x;\n    // eslint-disable-next-line deprecation/deprecation\n    y = target.top || target.y;\n  }\n  var bounds = {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: 0,\n    height: 0\n  };\n  // Define which window segment are the coordinates in and calculate bounds based on that.\n  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n    var segment = segments_1[_i];\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height\n      };\n    }\n  }\n  return bounds;\n}\nexport function getBoundsFromTargetWindow(target, targetWindow) {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}\nexport function calculateGapSpace(isBeakVisible, beakWidth, gapSpace) {\n  return _calculateGapSpace(isBeakVisible, beakWidth, gapSpace);\n}\nexport function getRectangleFromTarget(target) {\n  return _getRectangleFromTarget(target);\n}","map":{"version":3,"names":["DirectionalHint","getScrollbarWidth","getRTL","getWindow","RectangleEdge","Rectangle","_createPositionData","targetEdge","alignmentEdge","isAuto","DirectionalDictionary","_a","topLeftEdge","top","left","topCenter","topRightEdge","right","topAutoEdge","undefined","bottomLeftEdge","bottom","bottomCenter","bottomRightEdge","bottomAutoEdge","leftTopEdge","leftCenter","leftBottomEdge","rightTopEdge","rightCenter","rightBottomEdge","_isRectangleWithinBounds","rect","boundingRect","_getOutOfBoundsEdges","outOfBounds","push","_getEdgeValue","edge","_setEdgeValue","value","_getCenterValue","edges","_getFlankingEdges","positiveEdge","negativeEdge","_getRelativeEdgeValue","_getRelativeRectEdgeValue","_getRelativeEdgeDifference","hostRect","edgeDifference","_moveEdge","newValue","maintainSize","difference","returnRect","_alignEdges","target","gap","_alignOppositeEdges","oppositeEdge","adjustedGap","_isEdgeInBounds","bounds","adjustedRectValue","_getOutOfBoundsDegree","breakingEdges","total","_i","breakingEdges_1","length","Math","pow","_canScrollResizeToFitEdge","bounding","minimumScrollResizeHeight","_flipToFit","positionData","shouldScroll","directions","currentEstimate","currentEdge","currentAlignment","oobDegree","bestEdge","bestAlignment","i","elementRectangle","forcedInBounds","currentOOBDegree","splice","indexOf","slice","_estimatePosition","_flipAlignmentEdge","elementEstimate","coverTarget","newEstimate","_adjustFitWithinBounds","element","directionalHintFixed","alignTargetEdge","fixedEdge","flippedElementEstimate","_alignOutOfBoundsEdges","outOfBoundsEdges","preserveEdge","outOfBoundsEdges_1","direction","edgeAttempt","inBounds","_centerEdgeToPoint","point","elementMiddle","distanceToMiddle","elementToPosition","estimatedElementPosition","elementEdge","targetMiddlePoint","_finalizeReturnEdge","returnEdge","abs","_isEdgeOnBounds","_finalizeElementPosition","hostElement","doNotFinalizeReturnEdge","forceWithinBounds","returnValue","_getRectangleFromElement","getOppositeEdge","_calculateActualBeakWidthInPixels","beakWidth","sqrt","_getPositionData","directionalHint","directionalHintForRTL","previousPositions","positionInformation","__assign","_getAlignmentData","getClosestEdge","targetCenter","boundingCenter","_positionElementWithinBounds","_finalizeBeakPosition","elementPosition","positionedBeak","actualElement","width","height","beakEdgeDifference","targetRectangle","showBeak","closestEdge","hideBeak","_positionBeak","beakTargetPoint","elementBounds","beakPosition","clientRect","getBoundingClientRect","_getRectangleFromIRect","_getTargetRect","preventDefault","ev","clientX","clientY","rectOrPoint","x","top_1","y","outOfBounds_1","_getMaxHeightFromTargetRectangle","gapSpace","maxHeight","_positionElementRelative","props","targetRect","positionedElement","_finalizePositionData","finalizedElement","_positionElement","win","theWin","innerWidth","innerHeight","_calculateGapSpace","isBeakVisible","_positionCallout","callout","positionProps","beakPositioned","finalizedBeakPosition","_positionCard","_getRectangleFromTarget","mouseTarget","elementTarget","rectOrPointTarget","_b","_c","_d","stopPropagation","__positioningTestPackage","positionElement","positionCallout","positionCard","getMaxHeight","boundingRectangle","_getBoundsFromTargetWindow","targetWindow","segments","getWindowSegments","segments_1","segment","getBoundsFromTargetWindow","calculateGapSpace","getRectangleFromTarget"],"sources":["C:\\Users\\sahan\\Documents\\Projects\\indian-cuisine-frontend\\node_modules\\@fluentui\\react\\lib\\utilities\\src\\utilities\\positioning\\positioning.ts"],"sourcesContent":["import { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL, getWindow } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\nimport type { IRectangle, Point } from '../../Utilities';\nimport type {\n  IPositionDirectionalHintData,\n  IPositionedData,\n  ICalloutPositionedInfo,\n  ICalloutBeakPositionedInfo,\n  IPositionProps,\n  ICalloutPositionProps,\n  IWindowWithSegments,\n} from './positioning.types';\n\nfunction _createPositionData(\n  targetEdge: RectangleEdge,\n  alignmentEdge?: RectangleEdge,\n  isAuto?: boolean,\n): IPositionDirectionalHintData {\n  return {\n    targetEdge,\n    alignmentEdge,\n    isAuto,\n  };\n}\n\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nconst DirectionalDictionary: { [key: number]: IPositionDirectionalHintData } = {\n  [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),\n  [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),\n  [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),\n  [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),\n  [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\n  [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),\n  [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\n  [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),\n  [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),\n  [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),\n  [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\n  [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),\n  [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),\n  [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom),\n};\n\n/**\n * Do not call methods from this directly, use either positionCallout or positionElement or make another function that\n * utilizes them.\n * START Private functions and interfaces\n */\n\nexport interface IElementPosition {\n  elementRectangle: Rectangle;\n  targetEdge: RectangleEdge;\n  alignmentEdge: RectangleEdge | undefined;\n  forcedInBounds?: boolean;\n}\n\nexport interface IElementPositionInfo extends IElementPosition {\n  targetRectangle: Rectangle;\n}\n\ntype PartialIRectangle = Partial<IRectangle>;\n\ninterface IPartialIRectangle extends PartialIRectangle {\n  [key: string]: number | undefined;\n}\n\nfunction _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\n  const outOfBounds: RectangleEdge[] = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect: Rectangle, edge: RectangleEdge): number {\n  return (rect as any)[RectangleEdge[edge]] as number;\n}\n\nfunction _setEdgeValue(rect: Rectangle, edge: RectangleEdge, value: number) {\n  (rect as any)[RectangleEdge[edge]] = value;\n  return rect;\n}\n\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect: Rectangle, edge: RectangleEdge): number {\n  const edges = _getFlankingEdges(edge);\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge: RectangleEdge, value: number): number {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge: RectangleEdge, rect: Rectangle): number {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect: Rectangle, hostRect: Rectangle, edge: RectangleEdge): number {\n  const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\nfunction _moveEdge(rect: Rectangle, edge: RectangleEdge, newValue: number, maintainSize = true): Rectangle {\n  const difference = _getEdgeValue(rect, edge) - newValue;\n  let returnRect = _setEdgeValue(rect, edge, newValue);\n  if (maintainSize) {\n    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  }\n  return returnRect;\n}\n\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect: Rectangle, target: Rectangle, edge: RectangleEdge, gap: number = 0): Rectangle {\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(\n  rect: Rectangle,\n  target: Rectangle,\n  targetEdge: RectangleEdge,\n  gap: number = 0,\n): Rectangle {\n  const oppositeEdge = targetEdge * -1;\n  const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect: Rectangle, bounds: Rectangle, edge: RectangleEdge): boolean {\n  const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\nfunction _getOutOfBoundsDegree(rect: Rectangle, bounds: Rectangle) {\n  const breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n  let total = 0;\n  for (const edge of breakingEdges) {\n    total += _getRelativeEdgeDifference(rect, bounds, edge) ** 2;\n  }\n\n  return total;\n}\n\n/**\n * Returns true if scroll-resizing will move the target edge within the bounding rectangle,\n * and there is room between the target edge and the bounding edge for scrolled content.\n * Returns false otherwise.\n */\nfunction _canScrollResizeToFitEdge(\n  target: Rectangle,\n  bounding: Rectangle,\n  targetEdge: RectangleEdge,\n  minimumScrollResizeHeight = 200,\n) {\n  // Only scroll vertically to fit - cannot scroll to fit right or left edges\n  if (targetEdge !== RectangleEdge.bottom && targetEdge !== RectangleEdge.top) {\n    return false;\n  }\n\n  return _getRelativeEdgeDifference(target, bounding, targetEdge) >= minimumScrollResizeHeight;\n}\n\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\nfunction _flipToFit(\n  rect: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  shouldScroll = false,\n  minimumScrollResizeHeight?: number,\n  gap: number = 0,\n): IElementPosition {\n  const directions: RectangleEdge[] = [\n    RectangleEdge.left,\n    RectangleEdge.right,\n    RectangleEdge.bottom,\n    RectangleEdge.top,\n  ];\n  // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n  let currentEstimate = rect;\n  let currentEdge = positionData.targetEdge;\n  let currentAlignment = positionData.alignmentEdge;\n\n  // keep track of least bad option, in case no sides fit\n  let oobDegree;\n  let bestEdge = currentEdge;\n  let bestAlignment = currentAlignment;\n\n  // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n  for (let i = 0; i < 4; i++) {\n    if (_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      // Edge is in bounds, return current estimate\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n      };\n    } else if (shouldScroll && _canScrollResizeToFitEdge(target, bounding, currentEdge, minimumScrollResizeHeight)) {\n      // Scrolling will allow edge to fit, move the estimate currentEdge inside the bounds and return\n      switch (currentEdge) {\n        case RectangleEdge.bottom:\n          currentEstimate.bottom = bounding.bottom;\n          break;\n        case RectangleEdge.top:\n          currentEstimate.top = bounding.top;\n          break;\n      }\n\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n        forcedInBounds: true,\n      };\n    } else {\n      // update least-bad edges\n      const currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n      if (!oobDegree || currentOOBDegree < oobDegree) {\n        oobDegree = currentOOBDegree;\n        bestEdge = currentEdge;\n        bestAlignment = currentAlignment;\n      }\n\n      directions.splice(directions.indexOf(currentEdge), 1);\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n        currentEstimate = _estimatePosition(\n          rect,\n          target,\n          { targetEdge: currentEdge, alignmentEdge: currentAlignment },\n          gap,\n        );\n      }\n    }\n  }\n\n  // nothing fits, use least-bad option\n  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);\n  return {\n    elementRectangle: currentEstimate,\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment,\n  };\n}\n\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\nfunction _flipAlignmentEdge(\n  elementEstimate: IElementPosition,\n  target: Rectangle,\n  gap: number,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;\n  const oppositeEdge = alignmentEdge! * -1;\n  const newEstimate = _estimatePosition(\n    elementRectangle,\n    target,\n    { targetEdge, alignmentEdge: oppositeEdge },\n    gap,\n    coverTarget,\n  );\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge,\n    alignmentEdge: oppositeEdge,\n  };\n}\n\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(\n  element: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  shouldScroll = false,\n  minimumScrollResizeHeight?: number,\n  gap: number = 0,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, alignTargetEdge } = positionData;\n  let elementEstimate: IElementPosition = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge,\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap);\n  }\n  const outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);\n  // if directionalHintFixed is specified, we need to force the target edge to not change\n  // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n  const fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n\n  if (outOfBounds.length > 0) {\n    if (alignTargetEdge) {\n      // The edge opposite to the alignment edge might be out of bounds.\n      // Flip alignment to see if we can get it within bounds.\n      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n        const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n          return flippedElementEstimate;\n        } else {\n          // If the flipped elements edges are still out of bounds, try nudging it.\n          elementEstimate = _alignOutOfBoundsEdges(\n            _getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding),\n            elementEstimate,\n            bounding,\n            fixedEdge,\n          );\n        }\n      } else {\n        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n      }\n    } else {\n      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n    }\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\nfunction _alignOutOfBoundsEdges(\n  outOfBoundsEdges: RectangleEdge[],\n  elementEstimate: IElementPosition,\n  bounding: Rectangle,\n  preserveEdge?: RectangleEdge,\n) {\n  for (const direction of outOfBoundsEdges) {\n    let edgeAttempt;\n\n    // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n    // this is because _alignEdges will move the opposite edge\n    if (preserveEdge && preserveEdge === direction * -1) {\n      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n      elementEstimate.forcedInBounds = true;\n    } else {\n      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n      const inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);\n      // only update estimate if the attempt didn't break out of the opposite bounding edge\n      if (!inBounds) {\n        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n        elementEstimate.forcedInBounds = true;\n      }\n    }\n\n    elementEstimate.elementRectangle = edgeAttempt;\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: number): Rectangle {\n  const { positiveEdge } = _getFlankingEdges(edge);\n  const elementMiddle = _getCenterValue(rect, edge);\n  const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  coverTarget?: boolean,\n): Rectangle {\n  let estimatedElementPosition = new Rectangle(\n    elementToPosition.left,\n    elementToPosition.right,\n    elementToPosition.top,\n    elementToPosition.bottom,\n  );\n  const { alignmentEdge, targetEdge } = positionData;\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget\n    ? _alignEdges(estimatedElementPosition, target, targetEdge, gap)\n    : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);\n  // if no alignment edge is provided it's supposed to be centered.\n  if (!alignmentEdge) {\n    const targetMiddlePoint = _getCenterValue(target, targetEdge);\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge: RectangleEdge): { positiveEdge: RectangleEdge; negativeEdge: RectangleEdge } {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right,\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom,\n    };\n  }\n}\n\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(\n  elementRectangle: Rectangle,\n  returnEdge: RectangleEdge,\n  bounds?: Rectangle,\n): RectangleEdge {\n  if (\n    bounds &&\n    Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\n      Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))\n  ) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\nfunction _isEdgeOnBounds(elementRectangle: Rectangle, edge: RectangleEdge, bounds?: Rectangle): boolean {\n  return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(\n  elementRectangle: Rectangle,\n  hostElement: HTMLElement,\n  targetEdge: RectangleEdge,\n  bounds?: Rectangle,\n  alignmentEdge?: RectangleEdge,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n  forceWithinBounds?: boolean,\n): IPartialIRectangle {\n  const returnValue: IPartialIRectangle = {};\n\n  const hostRect: Rectangle = _getRectangleFromElement(hostElement);\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  let returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n\n  // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n  // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n  // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n  // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n  // in the usual direction\n  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n\n  // if the positioned element will still overflow, return all four edges with in-bounds values\n  if (forceWithinBounds) {\n    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      elementEdge * -1,\n    );\n    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      returnEdge * -1,\n    );\n  }\n\n  return returnValue;\n}\n\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth: number): number {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(\n  directionalHint: DirectionalHint = DirectionalHint.bottomAutoEdge,\n  directionalHintForRTL?: DirectionalHint,\n  previousPositions?: IPositionDirectionalHintData,\n): IPositionDirectionalHintData {\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge,\n    };\n  }\n  const positionInformation: IPositionDirectionalHintData = { ...DirectionalDictionary[directionalHint] };\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n  return positionInformation;\n}\n\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(\n  positionData: IPositionDirectionalHintData,\n  target: Rectangle,\n  boundingRect: Rectangle,\n  coverTarget?: boolean,\n  alignTargetEdge?: boolean,\n): IPositionDirectionalHintData {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge: RectangleEdge, target: Rectangle, boundingRect: Rectangle): RectangleEdge {\n  const targetCenter: number = _getCenterValue(target, targetEdge);\n  const boundingCenter: number = _getCenterValue(boundingRect, targetEdge);\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number,\n  shouldScroll = false,\n  minimumScrollResizeHeight?: number,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const estimatedElementPosition: Rectangle = _estimatePosition(\n    elementToPosition,\n    target,\n    positionData,\n    gap,\n    coverTarget,\n  );\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge,\n    };\n  } else {\n    return _adjustFitWithinBounds(\n      estimatedElementPosition,\n      target,\n      bounding,\n      positionData,\n      shouldScroll,\n      minimumScrollResizeHeight,\n      gap,\n      directionalHintFixed,\n      coverTarget,\n    );\n  }\n}\n\nfunction _finalizeBeakPosition(\n  elementPosition: IElementPositionInfo,\n  positionedBeak: Rectangle,\n  bounds?: Rectangle,\n): ICalloutBeakPositionedInfo {\n  const targetEdge = elementPosition.targetEdge * -1;\n  // The \"host\" element that we will use to help position the beak.\n  const actualElement = new Rectangle(\n    0,\n    elementPosition.elementRectangle.width,\n    0,\n    elementPosition.elementRectangle.height,\n  );\n  const returnValue: IPartialIRectangle = {};\n  const returnEdge = _finalizeReturnEdge(\n    elementPosition.elementRectangle,\n    elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\n    bounds,\n  );\n\n  // only show the beak if the callout is not fully covering the target\n  const beakEdgeDifference = _getRelativeEdgeDifference(\n    elementPosition.elementRectangle,\n    elementPosition.targetRectangle,\n    targetEdge,\n  );\n  const showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n\n  return {\n    elementPosition: { ...returnValue },\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge,\n    hideBeak: !showBeak,\n  };\n}\n\nfunction _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle {\n  const target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);\n  const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n  const elementBounds = new Rectangle(\n    beakWidth / 2,\n    elementPosition.elementRectangle.width - beakWidth / 2,\n    beakWidth / 2,\n    elementPosition.elementRectangle.height - beakWidth / 2,\n  );\n\n  let beakPosition: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\n\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n\n  beakPosition = _centerEdgeToPoint(\n    beakPosition,\n    elementPosition.targetEdge * -1,\n    beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle),\n  );\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element: Element): Rectangle {\n  // eslint-disable-next-line deprecation/deprecation\n  const clientRect: ClientRect = element.getBoundingClientRect();\n\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect: IRectangle): Rectangle {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | Point | Rectangle | undefined): Rectangle {\n  let targetRectangle: Rectangle;\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!(target as MouseEvent).preventDefault) {\n      const ev = target as MouseEvent;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n      // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!(target as Element).getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target as Element);\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      const rectOrPoint: Point & Rectangle = target as Point & Rectangle;\n      // eslint-disable-next-line deprecation/deprecation\n      const left = rectOrPoint.left || rectOrPoint.x;\n      // eslint-disable-next-line deprecation/deprecation\n      const top = rectOrPoint.top || rectOrPoint.y;\n      const right = rectOrPoint.right || left;\n      const bottom = rectOrPoint.bottom || top;\n      targetRectangle = new Rectangle(left, right, top, bottom);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      const outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (const direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(\n  targetRectangle: Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number,\n  bounds: Rectangle,\n  coverTarget?: boolean,\n) {\n  let maxHeight = 0;\n  const directionalHint = DirectionalDictionary[targetEdge];\n\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n  const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(\n  props: IPositionProps,\n  elementToPosition: HTMLElement,\n  boundingRect: Rectangle,\n  previousPositions?: IPositionedData,\n  shouldScroll = false,\n  minimumScrollResizeHeight?: number,\n): IElementPositionInfo {\n  const gap: number = props.gapSpace ? props.gapSpace : 0;\n  const targetRect: Rectangle = _getTargetRect(boundingRect, props.target);\n  const positionData: IPositionDirectionalHintData = _getAlignmentData(\n    _getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions)!,\n    targetRect,\n    boundingRect,\n    props.coverTarget,\n    props.alignTargetEdge,\n  );\n  const positionedElement: IElementPosition = _positionElementWithinBounds(\n    _getRectangleFromElement(elementToPosition),\n    targetRect,\n    boundingRect,\n    positionData,\n    gap,\n    shouldScroll,\n    minimumScrollResizeHeight,\n    props.directionalHintFixed,\n    props.coverTarget,\n  );\n  return { ...positionedElement, targetRectangle: targetRect };\n}\n\nfunction _finalizePositionData(\n  positionedElement: IElementPosition,\n  hostElement: HTMLElement,\n  bounds?: Rectangle,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n): IPositionedData {\n  const finalizedElement: IPartialIRectangle = _finalizeElementPosition(\n    positionedElement.elementRectangle,\n    hostElement,\n    positionedElement.targetEdge,\n    bounds,\n    positionedElement.alignmentEdge,\n    coverTarget,\n    doNotFinalizeReturnEdge,\n    positionedElement.forcedInBounds,\n  );\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge,\n  };\n}\n\nfunction _positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n  win?: Window,\n): IPositionedData {\n  const theWin = win ?? getWindow()!;\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n  const positionedElement: IElementPosition = _positionElementRelative(\n    props,\n    elementToPosition,\n    boundingRect,\n    previousPositions,\n  );\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _calculateGapSpace(isBeakVisible: boolean | undefined, beakWidth = 0, gapSpace = 0): number {\n  return _calculateActualBeakWidthInPixels(isBeakVisible ? beakWidth : 0) / 2 + gapSpace;\n}\n\nfunction _positionCallout(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  shouldScroll = false,\n  minimumScrollResizeHeight?: number,\n  doNotFinalizeReturnEdge?: boolean,\n  win?: Window,\n): ICalloutPositionedInfo {\n  const theWin = win ?? getWindow()!;\n  const beakWidth: number = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  const gap = _calculateGapSpace(props.isBeakVisible, props.beakWidth, props.gapSpace);\n  const positionProps: IPositionProps = props;\n  positionProps.gapSpace = gap;\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n\n  const positionedElement: IElementPositionInfo = _positionElementRelative(\n    positionProps,\n    callout,\n    boundingRect,\n    previousPositions,\n    shouldScroll,\n    minimumScrollResizeHeight,\n  );\n\n  const beakPositioned: Rectangle = _positionBeak(beakWidth, positionedElement);\n  const finalizedBeakPosition: ICalloutBeakPositionedInfo = _finalizeBeakPosition(\n    positionedElement,\n    beakPositioned,\n    boundingRect,\n  );\n\n  return {\n    ..._finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge),\n    beakPosition: finalizedBeakPosition,\n  };\n}\n\nfunction _positionCard(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  win?: Window,\n): ICalloutPositionedInfo {\n  const theWin = win ?? getWindow()!;\n  return _positionCallout(props, hostElement, callout, previousPositions, false, undefined, true, theWin);\n}\n\nfunction _getRectangleFromTarget(target: Element | MouseEvent | Point | Rectangle): Rectangle {\n  const mouseTarget: MouseEvent = target as MouseEvent;\n  const elementTarget: Element = target as Element;\n  const rectOrPointTarget: Point & Rectangle = target as Point & Rectangle;\n  let targetRect: Rectangle;\n\n  // eslint-disable-next-line deprecation/deprecation\n  const left = rectOrPointTarget.left ?? rectOrPointTarget.x;\n  // eslint-disable-next-line deprecation/deprecation\n  const top = rectOrPointTarget.top ?? rectOrPointTarget.y;\n  const right = rectOrPointTarget.right ?? left;\n  const bottom = rectOrPointTarget.bottom ?? top;\n\n  // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, right, top, bottom);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return targetRect;\n}\n// END PRIVATE FUNCTIONS\n\nexport const __positioningTestPackage = {\n  _finalizePositionData,\n  _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds,\n  _positionBeak,\n  _getPositionData,\n  _getMaxHeightFromTargetRectangle,\n};\n\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n  win?: Window,\n): IPositionedData {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions, win);\n}\n\nexport function positionCallout(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  shouldScroll?: boolean,\n  minimumScrollResizeHeight?: number,\n  win?: Window,\n): ICalloutPositionedInfo {\n  return _positionCallout(\n    props,\n    hostElement,\n    elementToPosition,\n    previousPositions,\n    shouldScroll,\n    minimumScrollResizeHeight,\n    undefined,\n    win,\n  );\n}\n\nexport function positionCard(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  win?: Window,\n): ICalloutPositionedInfo {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions, win);\n}\n\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(\n  target: Element | MouseEvent | Point | Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number = 0,\n  bounds?: IRectangle,\n  coverTarget?: boolean,\n  win?: Window,\n): number {\n  const theWin = win ?? getWindow()!;\n  const targetRect = _getRectangleFromTarget(target);\n  const boundingRectangle = bounds\n    ? _getRectangleFromIRect(bounds)\n    : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge: RectangleEdge): RectangleEdge {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  let segments = undefined;\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  }\n\n  // Identify if we're dealing with single screen scenarios.\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight,\n    };\n  }\n\n  // Logic for determining dual screen scenarios.\n  let x: number | undefined = 0;\n  let y: number | undefined = 0;\n\n  // If the target is an Element get coordinates for its center.\n  if (target !== null && !!(target as Element).getBoundingClientRect) {\n    const clientRect = (target as Element).getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  }\n  // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = (target as Point).left || (target as MouseEvent | Point).x;\n    // eslint-disable-next-line deprecation/deprecation\n    y = (target as Point).top || (target as MouseEvent | Point).y;\n  }\n\n  let bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };\n\n  // Define which window segment are the coordinates in and calculate bounds based on that.\n  for (const segment of segments) {\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height,\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}\n\nexport function calculateGapSpace(\n  isBeakVisible: boolean | undefined,\n  beakWidth: number | undefined,\n  gapSpace: number | undefined,\n): number {\n  return _calculateGapSpace(isBeakVisible, beakWidth, gapSpace);\n}\n\nexport function getRectangleFromTarget(target: Element | MouseEvent | Point | Rectangle): Rectangle {\n  return _getRectangleFromTarget(target);\n}\n"],"mappings":";;AAAA,SAASA,eAAe,QAAQ,8BAA8B;AAC9D,SAASC,iBAAiB,EAAEC,MAAM,EAAEC,SAAS,QAAQ,iBAAiB;AACtE,SAASC,aAAa,QAAQ,qBAAqB;AACnD,SAASC,SAAS,QAAQ,iBAAiB;AAY3C,SAASC,mBAAmBA,CAC1BC,UAAyB,EACzBC,aAA6B,EAC7BC,MAAgB;EAEhB,OAAO;IACLF,UAAU,EAAAA,UAAA;IACVC,aAAa,EAAAA,aAAA;IACbC,MAAM,EAAAA;GACP;AACH;AAEA;AACA,IAAMC,qBAAqB,IAAAC,EAAA,OACzBA,EAAA,CAACX,eAAe,CAACY,WAAW,IAAGN,mBAAmB,CAACF,aAAa,CAACS,GAAG,EAAET,aAAa,CAACU,IAAI,CAAC,EACzFH,EAAA,CAACX,eAAe,CAACe,SAAS,IAAGT,mBAAmB,CAACF,aAAa,CAACS,GAAG,CAAC,EACnEF,EAAA,CAACX,eAAe,CAACgB,YAAY,IAAGV,mBAAmB,CAACF,aAAa,CAACS,GAAG,EAAET,aAAa,CAACa,KAAK,CAAC,EAC3FN,EAAA,CAACX,eAAe,CAACkB,WAAW,IAAGZ,mBAAmB,CAACF,aAAa,CAACS,GAAG,EAAEM,SAAS,EAAE,IAAI,CAAC,EACtFR,EAAA,CAACX,eAAe,CAACoB,cAAc,IAAGd,mBAAmB,CAACF,aAAa,CAACiB,MAAM,EAAEjB,aAAa,CAACU,IAAI,CAAC,EAC/FH,EAAA,CAACX,eAAe,CAACsB,YAAY,IAAGhB,mBAAmB,CAACF,aAAa,CAACiB,MAAM,CAAC,EACzEV,EAAA,CAACX,eAAe,CAACuB,eAAe,IAAGjB,mBAAmB,CAACF,aAAa,CAACiB,MAAM,EAAEjB,aAAa,CAACa,KAAK,CAAC,EACjGN,EAAA,CAACX,eAAe,CAACwB,cAAc,IAAGlB,mBAAmB,CAACF,aAAa,CAACiB,MAAM,EAAEF,SAAS,EAAE,IAAI,CAAC,EAC5FR,EAAA,CAACX,eAAe,CAACyB,WAAW,IAAGnB,mBAAmB,CAACF,aAAa,CAACU,IAAI,EAAEV,aAAa,CAACS,GAAG,CAAC,EACzFF,EAAA,CAACX,eAAe,CAAC0B,UAAU,IAAGpB,mBAAmB,CAACF,aAAa,CAACU,IAAI,CAAC,EACrEH,EAAA,CAACX,eAAe,CAAC2B,cAAc,IAAGrB,mBAAmB,CAACF,aAAa,CAACU,IAAI,EAAEV,aAAa,CAACiB,MAAM,CAAC,EAC/FV,EAAA,CAACX,eAAe,CAAC4B,YAAY,IAAGtB,mBAAmB,CAACF,aAAa,CAACa,KAAK,EAAEb,aAAa,CAACS,GAAG,CAAC,EAC3FF,EAAA,CAACX,eAAe,CAAC6B,WAAW,IAAGvB,mBAAmB,CAACF,aAAa,CAACa,KAAK,CAAC,EACvEN,EAAA,CAACX,eAAe,CAAC8B,eAAe,IAAGxB,mBAAmB,CAACF,aAAa,CAACa,KAAK,EAAEb,aAAa,CAACiB,MAAM,CAAC,E,GAClG;AAyBD,SAASU,wBAAwBA,CAACC,IAAe,EAAEC,YAAuB;EACxE,IAAID,IAAI,CAACnB,GAAG,GAAGoB,YAAY,CAACpB,GAAG,EAAE;IAC/B,OAAO,KAAK;;EAEd,IAAImB,IAAI,CAACX,MAAM,GAAGY,YAAY,CAACZ,MAAM,EAAE;IACrC,OAAO,KAAK;;EAEd,IAAIW,IAAI,CAAClB,IAAI,GAAGmB,YAAY,CAACnB,IAAI,EAAE;IACjC,OAAO,KAAK;;EAEd,IAAIkB,IAAI,CAACf,KAAK,GAAGgB,YAAY,CAAChB,KAAK,EAAE;IACnC,OAAO,KAAK;;EAGd,OAAO,IAAI;AACb;AAEA;;;;AAIA,SAASiB,oBAAoBA,CAACF,IAAe,EAAEC,YAAuB;EACpE,IAAME,WAAW,GAAoB,EAAE;EAEvC,IAAIH,IAAI,CAACnB,GAAG,GAAGoB,YAAY,CAACpB,GAAG,EAAE;IAC/BsB,WAAW,CAACC,IAAI,CAAChC,aAAa,CAACS,GAAG,CAAC;;EAErC,IAAImB,IAAI,CAACX,MAAM,GAAGY,YAAY,CAACZ,MAAM,EAAE;IACrCc,WAAW,CAACC,IAAI,CAAChC,aAAa,CAACiB,MAAM,CAAC;;EAExC,IAAIW,IAAI,CAAClB,IAAI,GAAGmB,YAAY,CAACnB,IAAI,EAAE;IACjCqB,WAAW,CAACC,IAAI,CAAChC,aAAa,CAACU,IAAI,CAAC;;EAEtC,IAAIkB,IAAI,CAACf,KAAK,GAAGgB,YAAY,CAAChB,KAAK,EAAE;IACnCkB,WAAW,CAACC,IAAI,CAAChC,aAAa,CAACa,KAAK,CAAC;;EAGvC,OAAOkB,WAAW;AACpB;AAEA,SAASE,aAAaA,CAACL,IAAe,EAAEM,IAAmB;EACzD,OAAQN,IAAY,CAAC5B,aAAa,CAACkC,IAAI,CAAC,CAAW;AACrD;AAEA,SAASC,aAAaA,CAACP,IAAe,EAAEM,IAAmB,EAAEE,KAAa;EACvER,IAAY,CAAC5B,aAAa,CAACkC,IAAI,CAAC,CAAC,GAAGE,KAAK;EAC1C,OAAOR,IAAI;AACb;AAEA;;;;;AAKA,SAASS,eAAeA,CAACT,IAAe,EAAEM,IAAmB;EAC3D,IAAMI,KAAK,GAAGC,iBAAiB,CAACL,IAAI,CAAC;EACrC,OAAO,CAACD,aAAa,CAACL,IAAI,EAAEU,KAAK,CAACE,YAAY,CAAC,GAAGP,aAAa,CAACL,IAAI,EAAEU,KAAK,CAACG,YAAY,CAAC,IAAI,CAAC;AAChG;AAEA;;;;;;;;;;;AAWA,SAASC,qBAAqBA,CAACR,IAAmB,EAAEE,KAAa;EAC/D,IAAIF,IAAI,GAAG,CAAC,EAAE;IACZ,OAAOE,KAAK;GACb,MAAM;IACL,OAAOA,KAAK,GAAG,CAAC,CAAC;;AAErB;AAEA,SAASO,yBAAyBA,CAACT,IAAmB,EAAEN,IAAe;EACrE,OAAOc,qBAAqB,CAACR,IAAI,EAAED,aAAa,CAACL,IAAI,EAAEM,IAAI,CAAC,CAAC;AAC/D;AAEA,SAASU,0BAA0BA,CAAChB,IAAe,EAAEiB,QAAmB,EAAEX,IAAmB;EAC3F,IAAMY,cAAc,GAAGb,aAAa,CAACL,IAAI,EAAEM,IAAI,CAAC,GAAGD,aAAa,CAACY,QAAQ,EAAEX,IAAI,CAAC;EAChF,OAAOQ,qBAAqB,CAACR,IAAI,EAAEY,cAAc,CAAC;AACpD;AAEA;;;;;AAKA,SAASC,SAASA,CAACnB,IAAe,EAAEM,IAAmB,EAAEc,QAAgB,EAAEC,YAAmB;EAAnB,IAAAA,YAAA;IAAAA,YAAA,OAAmB;EAAA;EAC5F,IAAMC,UAAU,GAAGjB,aAAa,CAACL,IAAI,EAAEM,IAAI,CAAC,GAAGc,QAAQ;EACvD,IAAIG,UAAU,GAAGhB,aAAa,CAACP,IAAI,EAAEM,IAAI,EAAEc,QAAQ,CAAC;EACpD,IAAIC,YAAY,EAAE;IAChBE,UAAU,GAAGhB,aAAa,CAACP,IAAI,EAAEM,IAAI,GAAG,CAAC,CAAC,EAAED,aAAa,CAACL,IAAI,EAAEM,IAAI,GAAG,CAAC,CAAC,CAAC,GAAGgB,UAAU,CAAC;;EAE1F,OAAOC,UAAU;AACnB;AAEA;;;AAGA,SAASC,WAAWA,CAACxB,IAAe,EAAEyB,MAAiB,EAAEnB,IAAmB,EAAEoB,GAAe;EAAf,IAAAA,GAAA;IAAAA,GAAA,IAAe;EAAA;EAC3F,OAAOP,SAAS,CAACnB,IAAI,EAAEM,IAAI,EAAED,aAAa,CAACoB,MAAM,EAAEnB,IAAI,CAAC,GAAGQ,qBAAqB,CAACR,IAAI,EAAEoB,GAAG,CAAC,CAAC;AAC9F;AAEA;;;;AAIA,SAASC,mBAAmBA,CAC1B3B,IAAe,EACfyB,MAAiB,EACjBlD,UAAyB,EACzBmD,GAAe;EAAf,IAAAA,GAAA;IAAAA,GAAA,IAAe;EAAA;EAEf,IAAME,YAAY,GAAGrD,UAAU,GAAG,CAAC,CAAC;EACpC,IAAMsD,WAAW,GAAGf,qBAAqB,CAACc,YAAY,EAAEF,GAAG,CAAC;EAC5D,OAAOP,SAAS,CAACnB,IAAI,EAAEzB,UAAU,GAAG,CAAC,CAAC,EAAE8B,aAAa,CAACoB,MAAM,EAAElD,UAAU,CAAC,GAAGsD,WAAW,CAAC;AAC1F;AAEA;;;AAGA,SAASC,eAAeA,CAAC9B,IAAe,EAAE+B,MAAiB,EAAEzB,IAAmB;EAC9E,IAAM0B,iBAAiB,GAAGjB,yBAAyB,CAACT,IAAI,EAAEN,IAAI,CAAC;EAC/D,OAAOgC,iBAAiB,GAAGjB,yBAAyB,CAACT,IAAI,EAAEyB,MAAM,CAAC;AACpE;AAEA;;;;;AAKA,SAASE,qBAAqBA,CAACjC,IAAe,EAAE+B,MAAiB;EAC/D,IAAMG,aAAa,GAAGhC,oBAAoB,CAACF,IAAI,EAAE+B,MAAM,CAAC;EACxD,IAAII,KAAK,GAAG,CAAC;EACb,KAAmB,IAAAC,EAAA,IAAa,EAAbC,eAAA,GAAAH,aAAa,EAAbE,EAAA,GAAAC,eAAA,CAAAC,MAAa,EAAbF,EAAA,EAAa,EAAE;IAA7B,IAAM9B,IAAI,GAAA+B,eAAA,CAAAD,EAAA;IACbD,KAAK,IAAII,IAAA,CAAAC,GAAA,CAAAxB,0BAA0B,CAAChB,IAAI,EAAE+B,MAAM,EAAEzB,IAAI,CAAC,EAAI,CAAC;;EAG9D,OAAO6B,KAAK;AACd;AAEA;;;;;AAKA,SAASM,yBAAyBA,CAChChB,MAAiB,EACjBiB,QAAmB,EACnBnE,UAAyB,EACzBoE,yBAA+B;EAA/B,IAAAA,yBAAA;IAAAA,yBAAA,MAA+B;EAAA;EAE/B;EACA,IAAIpE,UAAU,KAAKH,aAAa,CAACiB,MAAM,IAAId,UAAU,KAAKH,aAAa,CAACS,GAAG,EAAE;IAC3E,OAAO,KAAK;;EAGd,OAAOmC,0BAA0B,CAACS,MAAM,EAAEiB,QAAQ,EAAEnE,UAAU,CAAC,IAAIoE,yBAAyB;AAC9F;AAEA;;;;AAIA,SAASC,UAAUA,CACjB5C,IAAe,EACfyB,MAAiB,EACjBiB,QAAmB,EACnBG,YAA0C,EAC1CC,YAAoB,EACpBH,yBAAkC,EAClCjB,GAAe;EAFf,IAAAoB,YAAA;IAAAA,YAAA,QAAoB;EAAA;EAEpB,IAAApB,GAAA;IAAAA,GAAA,IAAe;EAAA;EAEf,IAAMqB,UAAU,GAAoB,CAClC3E,aAAa,CAACU,IAAI,EAClBV,aAAa,CAACa,KAAK,EACnBb,aAAa,CAACiB,MAAM,EACpBjB,aAAa,CAACS,GAAG,CAClB;EACD;EACA,IAAIX,MAAM,EAAE,EAAE;IACZ6E,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACnBA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;;EAErB,IAAIC,eAAe,GAAGhD,IAAI;EAC1B,IAAIiD,WAAW,GAAGJ,YAAY,CAACtE,UAAU;EACzC,IAAI2E,gBAAgB,GAAGL,YAAY,CAACrE,aAAa;EAEjD;EACA,IAAI2E,SAAS;EACb,IAAIC,QAAQ,GAAGH,WAAW;EAC1B,IAAII,aAAa,GAAGH,gBAAgB;EAEpC;EACA;EACA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1B,IAAIxB,eAAe,CAACkB,eAAe,EAAEN,QAAQ,EAAEO,WAAW,CAAC,EAAE;MAC3D;MACA,OAAO;QACLM,gBAAgB,EAAEP,eAAe;QACjCzE,UAAU,EAAE0E,WAAW;QACvBzE,aAAa,EAAE0E;OAChB;KACF,MAAM,IAAIJ,YAAY,IAAIL,yBAAyB,CAAChB,MAAM,EAAEiB,QAAQ,EAAEO,WAAW,EAAEN,yBAAyB,CAAC,EAAE;MAC9G;MACA,QAAQM,WAAW;QACjB,KAAK7E,aAAa,CAACiB,MAAM;UACvB2D,eAAe,CAAC3D,MAAM,GAAGqD,QAAQ,CAACrD,MAAM;UACxC;QACF,KAAKjB,aAAa,CAACS,GAAG;UACpBmE,eAAe,CAACnE,GAAG,GAAG6D,QAAQ,CAAC7D,GAAG;UAClC;;MAGJ,OAAO;QACL0E,gBAAgB,EAAEP,eAAe;QACjCzE,UAAU,EAAE0E,WAAW;QACvBzE,aAAa,EAAE0E,gBAAgB;QAC/BM,cAAc,EAAE;OACjB;KACF,MAAM;MACL;MACA,IAAMC,gBAAgB,GAAGxB,qBAAqB,CAACe,eAAe,EAAEN,QAAQ,CAAC;MACzE,IAAI,CAACS,SAAS,IAAIM,gBAAgB,GAAGN,SAAS,EAAE;QAC9CA,SAAS,GAAGM,gBAAgB;QAC5BL,QAAQ,GAAGH,WAAW;QACtBI,aAAa,GAAGH,gBAAgB;;MAGlCH,UAAU,CAACW,MAAM,CAACX,UAAU,CAACY,OAAO,CAACV,WAAW,CAAC,EAAE,CAAC,CAAC;MACrD,IAAIF,UAAU,CAACT,MAAM,GAAG,CAAC,EAAE;QACzB,IAAIS,UAAU,CAACY,OAAO,CAACV,WAAW,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;UAC7CA,WAAW,GAAGA,WAAW,GAAG,CAAC,CAAC;SAC/B,MAAM;UACLC,gBAAgB,GAAGD,WAAW;UAC9BA,WAAW,GAAGF,UAAU,CAACa,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEvCZ,eAAe,GAAGa,iBAAiB,CACjC7D,IAAI,EACJyB,MAAM,EACN;UAAElD,UAAU,EAAE0E,WAAW;UAAEzE,aAAa,EAAE0E;QAAgB,CAAE,EAC5DxB,GAAG,CACJ;;;;EAKP;EACAsB,eAAe,GAAGa,iBAAiB,CAAC7D,IAAI,EAAEyB,MAAM,EAAE;IAAElD,UAAU,EAAE6E,QAAQ;IAAE5E,aAAa,EAAE6E;EAAa,CAAE,EAAE3B,GAAG,CAAC;EAC9G,OAAO;IACL6B,gBAAgB,EAAEP,eAAe;IACjCzE,UAAU,EAAE6E,QAAQ;IACpB5E,aAAa,EAAE6E;GAChB;AACH;AAEA;;;;AAIA,SAASS,kBAAkBA,CACzBC,eAAiC,EACjCtC,MAAiB,EACjBC,GAAW,EACXsC,WAAqB;EAEb,IAAAxF,aAAa,GAAmCuF,eAAe,CAAAvF,aAAlD;IAAED,UAAU,GAAuBwF,eAAe,CAAAxF,UAAtC;IAAEgF,gBAAgB,GAAKQ,eAAe,CAAAR,gBAApB;EACnD,IAAM3B,YAAY,GAAGpD,aAAc,GAAG,CAAC,CAAC;EACxC,IAAMyF,WAAW,GAAGJ,iBAAiB,CACnCN,gBAAgB,EAChB9B,MAAM,EACN;IAAElD,UAAU,EAAAA,UAAA;IAAEC,aAAa,EAAEoD;EAAY,CAAE,EAC3CF,GAAG,EACHsC,WAAW,CACZ;EAED,OAAO;IACLT,gBAAgB,EAAEU,WAAW;IAC7B1F,UAAU,EAAAA,UAAA;IACVC,aAAa,EAAEoD;GAChB;AACH;AAEA;;;;AAIA,SAASsC,sBAAsBA,CAC7BC,OAAkB,EAClB1C,MAAiB,EACjBiB,QAAmB,EACnBG,YAA0C,EAC1CC,YAAoB,EACpBH,yBAAkC,EAClCjB,GAAe,EACf0C,oBAA8B,EAC9BJ,WAAqB;EAJrB,IAAAlB,YAAA;IAAAA,YAAA,QAAoB;EAAA;EAEpB,IAAApB,GAAA;IAAAA,GAAA,IAAe;EAAA;EAIP,IAAAlD,aAAa,GAAsBqE,YAAY,CAAArE,aAAlC;IAAE6F,eAAe,GAAKxB,YAAY,CAAAwB,eAAjB;EACtC,IAAIN,eAAe,GAAqB;IACtCR,gBAAgB,EAAEY,OAAO;IACzB5F,UAAU,EAAEsE,YAAY,CAACtE,UAAU;IACnCC,aAAa,EAAAA;GACd;EAED,IAAI,CAAC4F,oBAAoB,IAAI,CAACJ,WAAW,EAAE;IACzCD,eAAe,GAAGnB,UAAU,CAACuB,OAAO,EAAE1C,MAAM,EAAEiB,QAAQ,EAAEG,YAAY,EAAEC,YAAY,EAAEH,yBAAyB,EAAEjB,GAAG,CAAC;;EAErH,IAAMvB,WAAW,GAAGD,oBAAoB,CAAC6D,eAAe,CAACR,gBAAgB,EAAEb,QAAQ,CAAC;EACpF;EACA;EACA,IAAM4B,SAAS,GAAGF,oBAAoB,GAAG,CAACL,eAAe,CAACxF,UAAU,GAAGY,SAAS;EAEhF,IAAIgB,WAAW,CAACmC,MAAM,GAAG,CAAC,EAAE;IAC1B,IAAI+B,eAAe,EAAE;MACnB;MACA;MACA,IAAIN,eAAe,CAACvF,aAAa,IAAI2B,WAAW,CAACwD,OAAO,CAACI,eAAe,CAACvF,aAAa,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;QACjG,IAAM+F,sBAAsB,GAAGT,kBAAkB,CAACC,eAAe,EAAEtC,MAAM,EAAEC,GAAG,EAAEsC,WAAW,CAAC;QAC5F,IAAIjE,wBAAwB,CAACwE,sBAAsB,CAAChB,gBAAgB,EAAEb,QAAQ,CAAC,EAAE;UAC/E,OAAO6B,sBAAsB;SAC9B,MAAM;UACL;UACAR,eAAe,GAAGS,sBAAsB,CACtCtE,oBAAoB,CAACqE,sBAAsB,CAAChB,gBAAgB,EAAEb,QAAQ,CAAC,EACvEqB,eAAe,EACfrB,QAAQ,EACR4B,SAAS,CACV;;OAEJ,MAAM;QACLP,eAAe,GAAGS,sBAAsB,CAACrE,WAAW,EAAE4D,eAAe,EAAErB,QAAQ,EAAE4B,SAAS,CAAC;;KAE9F,MAAM;MACLP,eAAe,GAAGS,sBAAsB,CAACrE,WAAW,EAAE4D,eAAe,EAAErB,QAAQ,EAAE4B,SAAS,CAAC;;;EAI/F,OAAOP,eAAe;AACxB;AAEA;;;;;;;AAOA,SAASS,sBAAsBA,CAC7BC,gBAAiC,EACjCV,eAAiC,EACjCrB,QAAmB,EACnBgC,YAA4B;EAE5B,KAAwB,IAAAtC,EAAA,IAAgB,EAAhBuC,kBAAA,GAAAF,gBAAgB,EAAhBrC,EAAA,GAAAuC,kBAAA,CAAArC,MAAgB,EAAhBF,EAAA,EAAgB,EAAE;IAArC,IAAMwC,SAAS,GAAAD,kBAAA,CAAAvC,EAAA;IAClB,IAAIyC,WAAW;IAEf;IACA;IACA,IAAIH,YAAY,IAAIA,YAAY,KAAKE,SAAS,GAAG,CAAC,CAAC,EAAE;MACnDC,WAAW,GAAG1D,SAAS,CAAC4C,eAAe,CAACR,gBAAgB,EAAEqB,SAAS,EAAEvE,aAAa,CAACqC,QAAQ,EAAEkC,SAAS,CAAC,EAAE,KAAK,CAAC;MAC/Gb,eAAe,CAACP,cAAc,GAAG,IAAI;KACtC,MAAM;MACLqB,WAAW,GAAGrD,WAAW,CAACuC,eAAe,CAACR,gBAAgB,EAAEb,QAAQ,EAAEkC,SAAS,CAAC;MAChF,IAAME,QAAQ,GAAGhD,eAAe,CAAC+C,WAAW,EAAEnC,QAAQ,EAAEkC,SAAS,GAAG,CAAC,CAAC,CAAC;MACvE;MACA,IAAI,CAACE,QAAQ,EAAE;QACbD,WAAW,GAAG1D,SAAS,CAAC0D,WAAW,EAAED,SAAS,GAAG,CAAC,CAAC,EAAEvE,aAAa,CAACqC,QAAQ,EAAEkC,SAAS,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;QACpGb,eAAe,CAACP,cAAc,GAAG,IAAI;;;IAIzCO,eAAe,CAACR,gBAAgB,GAAGsB,WAAW;;EAGhD,OAAOd,eAAe;AACxB;AAEA;;;;;AAKA,SAASgB,kBAAkBA,CAAC/E,IAAe,EAAEM,IAAmB,EAAE0E,KAAa;EACrE,IAAApE,YAAY,GAAKD,iBAAiB,CAACL,IAAI,CAAC,CAAAM,YAA5B;EACpB,IAAMqE,aAAa,GAAGxE,eAAe,CAACT,IAAI,EAAEM,IAAI,CAAC;EACjD,IAAM4E,gBAAgB,GAAGD,aAAa,GAAG5E,aAAa,CAACL,IAAI,EAAEY,YAAY,CAAC;EAC1E,OAAOO,SAAS,CAACnB,IAAI,EAAEY,YAAY,EAAEoE,KAAK,GAAGE,gBAAgB,CAAC;AAChE;AAEA;;;;AAIA,SAASrB,iBAAiBA,CACxBsB,iBAA4B,EAC5B1D,MAAiB,EACjBoB,YAA0C,EAC1CnB,GAAe,EACfsC,WAAqB;EADrB,IAAAtC,GAAA;IAAAA,GAAA,IAAe;EAAA;EAGf,IAAI0D,wBAAwB,GAAG,IAAI/G,SAAS,CAC1C8G,iBAAiB,CAACrG,IAAI,EACtBqG,iBAAiB,CAAClG,KAAK,EACvBkG,iBAAiB,CAACtG,GAAG,EACrBsG,iBAAiB,CAAC9F,MAAM,CACzB;EACO,IAAAb,aAAa,GAAiBqE,YAAY,CAAArE,aAA7B;IAAED,UAAU,GAAKsE,YAAY,CAAAtE,UAAjB;EACjC,IAAM8G,WAAW,GAAGrB,WAAW,GAAGzF,UAAU,GAAGA,UAAU,GAAG,CAAC,CAAC;EAC9D6G,wBAAwB,GAAGpB,WAAW,GAClCxC,WAAW,CAAC4D,wBAAwB,EAAE3D,MAAM,EAAElD,UAAU,EAAEmD,GAAG,CAAC,GAC9DC,mBAAmB,CAACyD,wBAAwB,EAAE3D,MAAM,EAAElD,UAAU,EAAEmD,GAAG,CAAC;EAC1E;EACA,IAAI,CAAClD,aAAa,EAAE;IAClB,IAAM8G,iBAAiB,GAAG7E,eAAe,CAACgB,MAAM,EAAElD,UAAU,CAAC;IAC7D6G,wBAAwB,GAAGL,kBAAkB,CAACK,wBAAwB,EAAEC,WAAW,EAAEC,iBAAiB,CAAC;GACxG,MAAM;IACLF,wBAAwB,GAAG5D,WAAW,CAAC4D,wBAAwB,EAAE3D,MAAM,EAAEjD,aAAa,CAAC;;EAGzF,OAAO4G,wBAAwB;AACjC;AAEA;;;;AAIA,SAASzE,iBAAiBA,CAACL,IAAmB;EAC5C,IAAIA,IAAI,KAAKlC,aAAa,CAACS,GAAG,IAAIyB,IAAI,KAAKlC,aAAa,CAACiB,MAAM,EAAE;IAC/D,OAAO;MACLuB,YAAY,EAAExC,aAAa,CAACU,IAAI;MAChC+B,YAAY,EAAEzC,aAAa,CAACa;KAC7B;GACF,MAAM;IACL,OAAO;MACL2B,YAAY,EAAExC,aAAa,CAACS,GAAG;MAC/BgC,YAAY,EAAEzC,aAAa,CAACiB;KAC7B;;AAEL;AAEA;;;;AAIA,SAASkG,mBAAmBA,CAC1BhC,gBAA2B,EAC3BiC,UAAyB,EACzBzD,MAAkB;EAElB,IACEA,MAAM,IACNQ,IAAI,CAACkD,GAAG,CAACzE,0BAA0B,CAACuC,gBAAgB,EAAExB,MAAM,EAAEyD,UAAU,CAAC,CAAC,GACxEjD,IAAI,CAACkD,GAAG,CAACzE,0BAA0B,CAACuC,gBAAgB,EAAExB,MAAM,EAAEyD,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,EACjF;IACA,OAAOA,UAAU,GAAG,CAAC,CAAC;;EAGxB,OAAOA,UAAU;AACnB;AAEA;;;;;;;AAOA,SAASE,eAAeA,CAACnC,gBAA2B,EAAEjD,IAAmB,EAAEyB,MAAkB;EAC3F,OAAOA,MAAM,KAAK5C,SAAS,IAAIkB,aAAa,CAACkD,gBAAgB,EAAEjD,IAAI,CAAC,KAAKD,aAAa,CAAC0B,MAAM,EAAEzB,IAAI,CAAC;AACtG;AAEA;;;;;;;AAOA,SAASqF,wBAAwBA,CAC/BpC,gBAA2B,EAC3BqC,WAAwB,EACxBrH,UAAyB,EACzBwD,MAAkB,EAClBvD,aAA6B,EAC7BwF,WAAqB,EACrB6B,uBAAiC,EACjCC,iBAA2B;EAE3B,IAAMC,WAAW,GAAuB,EAAE;EAE1C,IAAM9E,QAAQ,GAAc+E,wBAAwB,CAACJ,WAAW,CAAC;EACjE,IAAMP,WAAW,GAAGrB,WAAW,GAAGzF,UAAU,GAAGA,UAAU,GAAG,CAAC,CAAC;EAC9D,IAAIiH,UAAU,GAAGhH,aAAa,GAAGA,aAAa,GAAGmC,iBAAiB,CAACpC,UAAU,CAAC,CAACqC,YAAY;EAE3F;EACA;EACA;EACA;EACA;EACA,IAAI,CAACiF,uBAAuB,IAAIH,eAAe,CAACnC,gBAAgB,EAAE0C,eAAe,CAACT,UAAU,CAAC,EAAEzD,MAAM,CAAC,EAAE;IACtGyD,UAAU,GAAGD,mBAAmB,CAAChC,gBAAgB,EAAEiC,UAAU,EAAEzD,MAAM,CAAC;;EAGxEgE,WAAW,CAAC3H,aAAa,CAACiH,WAAW,CAAC,CAAC,GAAGrE,0BAA0B,CAACuC,gBAAgB,EAAEtC,QAAQ,EAAEoE,WAAW,CAAC;EAC7GU,WAAW,CAAC3H,aAAa,CAACoH,UAAU,CAAC,CAAC,GAAGxE,0BAA0B,CAACuC,gBAAgB,EAAEtC,QAAQ,EAAEuE,UAAU,CAAC;EAE3G;EACA,IAAIM,iBAAiB,EAAE;IACrBC,WAAW,CAAC3H,aAAa,CAACiH,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGrE,0BAA0B,CACvEuC,gBAAgB,EAChBtC,QAAQ,EACRoE,WAAW,GAAG,CAAC,CAAC,CACjB;IACDU,WAAW,CAAC3H,aAAa,CAACoH,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGxE,0BAA0B,CACtEuC,gBAAgB,EAChBtC,QAAQ,EACRuE,UAAU,GAAG,CAAC,CAAC,CAChB;;EAGH,OAAOO,WAAW;AACpB;AAEA;AACA;AACA;AACA,SAASG,iCAAiCA,CAACC,SAAiB;EAC1D,OAAO5D,IAAI,CAAC6D,IAAI,CAACD,SAAS,GAAGA,SAAS,GAAG,CAAC,CAAC;AAC7C;AAEA;;;;;;;;AAQA,SAASE,gBAAgBA,CACvBC,eAAiE,EACjEC,qBAAuC,EACvCC,iBAAgD;EAFhD,IAAAF,eAAA;IAAAA,eAAA,GAAmCtI,eAAe,CAACwB,cAAc;EAAA;EAIjE,IAAIgH,iBAAiB,EAAE;IACrB,OAAO;MACLhI,aAAa,EAAEgI,iBAAiB,CAAChI,aAAa;MAC9CC,MAAM,EAAE+H,iBAAiB,CAAC/H,MAAM;MAChCF,UAAU,EAAEiI,iBAAiB,CAACjI;KAC/B;;EAEH,IAAMkI,mBAAmB,GAAAC,QAAA,KAAsChI,qBAAqB,CAAC4H,eAAe,CAAC,CAAE;EACvG,IAAIpI,MAAM,EAAE,EAAE;IACZ;IACA,IAAIuI,mBAAmB,CAACjI,aAAa,IAAIiI,mBAAmB,CAACjI,aAAa,GAAG,CAAC,KAAK,CAAC,EAAE;MACpFiI,mBAAmB,CAACjI,aAAa,GAAGiI,mBAAmB,CAACjI,aAAa,GAAG,CAAC,CAAC;;IAG5E,OAAO+H,qBAAqB,KAAKpH,SAAS,GAAGT,qBAAqB,CAAC6H,qBAAqB,CAAC,GAAGE,mBAAmB;;EAEjH,OAAOA,mBAAmB;AAC5B;AAEA;;;;;AAKA,SAASE,iBAAiBA,CACxB9D,YAA0C,EAC1CpB,MAAiB,EACjBxB,YAAuB,EACvB+D,WAAqB,EACrBK,eAAyB;EAEzB,IAAIxB,YAAY,CAACpE,MAAM,EAAE;IACvBoE,YAAY,CAACrE,aAAa,GAAGoI,cAAc,CAAC/D,YAAY,CAACtE,UAAU,EAAEkD,MAAM,EAAExB,YAAY,CAAC;;EAG5F4C,YAAY,CAACwB,eAAe,GAAGA,eAAe;EAC9C,OAAOxB,YAAY;AACrB;AAEA,SAAS+D,cAAcA,CAACrI,UAAyB,EAAEkD,MAAiB,EAAExB,YAAuB;EAC3F,IAAM4G,YAAY,GAAWpG,eAAe,CAACgB,MAAM,EAAElD,UAAU,CAAC;EAChE,IAAMuI,cAAc,GAAWrG,eAAe,CAACR,YAAY,EAAE1B,UAAU,CAAC;EAClE,IAAAI,EAAA,GAAiCgC,iBAAiB,CAACpC,UAAU,CAAC;IAA5DqC,YAAY,GAAAjC,EAAA,CAAAiC,YAAA;IAAEC,YAAY,GAAAlC,EAAA,CAAAkC,YAAkC;EACpE,IAAIgG,YAAY,IAAIC,cAAc,EAAE;IAClC,OAAOlG,YAAY;GACpB,MAAM;IACL,OAAOC,YAAY;;AAEvB;AAEA,SAASkG,4BAA4BA,CACnC5B,iBAA4B,EAC5B1D,MAAiB,EACjBiB,QAAmB,EACnBG,YAA0C,EAC1CnB,GAAW,EACXoB,YAAoB,EACpBH,yBAAkC,EAClCyB,oBAA8B,EAC9BJ,WAAqB;EAHrB,IAAAlB,YAAA;IAAAA,YAAA,QAAoB;EAAA;EAKpB,IAAMsC,wBAAwB,GAAcvB,iBAAiB,CAC3DsB,iBAAiB,EACjB1D,MAAM,EACNoB,YAAY,EACZnB,GAAG,EACHsC,WAAW,CACZ;EACD,IAAIjE,wBAAwB,CAACqF,wBAAwB,EAAE1C,QAAQ,CAAC,EAAE;IAChE,OAAO;MACLa,gBAAgB,EAAE6B,wBAAwB;MAC1C7G,UAAU,EAAEsE,YAAY,CAACtE,UAAU;MACnCC,aAAa,EAAEqE,YAAY,CAACrE;KAC7B;GACF,MAAM;IACL,OAAO0F,sBAAsB,CAC3BkB,wBAAwB,EACxB3D,MAAM,EACNiB,QAAQ,EACRG,YAAY,EACZC,YAAY,EACZH,yBAAyB,EACzBjB,GAAG,EACH0C,oBAAoB,EACpBJ,WAAW,CACZ;;AAEL;AAEA,SAASgD,qBAAqBA,CAC5BC,eAAqC,EACrCC,cAAyB,EACzBnF,MAAkB;EAElB,IAAMxD,UAAU,GAAG0I,eAAe,CAAC1I,UAAU,GAAG,CAAC,CAAC;EAClD;EACA,IAAM4I,aAAa,GAAG,IAAI9I,SAAS,CACjC,CAAC,EACD4I,eAAe,CAAC1D,gBAAgB,CAAC6D,KAAK,EACtC,CAAC,EACDH,eAAe,CAAC1D,gBAAgB,CAAC8D,MAAM,CACxC;EACD,IAAMtB,WAAW,GAAuB,EAAE;EAC1C,IAAMP,UAAU,GAAGD,mBAAmB,CACpC0B,eAAe,CAAC1D,gBAAgB,EAChC0D,eAAe,CAACzI,aAAa,GAAGyI,eAAe,CAACzI,aAAa,GAAGmC,iBAAiB,CAACpC,UAAU,CAAC,CAACqC,YAAY,EAC1GmB,MAAM,CACP;EAED;EACA,IAAMuF,kBAAkB,GAAGtG,0BAA0B,CACnDiG,eAAe,CAAC1D,gBAAgB,EAChC0D,eAAe,CAACM,eAAe,EAC/BhJ,UAAU,CACX;EACD,IAAMiJ,QAAQ,GAAGF,kBAAkB,GAAG/E,IAAI,CAACkD,GAAG,CAACpF,aAAa,CAAC6G,cAAc,EAAE3I,UAAU,CAAC,CAAC;EAEzFwH,WAAW,CAAC3H,aAAa,CAACG,UAAU,CAAC,CAAC,GAAG8B,aAAa,CAAC6G,cAAc,EAAE3I,UAAU,CAAC;EAClFwH,WAAW,CAAC3H,aAAa,CAACoH,UAAU,CAAC,CAAC,GAAGxE,0BAA0B,CAACkG,cAAc,EAAEC,aAAa,EAAE3B,UAAU,CAAC;EAE9G,OAAO;IACLyB,eAAe,EAAAP,QAAA,KAAOX,WAAW,CAAE;IACnC0B,WAAW,EAAEb,cAAc,CAACK,eAAe,CAAC1I,UAAU,EAAE2I,cAAc,EAAEC,aAAa,CAAC;IACtF5I,UAAU,EAAAA,UAAA;IACVmJ,QAAQ,EAAE,CAACF;GACZ;AACH;AAEA,SAASG,aAAaA,CAACxB,SAAiB,EAAEc,eAAqC;EAC7E,IAAMxF,MAAM,GAAGwF,eAAe,CAACM,eAAe;EAC9C;;;;;;EAMM,IAAA5I,EAAA,GAAiCgC,iBAAiB,CAACsG,eAAe,CAAC1I,UAAU,CAAC;IAA5EqC,YAAY,GAAAjC,EAAA,CAAAiC,YAAA;IAAEC,YAAY,GAAAlC,EAAA,CAAAkC,YAAkD;EACpF,IAAM+G,eAAe,GAAGnH,eAAe,CAACgB,MAAM,EAAEwF,eAAe,CAAC1I,UAAU,CAAC;EAC3E,IAAMsJ,aAAa,GAAG,IAAIxJ,SAAS,CACjC8H,SAAS,GAAG,CAAC,EACbc,eAAe,CAAC1D,gBAAgB,CAAC6D,KAAK,GAAGjB,SAAS,GAAG,CAAC,EACtDA,SAAS,GAAG,CAAC,EACbc,eAAe,CAAC1D,gBAAgB,CAAC8D,MAAM,GAAGlB,SAAS,GAAG,CAAC,CACxD;EAED,IAAI2B,YAAY,GAAc,IAAIzJ,SAAS,CAAC,CAAC,EAAE8H,SAAS,EAAE,CAAC,EAAEA,SAAS,CAAC;EAEvE2B,YAAY,GAAG3G,SAAS,CAAC2G,YAAY,EAAEb,eAAe,CAAC1I,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC4H,SAAS,GAAG,CAAC,CAAC;EAEvF2B,YAAY,GAAG/C,kBAAkB,CAC/B+C,YAAY,EACZb,eAAe,CAAC1I,UAAU,GAAG,CAAC,CAAC,EAC/BqJ,eAAe,GAAG7G,yBAAyB,CAACH,YAAY,EAAEqG,eAAe,CAAC1D,gBAAgB,CAAC,CAC5F;EAED,IAAI,CAACzB,eAAe,CAACgG,YAAY,EAAED,aAAa,EAAEjH,YAAY,CAAC,EAAE;IAC/DkH,YAAY,GAAGtG,WAAW,CAACsG,YAAY,EAAED,aAAa,EAAEjH,YAAY,CAAC;GACtE,MAAM,IAAI,CAACkB,eAAe,CAACgG,YAAY,EAAED,aAAa,EAAEhH,YAAY,CAAC,EAAE;IACtEiH,YAAY,GAAGtG,WAAW,CAACsG,YAAY,EAAED,aAAa,EAAEhH,YAAY,CAAC;;EAEvE,OAAOiH,YAAY;AACrB;AAEA,SAAS9B,wBAAwBA,CAAC7B,OAAgB;EAChD;EACA,IAAM4D,UAAU,GAAe5D,OAAO,CAAC6D,qBAAqB,EAAE;EAE9D,OAAO,IAAI3J,SAAS,CAAC0J,UAAU,CAACjJ,IAAI,EAAEiJ,UAAU,CAAC9I,KAAK,EAAE8I,UAAU,CAAClJ,GAAG,EAAEkJ,UAAU,CAAC1I,MAAM,CAAC;AAC5F;AAEA,SAAS4I,sBAAsBA,CAACjI,IAAgB;EAC9C,OAAO,IAAI3B,SAAS,CAAC2B,IAAI,CAAClB,IAAI,EAAEkB,IAAI,CAACf,KAAK,EAAEe,IAAI,CAACnB,GAAG,EAAEmB,IAAI,CAACX,MAAM,CAAC;AACpE;AAEA,SAAS6I,cAAcA,CAACnG,MAAiB,EAAEN,MAA4D;EACrG,IAAI8F,eAA0B;EAC9B,IAAI9F,MAAM,EAAE;IACV;IACA,IAAI,CAAC,CAAEA,MAAqB,CAAC0G,cAAc,EAAE;MAC3C,IAAMC,EAAE,GAAG3G,MAAoB;MAC/B8F,eAAe,GAAG,IAAIlJ,SAAS,CAAC+J,EAAE,CAACC,OAAO,EAAED,EAAE,CAACC,OAAO,EAAED,EAAE,CAACE,OAAO,EAAEF,EAAE,CAACE,OAAO,CAAC;MAC/E;KACD,MAAM,IAAI,CAAC,CAAE7G,MAAkB,CAACuG,qBAAqB,EAAE;MACtDT,eAAe,GAAGvB,wBAAwB,CAACvE,MAAiB,CAAC;MAC7D;KACD,MAAM;MACL,IAAM8G,WAAW,GAAsB9G,MAA2B;MAClE;MACA,IAAM3C,IAAI,GAAGyJ,WAAW,CAACzJ,IAAI,IAAIyJ,WAAW,CAACC,CAAC;MAC9C;MACA,IAAMC,KAAG,GAAGF,WAAW,CAAC1J,GAAG,IAAI0J,WAAW,CAACG,CAAC;MAC5C,IAAMzJ,KAAK,GAAGsJ,WAAW,CAACtJ,KAAK,IAAIH,IAAI;MACvC,IAAMO,MAAM,GAAGkJ,WAAW,CAAClJ,MAAM,IAAIoJ,KAAG;MACxClB,eAAe,GAAG,IAAIlJ,SAAS,CAACS,IAAI,EAAEG,KAAK,EAAEwJ,KAAG,EAAEpJ,MAAM,CAAC;;IAG3D,IAAI,CAACU,wBAAwB,CAACwH,eAAe,EAAExF,MAAM,CAAC,EAAE;MACtD,IAAM5B,WAAW,GAAoBD,oBAAoB,CAACqH,eAAe,EAAExF,MAAM,CAAC;MAElF,KAAwB,IAAAK,EAAA,IAAW,EAAXuG,aAAA,GAAAxI,WAAW,EAAXiC,EAAA,GAAAuG,aAAA,CAAArG,MAAW,EAAXF,EAAA,EAAW,EAAE;QAAhC,IAAMwC,SAAS,GAAA+D,aAAA,CAAAvG,EAAA;QACjBmF,eAAuB,CAACnJ,aAAa,CAACwG,SAAS,CAAC,CAAC,GAAI7C,MAAc,CAAC3D,aAAa,CAACwG,SAAS,CAAC,CAAC;;;GAGnG,MAAM;IACL2C,eAAe,GAAG,IAAIlJ,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;EAG7C,OAAOkJ,eAAe;AACxB;AAEA;;;AAGA,SAASqB,gCAAgCA,CACvCrB,eAA0B,EAC1BhJ,UAA2B,EAC3BsK,QAAgB,EAChB9G,MAAiB,EACjBiC,WAAqB;EAErB,IAAI8E,SAAS,GAAG,CAAC;EACjB,IAAMxC,eAAe,GAAG5H,qBAAqB,CAACH,UAAU,CAAC;EAEzD;EACA;EACA;EACA;EACA;EACA,IAAMkD,MAAM,GAAGuC,WAAW,GAAGsC,eAAe,CAAC/H,UAAU,GAAG,CAAC,CAAC,GAAG+H,eAAe,CAAC/H,UAAU;EAEzF,IAAIkD,MAAM,KAAKrD,aAAa,CAACS,GAAG,EAAE;IAChCiK,SAAS,GAAGzI,aAAa,CAACkH,eAAe,EAAEjB,eAAe,CAAC/H,UAAU,CAAC,GAAGwD,MAAM,CAAClD,GAAG,GAAGgK,QAAQ;GAC/F,MAAM,IAAIpH,MAAM,KAAKrD,aAAa,CAACiB,MAAM,EAAE;IAC1CyJ,SAAS,GAAG/G,MAAM,CAAC1C,MAAM,GAAGgB,aAAa,CAACkH,eAAe,EAAEjB,eAAe,CAAC/H,UAAU,CAAC,GAAGsK,QAAQ;GAClG,MAAM;IACLC,SAAS,GAAG/G,MAAM,CAAC1C,MAAM,GAAGkI,eAAe,CAAC1I,GAAG,GAAGgK,QAAQ;;EAG5D,OAAOC,SAAS,GAAG,CAAC,GAAGA,SAAS,GAAG/G,MAAM,CAACsF,MAAM;AAClD;AAEA,SAAS0B,wBAAwBA,CAC/BC,KAAqB,EACrB7D,iBAA8B,EAC9BlF,YAAuB,EACvBuG,iBAAmC,EACnC1D,YAAoB,EACpBH,yBAAkC;EADlC,IAAAG,YAAA;IAAAA,YAAA,QAAoB;EAAA;EAGpB,IAAMpB,GAAG,GAAWsH,KAAK,CAACH,QAAQ,GAAGG,KAAK,CAACH,QAAQ,GAAG,CAAC;EACvD,IAAMI,UAAU,GAAcf,cAAc,CAACjI,YAAY,EAAE+I,KAAK,CAACvH,MAAM,CAAC;EACxE,IAAMoB,YAAY,GAAiC8D,iBAAiB,CAClEN,gBAAgB,CAAC2C,KAAK,CAAC1C,eAAe,EAAE0C,KAAK,CAACzC,qBAAqB,EAAEC,iBAAiB,CAAE,EACxFyC,UAAU,EACVhJ,YAAY,EACZ+I,KAAK,CAAChF,WAAW,EACjBgF,KAAK,CAAC3E,eAAe,CACtB;EACD,IAAM6E,iBAAiB,GAAqBnC,4BAA4B,CACtEf,wBAAwB,CAACb,iBAAiB,CAAC,EAC3C8D,UAAU,EACVhJ,YAAY,EACZ4C,YAAY,EACZnB,GAAG,EACHoB,YAAY,EACZH,yBAAyB,EACzBqG,KAAK,CAAC5E,oBAAoB,EAC1B4E,KAAK,CAAChF,WAAW,CAClB;EACD,OAAA0C,QAAA,CAAAA,QAAA,KAAYwC,iBAAiB;IAAE3B,eAAe,EAAE0B;EAAU;AAC5D;AAEA,SAASE,qBAAqBA,CAC5BD,iBAAmC,EACnCtD,WAAwB,EACxB7D,MAAkB,EAClBiC,WAAqB,EACrB6B,uBAAiC;EAEjC,IAAMuD,gBAAgB,GAAuBzD,wBAAwB,CACnEuD,iBAAiB,CAAC3F,gBAAgB,EAClCqC,WAAW,EACXsD,iBAAiB,CAAC3K,UAAU,EAC5BwD,MAAM,EACNmH,iBAAiB,CAAC1K,aAAa,EAC/BwF,WAAW,EACX6B,uBAAuB,EACvBqD,iBAAiB,CAAC1F,cAAc,CACjC;EACD,OAAO;IACLyD,eAAe,EAAEmC,gBAAgB;IACjC7K,UAAU,EAAE2K,iBAAiB,CAAC3K,UAAU;IACxCC,aAAa,EAAE0K,iBAAiB,CAAC1K;GAClC;AACH;AAEA,SAAS6K,gBAAgBA,CACvBL,KAAqB,EACrBpD,WAAwB,EACxBT,iBAA8B,EAC9BqB,iBAAmC,EACnC8C,GAAY;EAEZ,IAAMC,MAAM,GAAGD,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAInL,SAAS,EAAG;EAClC,IAAM8B,YAAY,GAAc+I,KAAK,CAACjH,MAAM,GACxCkG,sBAAsB,CAACe,KAAK,CAACjH,MAAM,CAAC,GACpC,IAAI1D,SAAS,CAAC,CAAC,EAAEkL,MAAM,CAACC,UAAU,GAAGvL,iBAAiB,EAAE,EAAE,CAAC,EAAEsL,MAAM,CAACE,WAAW,CAAC;EACpF,IAAMP,iBAAiB,GAAqBH,wBAAwB,CAClEC,KAAK,EACL7D,iBAAiB,EACjBlF,YAAY,EACZuG,iBAAiB,CAClB;EACD,OAAO2C,qBAAqB,CAACD,iBAAiB,EAAEtD,WAAW,EAAE3F,YAAY,EAAE+I,KAAK,CAAChF,WAAW,CAAC;AAC/F;AAEA,SAAS0F,kBAAkBA,CAACC,aAAkC,EAAExD,SAAa,EAAE0C,QAAY;EAA3B,IAAA1C,SAAA;IAAAA,SAAA,IAAa;EAAA;EAAE,IAAA0C,QAAA;IAAAA,QAAA,IAAY;EAAA;EACzF,OAAO3C,iCAAiC,CAACyD,aAAa,GAAGxD,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG0C,QAAQ;AACxF;AAEA,SAASe,gBAAgBA,CACvBZ,KAA4B,EAC5BpD,WAAwB,EACxBiE,OAAoB,EACpBrD,iBAA0C,EAC1C1D,YAAoB,EACpBH,yBAAkC,EAClCkD,uBAAiC,EACjCyD,GAAY;EAHZ,IAAAxG,YAAA;IAAAA,YAAA,QAAoB;EAAA;EAKpB,IAAMyG,MAAM,GAAGD,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAInL,SAAS,EAAG;EAClC,IAAMgI,SAAS,GAAW6C,KAAK,CAACW,aAAa,GAAGX,KAAK,CAAC7C,SAAS,IAAI,CAAC,GAAG,CAAC;EACxE,IAAMzE,GAAG,GAAGgI,kBAAkB,CAACV,KAAK,CAACW,aAAa,EAAEX,KAAK,CAAC7C,SAAS,EAAE6C,KAAK,CAACH,QAAQ,CAAC;EACpF,IAAMiB,aAAa,GAAmBd,KAAK;EAC3Cc,aAAa,CAACjB,QAAQ,GAAGnH,GAAG;EAC5B,IAAMzB,YAAY,GAAc+I,KAAK,CAACjH,MAAM,GACxCkG,sBAAsB,CAACe,KAAK,CAACjH,MAAM,CAAC,GACpC,IAAI1D,SAAS,CAAC,CAAC,EAAEkL,MAAM,CAACC,UAAU,GAAGvL,iBAAiB,EAAE,EAAE,CAAC,EAAEsL,MAAM,CAACE,WAAW,CAAC;EAEpF,IAAMP,iBAAiB,GAAyBH,wBAAwB,CACtEe,aAAa,EACbD,OAAO,EACP5J,YAAY,EACZuG,iBAAiB,EACjB1D,YAAY,EACZH,yBAAyB,CAC1B;EAED,IAAMoH,cAAc,GAAcpC,aAAa,CAACxB,SAAS,EAAE+C,iBAAiB,CAAC;EAC7E,IAAMc,qBAAqB,GAA+BhD,qBAAqB,CAC7EkC,iBAAiB,EACjBa,cAAc,EACd9J,YAAY,CACb;EAED,OAAAyG,QAAA,CAAAA,QAAA,KACKyC,qBAAqB,CAACD,iBAAiB,EAAEtD,WAAW,EAAE3F,YAAY,EAAE+I,KAAK,CAAChF,WAAW,EAAE6B,uBAAuB,CAAC;IAClHiC,YAAY,EAAEkC;EAAqB;AAEvC;AAEA,SAASC,aAAaA,CACpBjB,KAA4B,EAC5BpD,WAAwB,EACxBiE,OAAoB,EACpBrD,iBAA0C,EAC1C8C,GAAY;EAEZ,IAAMC,MAAM,GAAGD,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAInL,SAAS,EAAG;EAClC,OAAOyL,gBAAgB,CAACZ,KAAK,EAAEpD,WAAW,EAAEiE,OAAO,EAAErD,iBAAiB,EAAE,KAAK,EAAErH,SAAS,EAAE,IAAI,EAAEoK,MAAM,CAAC;AACzG;AAEA,SAASW,uBAAuBA,CAACzI,MAAgD;;EAC/E,IAAM0I,WAAW,GAAe1I,MAAoB;EACpD,IAAM2I,aAAa,GAAY3I,MAAiB;EAChD,IAAM4I,iBAAiB,GAAsB5I,MAA2B;EACxE,IAAIwH,UAAqB;EAEzB;EACA,IAAMnK,IAAI,GAAG,CAAAH,EAAA,GAAA0L,iBAAiB,CAACvL,IAAI,cAAAH,EAAA,cAAAA,EAAA,GAAI0L,iBAAiB,CAAC7B,CAAC;EAC1D;EACA,IAAM3J,GAAG,GAAG,CAAAyL,EAAA,GAAAD,iBAAiB,CAACxL,GAAG,cAAAyL,EAAA,cAAAA,EAAA,GAAID,iBAAiB,CAAC3B,CAAC;EACxD,IAAMzJ,KAAK,GAAG,CAAAsL,EAAA,GAAAF,iBAAiB,CAACpL,KAAK,cAAAsL,EAAA,cAAAA,EAAA,GAAIzL,IAAI;EAC7C,IAAMO,MAAM,GAAG,CAAAmL,EAAA,GAAAH,iBAAiB,CAAChL,MAAM,cAAAmL,EAAA,cAAAA,EAAA,GAAI3L,GAAG;EAE9C;EACA,IAAI,CAAC,CAACsL,WAAW,CAACM,eAAe,EAAE;IACjCxB,UAAU,GAAG,IAAI5K,SAAS,CAAC8L,WAAW,CAAC9B,OAAO,EAAE8B,WAAW,CAAC9B,OAAO,EAAE8B,WAAW,CAAC7B,OAAO,EAAE6B,WAAW,CAAC7B,OAAO,CAAC;GAC/G,MAAM,IAAIxJ,IAAI,KAAKK,SAAS,IAAIN,GAAG,KAAKM,SAAS,EAAE;IAClD8J,UAAU,GAAG,IAAI5K,SAAS,CAACS,IAAI,EAAEG,KAAK,EAAEJ,GAAG,EAAEQ,MAAM,CAAC;GACrD,MAAM;IACL4J,UAAU,GAAGjD,wBAAwB,CAACoE,aAAa,CAAC;;EAGtD,OAAOnB,UAAU;AACnB;AACA;AAEA,OAAO,IAAMyB,wBAAwB,GAAG;EACtCvB,qBAAqB,EAAAA,qBAAA;EACrBnC,qBAAqB,EAAAA,qBAAA;EACrBd,iCAAiC,EAAAA,iCAAA;EACjCa,4BAA4B,EAAAA,4BAAA;EAC5BY,aAAa,EAAAA,aAAA;EACbtB,gBAAgB,EAAAA,gBAAA;EAChBuC,gCAAgC,EAAAA;CACjC;AAED;;;;;AAKA,OAAM,SAAU+B,eAAeA,CAC7B3B,KAAqB,EACrBpD,WAAwB,EACxBT,iBAA8B,EAC9BqB,iBAAmC,EACnC8C,GAAY;EAEZ,OAAOD,gBAAgB,CAACL,KAAK,EAAEpD,WAAW,EAAET,iBAAiB,EAAEqB,iBAAiB,EAAE8C,GAAG,CAAC;AACxF;AAEA,OAAM,SAAUsB,eAAeA,CAC7B5B,KAAqB,EACrBpD,WAAwB,EACxBT,iBAA8B,EAC9BqB,iBAA0C,EAC1C1D,YAAsB,EACtBH,yBAAkC,EAClC2G,GAAY;EAEZ,OAAOM,gBAAgB,CACrBZ,KAAK,EACLpD,WAAW,EACXT,iBAAiB,EACjBqB,iBAAiB,EACjB1D,YAAY,EACZH,yBAAyB,EACzBxD,SAAS,EACTmK,GAAG,CACJ;AACH;AAEA,OAAM,SAAUuB,YAAYA,CAC1B7B,KAAqB,EACrBpD,WAAwB,EACxBT,iBAA8B,EAC9BqB,iBAA0C,EAC1C8C,GAAY;EAEZ,OAAOW,aAAa,CAACjB,KAAK,EAAEpD,WAAW,EAAET,iBAAiB,EAAEqB,iBAAiB,EAAE8C,GAAG,CAAC;AACrF;AAEA;;;;;;AAMA,OAAM,SAAUwB,YAAYA,CAC1BrJ,MAAgD,EAChDlD,UAA2B,EAC3BsK,QAAoB,EACpB9G,MAAmB,EACnBiC,WAAqB,EACrBsF,GAAY;EAHZ,IAAAT,QAAA;IAAAA,QAAA,IAAoB;EAAA;EAKpB,IAAMU,MAAM,GAAGD,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAInL,SAAS,EAAG;EAClC,IAAM8K,UAAU,GAAGiB,uBAAuB,CAACzI,MAAM,CAAC;EAClD,IAAMsJ,iBAAiB,GAAGhJ,MAAM,GAC5BkG,sBAAsB,CAAClG,MAAM,CAAC,GAC9B,IAAI1D,SAAS,CAAC,CAAC,EAAEkL,MAAM,CAACC,UAAU,GAAGvL,iBAAiB,EAAE,EAAE,CAAC,EAAEsL,MAAM,CAACE,WAAW,CAAC;EAEpF,OAAOb,gCAAgC,CAACK,UAAU,EAAE1K,UAAU,EAAEsK,QAAQ,EAAEkC,iBAAiB,EAAE/G,WAAW,CAAC;AAC3G;AAEA;;;AAGA,OAAM,SAAUiC,eAAeA,CAAC3F,IAAmB;EACjD,OAAOA,IAAI,GAAG,CAAC,CAAC;AAClB;AAEA,SAAS0K,0BAA0BA,CACjCvJ,MAAuD,EACvDwJ,YAAiC;EAEjC,IAAIC,QAAQ,GAAG/L,SAAS;EACxB,IAAI8L,YAAY,CAACE,iBAAiB,EAAE;IAClCD,QAAQ,GAAGD,YAAY,CAACE,iBAAiB,EAAE;;EAG7C;EACA,IAAID,QAAQ,KAAK/L,SAAS,IAAI+L,QAAQ,CAAC5I,MAAM,IAAI,CAAC,EAAE;IAClD,OAAO;MACLzD,GAAG,EAAE,CAAC;MACNC,IAAI,EAAE,CAAC;MACPG,KAAK,EAAEgM,YAAY,CAACzB,UAAU;MAC9BnK,MAAM,EAAE4L,YAAY,CAACxB,WAAW;MAChCrC,KAAK,EAAE6D,YAAY,CAACzB,UAAU;MAC9BnC,MAAM,EAAE4D,YAAY,CAACxB;KACtB;;EAGH;EACA,IAAIjB,CAAC,GAAuB,CAAC;EAC7B,IAAIE,CAAC,GAAuB,CAAC;EAE7B;EACA,IAAIjH,MAAM,KAAK,IAAI,IAAI,CAAC,CAAEA,MAAkB,CAACuG,qBAAqB,EAAE;IAClE,IAAMD,UAAU,GAAItG,MAAkB,CAACuG,qBAAqB,EAAE;IAC9DQ,CAAC,GAAG,CAACT,UAAU,CAACjJ,IAAI,GAAGiJ,UAAU,CAAC9I,KAAK,IAAI,CAAC;IAC5CyJ,CAAC,GAAG,CAACX,UAAU,CAAClJ,GAAG,GAAGkJ,UAAU,CAAC1I,MAAM,IAAI,CAAC;;EAE9C;EAAA,KACK,IAAIoC,MAAM,KAAK,IAAI,EAAE;IACxB;IACA+G,CAAC,GAAI/G,MAAgB,CAAC3C,IAAI,IAAK2C,MAA6B,CAAC+G,CAAC;IAC9D;IACAE,CAAC,GAAIjH,MAAgB,CAAC5C,GAAG,IAAK4C,MAA6B,CAACiH,CAAC;;EAG/D,IAAI3G,MAAM,GAAG;IAAElD,GAAG,EAAE,CAAC;IAAEC,IAAI,EAAE,CAAC;IAAEG,KAAK,EAAE,CAAC;IAAEI,MAAM,EAAE,CAAC;IAAE+H,KAAK,EAAE,CAAC;IAAEC,MAAM,EAAE;EAAC,CAAE;EAE1E;EACA,KAAsB,IAAAjF,EAAA,IAAQ,EAARgJ,UAAA,GAAAF,QAAQ,EAAR9I,EAAA,GAAAgJ,UAAA,CAAA9I,MAAQ,EAARF,EAAA,EAAQ,EAAE;IAA3B,IAAMiJ,OAAO,GAAAD,UAAA,CAAAhJ,EAAA;IAChB,IAAIoG,CAAC,IAAI6C,OAAO,CAACvM,IAAI,IAAI0J,CAAC,IAAI6C,OAAO,CAACpM,KAAK,IAAIuJ,CAAC,IAAIE,CAAC,IAAI2C,OAAO,CAACxM,GAAG,IAAI6J,CAAC,IAAI2C,OAAO,CAAChM,MAAM,IAAIqJ,CAAC,EAAE;MAChG3G,MAAM,GAAG;QACPlD,GAAG,EAAEwM,OAAO,CAACxM,GAAG;QAChBC,IAAI,EAAEuM,OAAO,CAACvM,IAAI;QAClBG,KAAK,EAAEoM,OAAO,CAACpM,KAAK;QACpBI,MAAM,EAAEgM,OAAO,CAAChM,MAAM;QACtB+H,KAAK,EAAEiE,OAAO,CAACjE,KAAK;QACpBC,MAAM,EAAEgE,OAAO,CAAChE;OACjB;;;EAIL,OAAOtF,MAAM;AACf;AAEA,OAAM,SAAUuJ,yBAAyBA,CACvC7J,MAAuD,EACvDwJ,YAAiC;EAEjC,OAAOD,0BAA0B,CAACvJ,MAAM,EAAEwJ,YAAY,CAAC;AACzD;AAEA,OAAM,SAAUM,iBAAiBA,CAC/B5B,aAAkC,EAClCxD,SAA6B,EAC7B0C,QAA4B;EAE5B,OAAOa,kBAAkB,CAACC,aAAa,EAAExD,SAAS,EAAE0C,QAAQ,CAAC;AAC/D;AAEA,OAAM,SAAU2C,sBAAsBA,CAAC/J,MAAgD;EACrF,OAAOyI,uBAAuB,CAACzI,MAAM,CAAC;AACxC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}